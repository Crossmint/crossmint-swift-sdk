// Generated by swift-openapi-generator, do not modify.
// swiftlint:disable all
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Crossmint Wallets API
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitMeApprovals-5)`.
    public func walletsV1ControllerSubmitMeApprovals5(_ input: Operations.WalletsV1ControllerSubmitMeApprovals5.Input) async throws -> Operations.WalletsV1ControllerSubmitMeApprovals5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeApprovals5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/get(WalletsV1Controller-getMeTransaction-5)`.
    public func walletsV1ControllerGetMeTransaction5(_ input: Operations.WalletsV1ControllerGetMeTransaction5.Input) async throws -> Operations.WalletsV1ControllerGetMeTransaction5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransaction5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/transactions/get(WalletsV1Controller-getMeTransactionsWithoutChain-5)`.
    public func walletsV1ControllerGetMeTransactionsWithoutChain5(_ input: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.Input) async throws -> Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/transactions/post(WalletsV1Controller-createMeTransaction-5)`.
    public func walletsV1ControllerCreateMeTransaction5(_ input: Operations.WalletsV1ControllerCreateMeTransaction5.Input) async throws -> Operations.WalletsV1ControllerCreateMeTransaction5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeTransaction5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction5.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signers/{signer}/get(WalletsV1Controller-getMeDelegatedSigner-5)`.
    public func walletsV1ControllerGetMeDelegatedSigner5(_ input: Operations.WalletsV1ControllerGetMeDelegatedSigner5.Input) async throws -> Operations.WalletsV1ControllerGetMeDelegatedSigner5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeDelegatedSigner5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/signers`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signers/post(WalletsV1Controller-createMeDelegatedSigner-5)`.
    public func walletsV1ControllerCreateMeDelegatedSigner5(_ input: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Input) async throws -> Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signers",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitMeSignatureApprovals-5)`.
    public func walletsV1ControllerSubmitMeSignatureApprovals5(_ input: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Input) async throws -> Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/get(WalletsV1Controller-getMeSignature-5)`.
    public func walletsV1ControllerGetMeSignature5(_ input: Operations.WalletsV1ControllerGetMeSignature5.Input) async throws -> Operations.WalletsV1ControllerGetMeSignature5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeSignature5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/signatures`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signatures/post(WalletsV1Controller-createMeSignatureRequest-5)`.
    public func walletsV1ControllerCreateMeSignatureRequest5(_ input: Operations.WalletsV1ControllerCreateMeSignatureRequest5.Input) async throws -> Operations.WalletsV1ControllerCreateMeSignatureRequest5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeSignatureRequest5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/activity`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/activity/get(WalletsV1Controller-getMeWalletActivity-5)`.
    public func walletsV1ControllerGetMeWalletActivity5(_ input: Operations.WalletsV1ControllerGetMeWalletActivity5.Input) async throws -> Operations.WalletsV1ControllerGetMeWalletActivity5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWalletActivity5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/activity",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/get(WalletsV1Controller-getMeWallet-5)`.
    public func walletsV1ControllerGetMeWallet5(_ input: Operations.WalletsV1ControllerGetMeWallet5.Input) async throws -> Operations.WalletsV1ControllerGetMeWallet5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWallet5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWallet5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me/post(WalletsV1Controller-createMeWallet-5)`.
    public func walletsV1ControllerCreateMeWallet5(_ input: Operations.WalletsV1ControllerCreateMeWallet5.Input) async throws -> Operations.WalletsV1ControllerCreateMeWallet5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeWallet5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeWallet5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitApprovals-5)`.
    public func walletsV1ControllerSubmitApprovals5(_ input: Operations.WalletsV1ControllerSubmitApprovals5.Input) async throws -> Operations.WalletsV1ControllerSubmitApprovals5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitApprovals5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV1Controller-getTransaction-5)`.
    public func walletsV1ControllerGetTransaction5(_ input: Operations.WalletsV1ControllerGetTransaction5.Input) async throws -> Operations.WalletsV1ControllerGetTransaction5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransaction5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/transactions/get(WalletsV1Controller-getTransactionsWithoutChain-5)`.
    public func walletsV1ControllerGetTransactionsWithoutChain5(_ input: Operations.WalletsV1ControllerGetTransactionsWithoutChain5.Input) async throws -> Operations.WalletsV1ControllerGetTransactionsWithoutChain5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransactionsWithoutChain5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/transactions/post(WalletsV1Controller-createTransaction-5)`.
    public func walletsV1ControllerCreateTransaction5(_ input: Operations.WalletsV1ControllerCreateTransaction5.Input) async throws -> Operations.WalletsV1ControllerCreateTransaction5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateTransaction5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction5.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signers/{signer}/get(WalletsV1Controller-getDelegatedSigner-5)`.
    public func walletsV1ControllerGetDelegatedSigner5(_ input: Operations.WalletsV1ControllerGetDelegatedSigner5.Input) async throws -> Operations.WalletsV1ControllerGetDelegatedSigner5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetDelegatedSigner5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signers/post(WalletsV1Controller-createDelegatedSigner-5)`.
    public func walletsV1ControllerCreateDelegatedSigner5(_ input: Operations.WalletsV1ControllerCreateDelegatedSigner5.Input) async throws -> Operations.WalletsV1ControllerCreateDelegatedSigner5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateDelegatedSigner5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitSignatureApprovals-5)`.
    public func walletsV1ControllerSubmitSignatureApprovals5(_ input: Operations.WalletsV1ControllerSubmitSignatureApprovals5.Input) async throws -> Operations.WalletsV1ControllerSubmitSignatureApprovals5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitSignatureApprovals5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV1Controller-getSignature-5)`.
    public func walletsV1ControllerGetSignature5(_ input: Operations.WalletsV1ControllerGetSignature5.Input) async throws -> Operations.WalletsV1ControllerGetSignature5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetSignature5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signatures/get(WalletsV1Controller-getAllSignatures-5)`.
    public func walletsV1ControllerGetAllSignatures5(_ input: Operations.WalletsV1ControllerGetAllSignatures5.Input) async throws -> Operations.WalletsV1ControllerGetAllSignatures5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetAllSignatures5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2MultipleSignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signatures/post(WalletsV1Controller-createSignatureRequest-5)`.
    public func walletsV1ControllerCreateSignatureRequest5(_ input: Operations.WalletsV1ControllerCreateSignatureRequest5.Input) async throws -> Operations.WalletsV1ControllerCreateSignatureRequest5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateSignatureRequest5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/balances/get(BalanceController-getBalanceForLocator-2)`.
    public func balanceControllerGetBalanceForLocator2(_ input: Operations.BalanceControllerGetBalanceForLocator2.Input) async throws -> Operations.BalanceControllerGetBalanceForLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceControllerGetBalanceForLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerGetBalanceForLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerGetBalanceForLocator2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Fund Wallet
    ///
    /// Send funds to a wallet.
    ///
    /// **API scope required**: `wallets.fund`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/balances/post(BalanceController-fundWallet-2)`.
    public func balanceControllerFundWallet2(_ input: Operations.BalanceControllerFundWallet2.Input) async throws -> Operations.BalanceControllerFundWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceControllerFundWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerFundWallet2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerFundWallet2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/activity/get(WalletsV1Controller-getWalletActivity-5)`.
    public func walletsV1ControllerGetWalletActivity5(_ input: Operations.WalletsV1ControllerGetWalletActivity5.Input) async throws -> Operations.WalletsV1ControllerGetWalletActivity5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletActivity5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/get(WalletsV1Controller-getWalletByLocator-5)`.
    public func walletsV1ControllerGetWalletByLocator5(_ input: Operations.WalletsV1ControllerGetWalletByLocator5.Input) async throws -> Operations.WalletsV1ControllerGetWalletByLocator5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletByLocator5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When linkedUser is provided, subsequent calls with the same linkedUser will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/post(WalletsV1Controller-createWallet-5)`.
    public func walletsV1ControllerCreateWallet5(_ input: Operations.WalletsV1ControllerCreateWallet5.Input) async throws -> Operations.WalletsV1ControllerCreateWallet5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateWallet5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify wallet ownership
    ///
    /// Verifies wallet ownership by a given email.
    ///
    /// - Remark: HTTP `POST /unstable/wallets/verify-ownership`.
    /// - Remark: Generated from `#/paths//unstable/wallets/verify-ownership/post(WalletsVerifyRecipientController-verifyWalletOwnership-2)`.
    public func walletsVerifyRecipientControllerVerifyWalletOwnership2(_ input: Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership2.Input) async throws -> Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/verify-ownership",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token For Authenticated User
    ///
    /// Sends a token of any type from the authenticated user's wallet to a recipient
    ///
    /// - Remark: HTTP `POST /unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenController-sendMeToken-2)`.
    public func walletsSendTokenControllerSendMeToken2(_ input: Operations.WalletsSendTokenControllerSendMeToken2.Input) async throws -> Operations.WalletsSendTokenControllerSendMeToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenControllerSendMeToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/me{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletType,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenControllerSendMeToken2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User (Unstable)
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events. This is an unstable API that may change without notice.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /unstable/wallets/me{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//unstable/wallets/me{walletLocator}/activity/get(WalletActivityUnstableController-getMeWalletActivity-2)`.
    public func walletActivityUnstableControllerGetMeWalletActivity2(_ input: Operations.WalletActivityUnstableControllerGetMeWalletActivity2.Input) async throws -> Operations.WalletActivityUnstableControllerGetMeWalletActivity2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletActivityUnstableControllerGetMeWalletActivity2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/me{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetMeWalletActivity2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsActivityResponseUnstableDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetMeWalletActivity2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token
    ///
    /// Sends a token of any type from this wallet to a recipient
    ///
    /// - Remark: HTTP `POST /unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenController-sendToken-2)`.
    public func walletsSendTokenControllerSendToken2(_ input: Operations.WalletsSendTokenControllerSendToken2.Input) async throws -> Operations.WalletsSendTokenControllerSendToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenControllerSendToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenControllerSendToken2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseWithSendParamsDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /unstable/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//unstable/wallets/{walletLocator}/balances/get(BalanceUnstableController-getBalanceForLocator-2)`.
    public func balanceUnstableControllerGetBalanceForLocator2(_ input: Operations.BalanceUnstableControllerGetBalanceForLocator2.Input) async throws -> Operations.BalanceUnstableControllerGetBalanceForLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceUnstableControllerGetBalanceForLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceUnstableControllerGetBalanceForLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceUnstableResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceUnstableControllerGetBalanceForLocator2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity (Unstable)
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events. This is an unstable API that may change without notice.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /unstable/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//unstable/wallets/{walletLocator}/activity/get(WalletActivityUnstableController-getWalletActivity-2)`.
    public func walletActivityUnstableControllerGetWalletActivity2(_ input: Operations.WalletActivityUnstableControllerGetWalletActivity2.Input) async throws -> Operations.WalletActivityUnstableControllerGetWalletActivity2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletActivityUnstableControllerGetWalletActivity2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetWalletActivity2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsActivityResponseUnstableDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetWalletActivity2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV2025Controller-submitMeApprovals-2)`.
    public func walletsV2025ControllerSubmitMeApprovals2(_ input: Operations.WalletsV2025ControllerSubmitMeApprovals2.Input) async throws -> Operations.WalletsV2025ControllerSubmitMeApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitMeApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/get(WalletsV2025Controller-getMeTransaction-2)`.
    public func walletsV2025ControllerGetMeTransaction2(_ input: Operations.WalletsV2025ControllerGetMeTransaction2.Input) async throws -> Operations.WalletsV2025ControllerGetMeTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransaction2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/transactions/get(WalletsV2025Controller-getMeTransactionsWithoutChain-2)`.
    public func walletsV2025ControllerGetMeTransactionsWithoutChain2(_ input: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.Input) async throws -> Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/transactions/post(WalletsV2025Controller-createMeTransaction-2)`.
    public func walletsV2025ControllerCreateMeTransaction2(_ input: Operations.WalletsV2025ControllerCreateMeTransaction2.Input) async throws -> Operations.WalletsV2025ControllerCreateMeTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token For Authenticated User
    ///
    /// Sends a token of any type from the authenticated user's wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenV2025Controller-sendMeToken-2)`.
    public func walletsSendTokenV2025ControllerSendMeToken2(_ input: Operations.WalletsSendTokenV2025ControllerSendMeToken2.Input) async throws -> Operations.WalletsSendTokenV2025ControllerSendMeToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenV2025ControllerSendMeToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenV2025ControllerSendMeToken2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signers/{signer}/get(WalletsV2025Controller-getMeDelegatedSigner-2)`.
    public func walletsV2025ControllerGetMeDelegatedSigner2(_ input: Operations.WalletsV2025ControllerGetMeDelegatedSigner2.Input) async throws -> Operations.WalletsV2025ControllerGetMeDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeDelegatedSigner2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signers/post(WalletsV2025Controller-createMeDelegatedSigner-2)`.
    public func walletsV2025ControllerCreateMeDelegatedSigner2(_ input: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Input) async throws -> Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV2025Controller-submitMeSignatureApprovals-2)`.
    public func walletsV2025ControllerSubmitMeSignatureApprovals2(_ input: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Input) async throws -> Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/get(WalletsV2025Controller-getMeSignature-2)`.
    public func walletsV2025ControllerGetMeSignature2(_ input: Operations.WalletsV2025ControllerGetMeSignature2.Input) async throws -> Operations.WalletsV2025ControllerGetMeSignature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeSignature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignature2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignature2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Signatures For Authenticated User
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signatures/get(WalletsV2025Controller-getMeSignatures-2)`.
    public func walletsV2025ControllerGetMeSignatures2(_ input: Operations.WalletsV2025ControllerGetMeSignatures2.Input) async throws -> Operations.WalletsV2025ControllerGetMeSignatures2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeSignatures2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignatures2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignatures2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signatures/post(WalletsV2025Controller-createMeSignatureRequest-2)`.
    public func walletsV2025ControllerCreateMeSignatureRequest2(_ input: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Input) async throws -> Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/get(WalletsV2025Controller-getMeWallet-2)`.
    public func walletsV2025ControllerGetMeWallet2(_ input: Operations.WalletsV2025ControllerGetMeWallet2.Input) async throws -> Operations.WalletsV2025ControllerGetMeWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeWallet2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me/post(WalletsV2025Controller-createMeWallet-2)`.
    public func walletsV2025ControllerCreateMeWallet2(_ input: Operations.WalletsV2025ControllerCreateMeWallet2.Input) async throws -> Operations.WalletsV2025ControllerCreateMeWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeWallet2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV2025Controller-submitApprovals-2)`.
    public func walletsV2025ControllerSubmitApprovals2(_ input: Operations.WalletsV2025ControllerSubmitApprovals2.Input) async throws -> Operations.WalletsV2025ControllerSubmitApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV2025Controller-getTransaction-2)`.
    public func walletsV2025ControllerGetTransaction2(_ input: Operations.WalletsV2025ControllerGetTransaction2.Input) async throws -> Operations.WalletsV2025ControllerGetTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransaction2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/transactions/get(WalletsV2025Controller-getTransactionsWithoutChain-2)`.
    public func walletsV2025ControllerGetTransactionsWithoutChain2(_ input: Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.Input) async throws -> Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/transactions/post(WalletsV2025Controller-createTransaction-2)`.
    public func walletsV2025ControllerCreateTransaction2(_ input: Operations.WalletsV2025ControllerCreateTransaction2.Input) async throws -> Operations.WalletsV2025ControllerCreateTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token
    ///
    /// Sends a token of any type from this wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenV2025Controller-sendToken-2)`.
    public func walletsSendTokenV2025ControllerSendToken2(_ input: Operations.WalletsSendTokenV2025ControllerSendToken2.Input) async throws -> Operations.WalletsSendTokenV2025ControllerSendToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenV2025ControllerSendToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenV2025ControllerSendToken2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signers/{signer}/get(WalletsV2025Controller-getDelegatedSigner-2)`.
    public func walletsV2025ControllerGetDelegatedSigner2(_ input: Operations.WalletsV2025ControllerGetDelegatedSigner2.Input) async throws -> Operations.WalletsV2025ControllerGetDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetDelegatedSigner2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Delegated Signer
    ///
    /// Create a delegated signer for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signers/post(WalletsV2025Controller-createDelegatedSigner-2)`.
    public func walletsV2025ControllerCreateDelegatedSigner2(_ input: Operations.WalletsV2025ControllerCreateDelegatedSigner2.Input) async throws -> Operations.WalletsV2025ControllerCreateDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV2025Controller-submitSignatureApprovals-2)`.
    public func walletsV2025ControllerSubmitSignatureApprovals2(_ input: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Input) async throws -> Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV2025Controller-getSignature-2)`.
    public func walletsV2025ControllerGetSignature2(_ input: Operations.WalletsV2025ControllerGetSignature2.Input) async throws -> Operations.WalletsV2025ControllerGetSignature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetSignature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetSignature2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetSignature2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signatures/get(WalletsV2025Controller-getAllSignatures-2)`.
    public func walletsV2025ControllerGetAllSignatures2(_ input: Operations.WalletsV2025ControllerGetAllSignatures2.Input) async throws -> Operations.WalletsV2025ControllerGetAllSignatures2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetAllSignatures2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetAllSignatures2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetAllSignatures2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signatures/post(WalletsV2025Controller-createSignatureRequest-2)`.
    public func walletsV2025ControllerCreateSignatureRequest2(_ input: Operations.WalletsV2025ControllerCreateSignatureRequest2.Input) async throws -> Operations.WalletsV2025ControllerCreateSignatureRequest2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateSignatureRequest2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/balances/get(BalanceV20250609Controller-getBalanceForLocator-2)`.
    public func balanceV20250609ControllerGetBalanceForLocator2(_ input: Operations.BalanceV20250609ControllerGetBalanceForLocator2.Input) async throws -> Operations.BalanceV20250609ControllerGetBalanceForLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceV20250609ControllerGetBalanceForLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceV20250609ControllerGetBalanceForLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceV20250609ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceV20250609ControllerGetBalanceForLocator2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/get(WalletsV2025Controller-getWalletByLocator-2)`.
    public func walletsV2025ControllerGetWalletByLocator2(_ input: Operations.WalletsV2025ControllerGetWalletByLocator2.Input) async throws -> Operations.WalletsV2025ControllerGetWalletByLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetWalletByLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetWalletByLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetWalletByLocator2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When owner is provided, subsequent calls with the same owner will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/post(WalletsV2025Controller-createWallet-2)`.
    public func walletsV2025ControllerCreateWallet2(_ input: Operations.WalletsV2025ControllerCreateWallet2.Input) async throws -> Operations.WalletsV2025ControllerCreateWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateWallet2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateWallet2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitMeApprovals-4)`.
    public func walletsV1ControllerSubmitMeApprovals4(_ input: Operations.WalletsV1ControllerSubmitMeApprovals4.Input) async throws -> Operations.WalletsV1ControllerSubmitMeApprovals4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeApprovals4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/transactions/{transactionId}/get(WalletsV1Controller-getMeTransaction-4)`.
    public func walletsV1ControllerGetMeTransaction4(_ input: Operations.WalletsV1ControllerGetMeTransaction4.Input) async throws -> Operations.WalletsV1ControllerGetMeTransaction4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransaction4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/transactions/get(WalletsV1Controller-getMeTransactionsWithoutChain-4)`.
    public func walletsV1ControllerGetMeTransactionsWithoutChain4(_ input: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.Input) async throws -> Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/transactions/post(WalletsV1Controller-createMeTransaction-4)`.
    public func walletsV1ControllerCreateMeTransaction4(_ input: Operations.WalletsV1ControllerCreateMeTransaction4.Input) async throws -> Operations.WalletsV1ControllerCreateMeTransaction4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeTransaction4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction4.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signers/{signer}/get(WalletsV1Controller-getMeDelegatedSigner-4)`.
    public func walletsV1ControllerGetMeDelegatedSigner4(_ input: Operations.WalletsV1ControllerGetMeDelegatedSigner4.Input) async throws -> Operations.WalletsV1ControllerGetMeDelegatedSigner4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeDelegatedSigner4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signers/post(WalletsV1Controller-createMeDelegatedSigner-4)`.
    public func walletsV1ControllerCreateMeDelegatedSigner4(_ input: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Input) async throws -> Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signers",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitMeSignatureApprovals-4)`.
    public func walletsV1ControllerSubmitMeSignatureApprovals4(_ input: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Input) async throws -> Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signatures/{signatureId}/get(WalletsV1Controller-getMeSignature-4)`.
    public func walletsV1ControllerGetMeSignature4(_ input: Operations.WalletsV1ControllerGetMeSignature4.Input) async throws -> Operations.WalletsV1ControllerGetMeSignature4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeSignature4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signatures/post(WalletsV1Controller-createMeSignatureRequest-4)`.
    public func walletsV1ControllerCreateMeSignatureRequest4(_ input: Operations.WalletsV1ControllerCreateMeSignatureRequest4.Input) async throws -> Operations.WalletsV1ControllerCreateMeSignatureRequest4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeSignatureRequest4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/activity/get(WalletsV1Controller-getMeWalletActivity-4)`.
    public func walletsV1ControllerGetMeWalletActivity4(_ input: Operations.WalletsV1ControllerGetMeWalletActivity4.Input) async throws -> Operations.WalletsV1ControllerGetMeWalletActivity4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWalletActivity4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/activity",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/get(WalletsV1Controller-getMeWallet-4)`.
    public func walletsV1ControllerGetMeWallet4(_ input: Operations.WalletsV1ControllerGetMeWallet4.Input) async throws -> Operations.WalletsV1ControllerGetMeWallet4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWallet4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWallet4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me/post(WalletsV1Controller-createMeWallet-4)`.
    public func walletsV1ControllerCreateMeWallet4(_ input: Operations.WalletsV1ControllerCreateMeWallet4.Input) async throws -> Operations.WalletsV1ControllerCreateMeWallet4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeWallet4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeWallet4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitApprovals-4)`.
    public func walletsV1ControllerSubmitApprovals4(_ input: Operations.WalletsV1ControllerSubmitApprovals4.Input) async throws -> Operations.WalletsV1ControllerSubmitApprovals4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitApprovals4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV1Controller-getTransaction-4)`.
    public func walletsV1ControllerGetTransaction4(_ input: Operations.WalletsV1ControllerGetTransaction4.Input) async throws -> Operations.WalletsV1ControllerGetTransaction4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransaction4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/transactions/get(WalletsV1Controller-getTransactionsWithoutChain-4)`.
    public func walletsV1ControllerGetTransactionsWithoutChain4(_ input: Operations.WalletsV1ControllerGetTransactionsWithoutChain4.Input) async throws -> Operations.WalletsV1ControllerGetTransactionsWithoutChain4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransactionsWithoutChain4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/transactions/post(WalletsV1Controller-createTransaction-4)`.
    public func walletsV1ControllerCreateTransaction4(_ input: Operations.WalletsV1ControllerCreateTransaction4.Input) async throws -> Operations.WalletsV1ControllerCreateTransaction4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateTransaction4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction4.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signers/{signer}/get(WalletsV1Controller-getDelegatedSigner-4)`.
    public func walletsV1ControllerGetDelegatedSigner4(_ input: Operations.WalletsV1ControllerGetDelegatedSigner4.Input) async throws -> Operations.WalletsV1ControllerGetDelegatedSigner4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetDelegatedSigner4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signers/post(WalletsV1Controller-createDelegatedSigner-4)`.
    public func walletsV1ControllerCreateDelegatedSigner4(_ input: Operations.WalletsV1ControllerCreateDelegatedSigner4.Input) async throws -> Operations.WalletsV1ControllerCreateDelegatedSigner4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateDelegatedSigner4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitSignatureApprovals-4)`.
    public func walletsV1ControllerSubmitSignatureApprovals4(_ input: Operations.WalletsV1ControllerSubmitSignatureApprovals4.Input) async throws -> Operations.WalletsV1ControllerSubmitSignatureApprovals4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitSignatureApprovals4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV1Controller-getSignature-4)`.
    public func walletsV1ControllerGetSignature4(_ input: Operations.WalletsV1ControllerGetSignature4.Input) async throws -> Operations.WalletsV1ControllerGetSignature4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetSignature4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signatures/get(WalletsV1Controller-getAllSignatures-4)`.
    public func walletsV1ControllerGetAllSignatures4(_ input: Operations.WalletsV1ControllerGetAllSignatures4.Input) async throws -> Operations.WalletsV1ControllerGetAllSignatures4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetAllSignatures4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2MultipleSignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signatures/post(WalletsV1Controller-createSignatureRequest-4)`.
    public func walletsV1ControllerCreateSignatureRequest4(_ input: Operations.WalletsV1ControllerCreateSignatureRequest4.Input) async throws -> Operations.WalletsV1ControllerCreateSignatureRequest4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateSignatureRequest4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/activity/get(WalletsV1Controller-getWalletActivity-4)`.
    public func walletsV1ControllerGetWalletActivity4(_ input: Operations.WalletsV1ControllerGetWalletActivity4.Input) async throws -> Operations.WalletsV1ControllerGetWalletActivity4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletActivity4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/get(WalletsV1Controller-getWalletByLocator-4)`.
    public func walletsV1ControllerGetWalletByLocator4(_ input: Operations.WalletsV1ControllerGetWalletByLocator4.Input) async throws -> Operations.WalletsV1ControllerGetWalletByLocator4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletByLocator4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs from Wallet
    ///
    /// Retrieves NFTs from a wallet.
    ///
    /// **API scope required**: `wallets:nfts.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{locator}/nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{locator}/nfts/get(WalletNFTController-getNFTsFromWallet-4)`.
    public func walletNFTControllerGetNFTsFromWallet4(_ input: Operations.WalletNFTControllerGetNFTsFromWallet4.Input) async throws -> Operations.WalletNFTControllerGetNFTsFromWallet4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletNFTControllerGetNFTsFromWallet4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/nfts",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "contractAddress",
                    value: input.query.contractAddress
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokenId",
                    value: input.query.tokenId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletNFTControllerGetNFTsFromWallet4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNFTsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When linkedUser is provided, subsequent calls with the same linkedUser will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/post(WalletsV1Controller-createWallet-4)`.
    public func walletsV1ControllerCreateWallet4(_ input: Operations.WalletsV1ControllerCreateWallet4.Input) async throws -> Operations.WalletsV1ControllerCreateWallet4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateWallet4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}

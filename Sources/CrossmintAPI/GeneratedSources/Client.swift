// Generated by swift-openapi-generator, do not modify.
// swiftlint:disable all
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
///
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// - Remark: HTTP `POST /worldstore/protocol-alpha/webhooks/rye`.
    /// - Remark: Generated from `#/paths//worldstore/protocol-alpha/webhooks/rye/post(WorldstoreAlphaOrderWebhooksController-ryeWebhook-2)`.
    public func worldstoreAlphaOrderWebhooksControllerRyeWebhook2(_ input: Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook2.Input) async throws -> Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/worldstore/protocol-alpha/webhooks/rye",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order tracking information
    ///
    /// - Remark: HTTP `GET /worldstore/protocol-alpha/store/amazon/orders/{orderHash}/tracking`.
    /// - Remark: Generated from `#/paths//worldstore/protocol-alpha/store/amazon/orders/{orderHash}/tracking/get(WorldstoreAlphaController-getOrderTracking-2)`.
    public func worldstoreAlphaControllerGetOrderTracking2(_ input: Operations.WorldstoreAlphaControllerGetOrderTracking2.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrderTracking2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrderTracking2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/worldstore/protocol-alpha/store/amazon/orders/{}/tracking",
                    parameters: [
                        input.path.orderHash
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Webhook for Worldstore Alpha
    ///
    /// - Remark: HTTP `POST /worldstore/protocol-alpha/store/{store}/webhook`.
    /// - Remark: Generated from `#/paths//worldstore/protocol-alpha/store/{store}/webhook/post(WorldstoreAlphaController-webhook-2)`.
    public func worldstoreAlphaControllerWebhook2(_ input: Operations.WorldstoreAlphaControllerWebhook2.Input) async throws -> Operations.WorldstoreAlphaControllerWebhook2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerWebhook2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/worldstore/protocol-alpha/store/{}/webhook",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an order for a listing
    ///
    /// - Remark: HTTP `POST /worldstore/protocol-alpha/store/{store}/orders`.
    /// - Remark: Generated from `#/paths//worldstore/protocol-alpha/store/{store}/orders/post(WorldstoreAlphaController-getOrder-2)`.
    public func worldstoreAlphaControllerGetOrder2(_ input: Operations.WorldstoreAlphaControllerGetOrder2.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrder2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrder2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/worldstore/protocol-alpha/store/{}/orders",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order parameters schema for a store
    ///
    /// - Remark: HTTP `GET /worldstore/protocol-alpha/store/{store}/orderParameters`.
    /// - Remark: Generated from `#/paths//worldstore/protocol-alpha/store/{store}/orderParameters/get(WorldstoreAlphaController-getOrderParametersSchema-2)`.
    public func worldstoreAlphaControllerGetOrderParametersSchema2(_ input: Operations.WorldstoreAlphaControllerGetOrderParametersSchema2.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrderParametersSchema2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrderParametersSchema2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/worldstore/protocol-alpha/store/{}/orderParameters",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get metadata for a store
    ///
    /// - Remark: HTTP `GET /worldstore/protocol-alpha/store/{store}/metadata`.
    /// - Remark: Generated from `#/paths//worldstore/protocol-alpha/store/{store}/metadata/get(WorldstoreAlphaController-getMetadata-2)`.
    public func worldstoreAlphaControllerGetMetadata2(_ input: Operations.WorldstoreAlphaControllerGetMetadata2.Input) async throws -> Operations.WorldstoreAlphaControllerGetMetadata2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetMetadata2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/worldstore/protocol-alpha/store/{}/metadata",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get listings for a product
    ///
    /// - Remark: HTTP `GET /worldstore/protocol-alpha/store/{store}/listings`.
    /// - Remark: Generated from `#/paths//worldstore/protocol-alpha/store/{store}/listings/get(WorldstoreAlphaController-getListings-2)`.
    public func worldstoreAlphaControllerGetListings2(_ input: Operations.WorldstoreAlphaControllerGetListings2.Input) async throws -> Operations.WorldstoreAlphaControllerGetListings2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetListings2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/worldstore/protocol-alpha/store/{}/listings",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "uid",
                    value: input.query.uid
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /webhooks/internal/lead-scanner`.
    /// - Remark: Generated from `#/paths//webhooks/internal/lead-scanner/post(LeadScannerController-scan-2)`.
    public func leadScannerControllerScan2(_ input: Operations.LeadScannerControllerScan2.Input) async throws -> Operations.LeadScannerControllerScan2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.LeadScannerControllerScan2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/webhooks/internal/lead-scanner",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Start the device onboarding process
    ///
    /// - Remark: HTTP `POST /v1/signers/start-onboarding`.
    /// - Remark: Generated from `#/paths//v1/signers/start-onboarding/post(NCSController-forwardStartOnboarding-4)`.
    public func ncsControllerForwardStartOnboarding4(_ input: Operations.NCSControllerForwardStartOnboarding4.Input) async throws -> Operations.NCSControllerForwardStartOnboarding4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardStartOnboarding4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/signers/start-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deterministically generate a signer's public key for a specified signing curve
    ///
    /// - Remark: HTTP `POST /v1/signers/derive-public-key`.
    /// - Remark: Generated from `#/paths//v1/signers/derive-public-key/post(NCSController-forwardPreGeneration-4)`.
    public func ncsControllerForwardPreGeneration4(_ input: Operations.NCSControllerForwardPreGeneration4.Input) async throws -> Operations.NCSControllerForwardPreGeneration4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardPreGeneration4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/signers/derive-public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Complete the device onboarding process, storing an encrypted master secret, and forwarding it to the device
    ///
    /// - Remark: HTTP `POST /v1/signers/complete-onboarding`.
    /// - Remark: Generated from `#/paths//v1/signers/complete-onboarding/post(NCSController-forwardCompleteOnboarding-4)`.
    public func ncsControllerForwardCompleteOnboarding4(_ input: Operations.NCSControllerForwardCompleteOnboarding4.Input) async throws -> Operations.NCSControllerForwardCompleteOnboarding4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardCompleteOnboarding4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/signers/complete-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset Licenses
    ///
    /// Get the licenses of an IP Asset
    ///
    /// The ipassetId parameter should be the Story Protocol asset ID (not the Crossmint ID). Must start with '0x' followed by hexadecimal characters.
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /v1/ip/licenses/{ipassetId}`.
    /// - Remark: Generated from `#/paths//v1/ip/licenses/{ipassetId}/get(StoryApiController-getIpaLicenses-2)`.
    public func storyApiControllerGetIpaLicenses2(_ input: Operations.StoryApiControllerGetIpaLicenses2.Input) async throws -> Operations.StoryApiControllerGetIpaLicenses2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetIpaLicenses2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/licenses/{}",
                    parameters: [
                        input.path.ipassetId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetIpaLicenses2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset Graph
    ///
    /// Get the graph of an IP Asset, by default it will fetch the first level of parents and children (depth = 1). You can customize the depth using the query parameter 'depth' to a maximum of 3. Maximum 100 parents or children will be returned for each level.
    ///
    /// The ipAssetId parameter should be the Story Protocol asset ID (not the Crossmint ID). Must start with '0x' followed by hexadecimal characters.
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /v1/ip/graph/{ipAssetId}`.
    /// - Remark: Generated from `#/paths//v1/ip/graph/{ipAssetId}/get(StoryApiController-getIpaGraph-2)`.
    public func storyApiControllerGetIpaGraph2(_ input: Operations.StoryApiControllerGetIpaGraph2.Input) async throws -> Operations.StoryApiControllerGetIpaGraph2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetIpaGraph2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/graph/{}",
                    parameters: [
                        input.path.ipAssetId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "depth",
                    value: input.query.depth
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetIpaGraph2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetGraphDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset
    ///
    /// Get a single IP Asset
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/get(StoryApiController-getNft-2)`.
    public func storyApiControllerGetNft2(_ input: Operations.StoryApiControllerGetNft2.Input) async throws -> Operations.StoryApiControllerGetNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetNft2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update IP Asset
    ///
    /// Update an existing IP Asset
    ///
    /// **API scope required**: `nfts.update`
    ///
    /// - Remark: HTTP `PATCH /v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/patch(StoryApiController-updateNft-2)`.
    public func storyApiControllerUpdateNft2(_ input: Operations.StoryApiControllerUpdateNft2.Input) async throws -> Operations.StoryApiControllerUpdateNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerUpdateNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerUpdateNft2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetUpdateResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create IP Asset (Idempotent)
    ///
    /// Create a new IP Asset with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `PUT /v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/put(StoryApiController-createIPAssetIdempotent-2)`.
    public func storyApiControllerCreateIPAssetIdempotent2(_ input: Operations.StoryApiControllerCreateIPAssetIdempotent2.Input) async throws -> Operations.StoryApiControllerCreateIPAssetIdempotent2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIPAssetIdempotent2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIPAssetIdempotent2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Assets in a collection
    ///
    /// Get all IP Assets in a collection
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /v1/ip/collections/{collectionId}/ipassets`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/{collectionId}/ipassets/get(StoryApiController-getNfts-2)`.
    public func storyApiControllerGetNfts2(_ input: Operations.StoryApiControllerGetNfts2.Input) async throws -> Operations.StoryApiControllerGetNfts2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetNfts2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections/{}/ipassets",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetNfts2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultipleIPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create IP Asset
    ///
    /// Create a new IP Asset
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `POST /v1/ip/collections/{collectionId}/ipassets`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/{collectionId}/ipassets/post(StoryApiController-createIPAsset-2)`.
    public func storyApiControllerCreateIPAsset2(_ input: Operations.StoryApiControllerCreateIPAsset2.Input) async throws -> Operations.StoryApiControllerCreateIPAsset2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIPAsset2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections/{}/ipassets",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIPAsset2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a Collection
    ///
    /// Get a collection by its id deployed on the Story chain
    ///
    /// **API scope required**: `collections.read`
    ///
    /// - Remark: HTTP `GET /v1/ip/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/{collectionId}/get(StoryApiController-getCollection-2)`.
    public func storyApiControllerGetCollection2(_ input: Operations.StoryApiControllerGetCollection2.Input) async throws -> Operations.StoryApiControllerGetCollection2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetCollection2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetCollection2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `collections.create`
    ///
    /// - Remark: HTTP `PUT /v1/ip/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/{collectionId}/put(StoryApiController-createIdempotent-2)`.
    public func storyApiControllerCreateIdempotent2(_ input: Operations.StoryApiControllerCreateIdempotent2.Input) async throws -> Operations.StoryApiControllerCreateIdempotent2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIdempotent2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIdempotent2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Collections
    ///
    /// Get all collections associated with the Developer Project
    ///
    /// **API scope required**: `collections.read`
    ///
    /// - Remark: HTTP `GET /v1/ip/collections`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/get(StoryApiController-getCollections-2)`.
    public func storyApiControllerGetCollections2(_ input: Operations.StoryApiControllerGetCollections2.Input) async throws -> Operations.StoryApiControllerGetCollections2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetCollections2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetCollections2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultipleCollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `collections.create`
    ///
    /// - Remark: HTTP `POST /v1/ip/collections`.
    /// - Remark: Generated from `#/paths//v1/ip/collections/post(StoryApiController-create-2)`.
    public func storyApiControllerCreate2(_ input: Operations.StoryApiControllerCreate2.Input) async throws -> Operations.StoryApiControllerCreate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreate2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Action
    ///
    /// Get an action by its id
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `GET /v1/ip/actions/{actionId}`.
    /// - Remark: Generated from `#/paths//v1/ip/actions/{actionId}/get(StoryApiController-getAction-2)`.
    public func storyApiControllerGetAction2(_ input: Operations.StoryApiControllerGetAction2.Input) async throws -> Operations.StoryApiControllerGetAction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetAction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/ip/actions/{}",
                    parameters: [
                        input.path.actionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetAction2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.StoryActionsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get everything an NCS device needs to operate, including the encrypted master secret.
    ///
    /// - Remark: HTTP `GET /v1/devices/{deviceId}`.
    /// - Remark: Generated from `#/paths//v1/devices/{deviceId}/get(NCSController-getDevice-4)`.
    public func ncsControllerGetDevice4(_ input: Operations.NCSControllerGetDevice4.Input) async throws -> Operations.NCSControllerGetDevice4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetDevice4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/devices/{}",
                    parameters: [
                        input.path.deviceId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the encryption public key for the TEE - for local developement
    ///
    /// - Remark: HTTP `GET /v1/attestation/public-key`.
    /// - Remark: Generated from `#/paths//v1/attestation/public-key/get(NCSController-getPublicKey-4)`.
    public func ncsControllerGetPublicKey4(_ input: Operations.NCSControllerGetPublicKey4.Input) async throws -> Operations.NCSControllerGetPublicKey4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetPublicKey4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/attestation/public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the attestation for the TEE
    ///
    /// - Remark: HTTP `GET /v1/attestation`.
    /// - Remark: Generated from `#/paths//v1/attestation/get(NCSController-getAttestation-4)`.
    public func ncsControllerGetAttestation4(_ input: Operations.NCSControllerGetAttestation4.Input) async throws -> Operations.NCSControllerGetAttestation4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetAttestation4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/attestation",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitMeApprovals-5)`.
    public func walletsV1ControllerSubmitMeApprovals5(_ input: Operations.WalletsV1ControllerSubmitMeApprovals5.Input) async throws -> Operations.WalletsV1ControllerSubmitMeApprovals5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeApprovals5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals5.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/get(WalletsV1Controller-getMeTransaction-5)`.
    public func walletsV1ControllerGetMeTransaction5(_ input: Operations.WalletsV1ControllerGetMeTransaction5.Input) async throws -> Operations.WalletsV1ControllerGetMeTransaction5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransaction5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/transactions/get(WalletsV1Controller-getMeTransactionsWithoutChain-5)`.
    public func walletsV1ControllerGetMeTransactionsWithoutChain5(_ input: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.Input) async throws -> Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/transactions/post(WalletsV1Controller-createMeTransaction-5)`.
    public func walletsV1ControllerCreateMeTransaction5(_ input: Operations.WalletsV1ControllerCreateMeTransaction5.Input) async throws -> Operations.WalletsV1ControllerCreateMeTransaction5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeTransaction5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction5.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signers/{signer}/get(WalletsV1Controller-getMeDelegatedSigner-5)`.
    public func walletsV1ControllerGetMeDelegatedSigner5(_ input: Operations.WalletsV1ControllerGetMeDelegatedSigner5.Input) async throws -> Operations.WalletsV1ControllerGetMeDelegatedSigner5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeDelegatedSigner5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/signers`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signers/post(WalletsV1Controller-createMeDelegatedSigner-5)`.
    public func walletsV1ControllerCreateMeDelegatedSigner5(_ input: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Input) async throws -> Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signers",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitMeSignatureApprovals-5)`.
    public func walletsV1ControllerSubmitMeSignatureApprovals5(_ input: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Input) async throws -> Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/get(WalletsV1Controller-getMeSignature-5)`.
    public func walletsV1ControllerGetMeSignature5(_ input: Operations.WalletsV1ControllerGetMeSignature5.Input) async throws -> Operations.WalletsV1ControllerGetMeSignature5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeSignature5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me{walletType}/signatures`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/signatures/post(WalletsV1Controller-createMeSignatureRequest-5)`.
    public func walletsV1ControllerCreateMeSignatureRequest5(_ input: Operations.WalletsV1ControllerCreateMeSignatureRequest5.Input) async throws -> Operations.WalletsV1ControllerCreateMeSignatureRequest5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeSignatureRequest5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}/activity`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/activity/get(WalletsV1Controller-getMeWalletActivity-5)`.
    public func walletsV1ControllerGetMeWalletActivity5(_ input: Operations.WalletsV1ControllerGetMeWalletActivity5.Input) async throws -> Operations.WalletsV1ControllerGetMeWalletActivity5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWalletActivity5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}/activity",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/me{walletType}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me{walletType}/get(WalletsV1Controller-getMeWallet-5)`.
    public func walletsV1ControllerGetMeWallet5(_ input: Operations.WalletsV1ControllerGetMeWallet5.Input) async throws -> Operations.WalletsV1ControllerGetMeWallet5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWallet5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me{}",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWallet5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/me`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/me/post(WalletsV1Controller-createMeWallet-5)`.
    public func walletsV1ControllerCreateMeWallet5(_ input: Operations.WalletsV1ControllerCreateMeWallet5.Input) async throws -> Operations.WalletsV1ControllerCreateMeWallet5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeWallet5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeWallet5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitApprovals-5)`.
    public func walletsV1ControllerSubmitApprovals5(_ input: Operations.WalletsV1ControllerSubmitApprovals5.Input) async throws -> Operations.WalletsV1ControllerSubmitApprovals5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitApprovals5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals5.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV1Controller-getTransaction-5)`.
    public func walletsV1ControllerGetTransaction5(_ input: Operations.WalletsV1ControllerGetTransaction5.Input) async throws -> Operations.WalletsV1ControllerGetTransaction5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransaction5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/transactions/get(WalletsV1Controller-getTransactionsWithoutChain-5)`.
    public func walletsV1ControllerGetTransactionsWithoutChain5(_ input: Operations.WalletsV1ControllerGetTransactionsWithoutChain5.Input) async throws -> Operations.WalletsV1ControllerGetTransactionsWithoutChain5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransactionsWithoutChain5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/transactions/post(WalletsV1Controller-createTransaction-5)`.
    public func walletsV1ControllerCreateTransaction5(_ input: Operations.WalletsV1ControllerCreateTransaction5.Input) async throws -> Operations.WalletsV1ControllerCreateTransaction5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateTransaction5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction5.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signers/{signer}/get(WalletsV1Controller-getDelegatedSigner-5)`.
    public func walletsV1ControllerGetDelegatedSigner5(_ input: Operations.WalletsV1ControllerGetDelegatedSigner5.Input) async throws -> Operations.WalletsV1ControllerGetDelegatedSigner5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetDelegatedSigner5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signers/post(WalletsV1Controller-createDelegatedSigner-5)`.
    public func walletsV1ControllerCreateDelegatedSigner5(_ input: Operations.WalletsV1ControllerCreateDelegatedSigner5.Input) async throws -> Operations.WalletsV1ControllerCreateDelegatedSigner5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateDelegatedSigner5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitSignatureApprovals-5)`.
    public func walletsV1ControllerSubmitSignatureApprovals5(_ input: Operations.WalletsV1ControllerSubmitSignatureApprovals5.Input) async throws -> Operations.WalletsV1ControllerSubmitSignatureApprovals5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitSignatureApprovals5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV1Controller-getSignature-5)`.
    public func walletsV1ControllerGetSignature5(_ input: Operations.WalletsV1ControllerGetSignature5.Input) async throws -> Operations.WalletsV1ControllerGetSignature5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetSignature5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signatures/get(WalletsV1Controller-getAllSignatures-5)`.
    public func walletsV1ControllerGetAllSignatures5(_ input: Operations.WalletsV1ControllerGetAllSignatures5.Input) async throws -> Operations.WalletsV1ControllerGetAllSignatures5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetAllSignatures5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2MultipleSignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/signatures/post(WalletsV1Controller-createSignatureRequest-5)`.
    public func walletsV1ControllerCreateSignatureRequest5(_ input: Operations.WalletsV1ControllerCreateSignatureRequest5.Input) async throws -> Operations.WalletsV1ControllerCreateSignatureRequest5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateSignatureRequest5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/balances/get(BalanceController-getBalanceForLocator-2)`.
    public func balanceControllerGetBalanceForLocator2(_ input: Operations.BalanceControllerGetBalanceForLocator2.Input) async throws -> Operations.BalanceControllerGetBalanceForLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceControllerGetBalanceForLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerGetBalanceForLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerGetBalanceForLocator2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Fund Wallet
    ///
    /// Send funds to a wallet.
    ///
    /// **API scope required**: `wallets.fund`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/balances/post(BalanceController-fundWallet-2)`.
    public func balanceControllerFundWallet2(_ input: Operations.BalanceControllerFundWallet2.Input) async throws -> Operations.BalanceControllerFundWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceControllerFundWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerFundWallet2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerFundWallet2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/activity/get(WalletsV1Controller-getWalletActivity-5)`.
    public func walletsV1ControllerGetWalletActivity5(_ input: Operations.WalletsV1ControllerGetWalletActivity5.Input) async throws -> Operations.WalletsV1ControllerGetWalletActivity5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletActivity5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha2/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/{walletLocator}/get(WalletsV1Controller-getWalletByLocator-5)`.
    public func walletsV1ControllerGetWalletByLocator5(_ input: Operations.WalletsV1ControllerGetWalletByLocator5.Input) async throws -> Operations.WalletsV1ControllerGetWalletByLocator5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletByLocator5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator5.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When linkedUser is provided, subsequent calls with the same linkedUser will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /v1-alpha2/wallets`.
    /// - Remark: Generated from `#/paths//v1-alpha2/wallets/post(WalletsV1Controller-createWallet-5)`.
    public func walletsV1ControllerCreateWallet5(_ input: Operations.WalletsV1ControllerCreateWallet5.Input) async throws -> Operations.WalletsV1ControllerCreateWallet5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateWallet5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet5.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet5.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a token and its available features by its locator
    ///
    /// Get a token by its locator
    ///
    /// - Remark: HTTP `GET /v1-alpha2/tokens/{tokenLocator}`.
    /// - Remark: Generated from `#/paths//v1-alpha2/tokens/{tokenLocator}/get(TokensController-getToken-2)`.
    public func tokensControllerGetToken2(_ input: Operations.TokensControllerGetToken2.Input) async throws -> Operations.TokensControllerGetToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokensControllerGetToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha2/tokens/{}",
                    parameters: [
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TokensControllerGetToken2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SupportedTokenResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/wallets/{walletLocator}/credential_nfts`.
    /// - Remark: Generated from `#/paths//v1-alpha1/wallets/{walletLocator}/credential_nfts/get(WalletCredentialsController-getNFTsFromWallet-2)`.
    public func walletCredentialsControllerGetNFTsFromWallet2(_ input: Operations.WalletCredentialsControllerGetNFTsFromWallet2.Input) async throws -> Operations.WalletCredentialsControllerGetNFTsFromWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletCredentialsControllerGetNFTsFromWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/wallets/{}/credential_nfts",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs from Wallet
    ///
    /// Retrieves NFTs from a wallet.
    ///
    /// **API scope required**: `wallets:nfts.read`
    ///
    /// - Remark: HTTP `GET /v1-alpha1/wallets/{locator}/nfts`.
    /// - Remark: Generated from `#/paths//v1-alpha1/wallets/{locator}/nfts/get(WalletNFTController-getNFTsFromWallet-5)`.
    public func walletNFTControllerGetNFTsFromWallet5(_ input: Operations.WalletNFTControllerGetNFTsFromWallet5.Input) async throws -> Operations.WalletNFTControllerGetNFTsFromWallet5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletNFTControllerGetNFTsFromWallet5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/wallets/{}/nfts",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "contractAddress",
                    value: input.query.contractAddress
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokenId",
                    value: input.query.tokenId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletNFTControllerGetNFTsFromWallet5.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNFTsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/wallets`.
    /// - Remark: Generated from `#/paths//v1-alpha1/wallets/get(WalletController-getWalletForUser-2)`.
    public func walletControllerGetWalletForUser2(_ input: Operations.WalletControllerGetWalletForUser2.Input) async throws -> Operations.WalletControllerGetWalletForUser2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletControllerGetWalletForUser2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "uid",
                    value: input.query.uid
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "phoneNumber",
                    value: input.query.phoneNumber
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /v1-alpha1/wallets`.
    /// - Remark: Generated from `#/paths//v1-alpha1/wallets/post(WalletController-createWalletForUser-2)`.
    public func walletControllerCreateWalletForUser2(_ input: Operations.WalletControllerCreateWalletForUser2.Input) async throws -> Operations.WalletControllerCreateWalletForUser2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletControllerCreateWalletForUser2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/projects/{projectId}/wallets-created`.
    /// - Remark: Generated from `#/paths//v1-alpha1/projects/{projectId}/wallets-created/get(WalletsCreatedController-getWalletsCreated-2)`.
    public func walletsCreatedControllerGetWalletsCreated2(_ input: Operations.WalletsCreatedControllerGetWalletsCreated2.Input) async throws -> Operations.WalletsCreatedControllerGetWalletsCreated2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsCreatedControllerGetWalletsCreated2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/projects/{}/wallets-created",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/projects/{projectId}/usage`.
    /// - Remark: Generated from `#/paths//v1-alpha1/projects/{projectId}/usage/get(ProjectUsageController-getUsage-2)`.
    public func projectUsageControllerGetUsage2(_ input: Operations.ProjectUsageControllerGetUsage2.Input) async throws -> Operations.ProjectUsageControllerGetUsage2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectUsageControllerGetUsage2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/projects/{}/usage",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "dimension",
                    value: input.query.dimension
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "startDate",
                    value: input.query.startDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "endDate",
                    value: input.query.endDate
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /v1-alpha1/projects/{projectId}/domains/{domain}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/projects/{projectId}/domains/{domain}/put(ProjectDomainsController-updateDomain-2)`.
    public func projectDomainsControllerUpdateDomain2(_ input: Operations.ProjectDomainsControllerUpdateDomain2.Input) async throws -> Operations.ProjectDomainsControllerUpdateDomain2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectDomainsControllerUpdateDomain2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/projects/{}/domains/{}",
                    parameters: [
                        input.path.projectId,
                        input.path.domain
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /v1-alpha1/projects/{projectId}/domains/{domain}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/projects/{projectId}/domains/{domain}/delete(ProjectDomainsController-deleteDomain-2)`.
    public func projectDomainsControllerDeleteDomain2(_ input: Operations.ProjectDomainsControllerDeleteDomain2.Input) async throws -> Operations.ProjectDomainsControllerDeleteDomain2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectDomainsControllerDeleteDomain2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/projects/{}/domains/{}",
                    parameters: [
                        input.path.projectId,
                        input.path.domain
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/projects/{projectId}/branding`.
    /// - Remark: Generated from `#/paths//v1-alpha1/projects/{projectId}/branding/get(BrandingController-get-2)`.
    public func brandingControllerGet2(_ input: Operations.BrandingControllerGet2.Input) async throws -> Operations.BrandingControllerGet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BrandingControllerGet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/projects/{}/branding",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /v1-alpha1/projects/{projectId}/branding`.
    /// - Remark: Generated from `#/paths//v1-alpha1/projects/{projectId}/branding/post(BrandingController-update-2)`.
    public func brandingControllerUpdate2(_ input: Operations.BrandingControllerUpdate2.Input) async throws -> Operations.BrandingControllerUpdate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BrandingControllerUpdate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/projects/{}/branding",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credential by token locator
    ///
    /// Get a single credential by token locator <chain:contract:tokenId>
    ///
    /// - Remark: HTTP `GET /v1-alpha1/nfts/{locator}/credentials`.
    /// - Remark: Generated from `#/paths//v1-alpha1/nfts/{locator}/credentials/get(AlphaTokenLocatorController-getCredential-2)`.
    public func alphaTokenLocatorControllerGetCredential2(_ input: Operations.AlphaTokenLocatorControllerGetCredential2.Input) async throws -> Operations.AlphaTokenLocatorControllerGetCredential2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AlphaTokenLocatorControllerGetCredential2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/nfts/{}/credentials",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Token by Locator
    ///
    /// Updates a token's metadata using a Crossmint token locator
    ///
    /// - Remark: HTTP `PATCH /v1-alpha1/nfts/{locator}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/nfts/{locator}/patch(TokenLocatorController-update-2)`.
    public func tokenLocatorControllerUpdate2(_ input: Operations.TokenLocatorControllerUpdate2.Input) async throws -> Operations.TokenLocatorControllerUpdate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenLocatorControllerUpdate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/nfts/{}",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn Token by locator
    ///
    /// Burn an existing token
    ///
    /// - Remark: HTTP `DELETE /v1-alpha1/nfts/{locator}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/nfts/{locator}/delete(TokenLocatorController-delete-2)`.
    public func tokenLocatorControllerDelete2(_ input: Operations.TokenLocatorControllerDelete2.Input) async throws -> Operations.TokenLocatorControllerDelete2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenLocatorControllerDelete2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/nfts/{}",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/send/post(MintingAPIV1AlphaController-sendNft-2)`.
    public func mintingAPIV1AlphaControllerSendNft2(_ input: Operations.MintingAPIV1AlphaControllerSendNft2.Input) async throws -> Operations.MintingAPIV1AlphaControllerSendNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerSendNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/minting/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/patch(MintingAPIV1AlphaController-updateNft-2)`.
    public func mintingAPIV1AlphaControllerUpdateNft2(_ input: Operations.MintingAPIV1AlphaControllerUpdateNft2.Input) async throws -> Operations.MintingAPIV1AlphaControllerUpdateNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerUpdateNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/delete(MintingAPIV1AlphaController-deleteNft-2)`.
    public func mintingAPIV1AlphaControllerDeleteNft2(_ input: Operations.MintingAPIV1AlphaControllerDeleteNft2.Input) async throws -> Operations.MintingAPIV1AlphaControllerDeleteNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerDeleteNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/minting/collections/{collectionId}/{featureSlug}/get(MintingAPIV1AlphaController-getFeature-2)`.
    public func mintingAPIV1AlphaControllerGetFeature2(_ input: Operations.MintingAPIV1AlphaControllerGetFeature2.Input) async throws -> Operations.MintingAPIV1AlphaControllerGetFeature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerGetFeature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/minting/collections/{collectionId}/{featureSlug}/put(MintingAPIV1AlphaController-updateFeature-2)`.
    public func mintingAPIV1AlphaControllerUpdateFeature2(_ input: Operations.MintingAPIV1AlphaControllerUpdateFeature2.Input) async throws -> Operations.MintingAPIV1AlphaControllerUpdateFeature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerUpdateFeature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/minting/collections/{collectionId}/{featureSlug}/delete(MintingAPIV1AlphaController-disableFeature-2)`.
    public func mintingAPIV1AlphaControllerDisableFeature2(_ input: Operations.MintingAPIV1AlphaControllerDisableFeature2.Input) async throws -> Operations.MintingAPIV1AlphaControllerDisableFeature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerDisableFeature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify a Credential
    ///
    /// Verify a Verifiable Credential
    ///
    /// - Remark: HTTP `POST /v1-alpha1/credentials/verification/verify`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/verification/verify/post(CredentialController-verifyCredential-2)`.
    public func credentialControllerVerifyCredential2(_ input: Operations.CredentialControllerVerifyCredential2.Input) async throws -> Operations.CredentialControllerVerifyCredential2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerVerifyCredential2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/verification/verify",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Type
    ///
    /// Get a Verifiable Credential Type by id
    ///
    /// - Remark: HTTP `GET /v1-alpha1/credentials/types/{typeId}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/types/{typeId}/get(CredentialTypesController-getType-2)`.
    public func credentialTypesControllerGetType2(_ input: Operations.CredentialTypesControllerGetType2.Input) async throws -> Operations.CredentialTypesControllerGetType2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerGetType2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/types/{}",
                    parameters: [
                        input.path.typeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Type (Idempotent)
    ///
    /// Create a new type with a given name
    ///
    /// - Remark: HTTP `PUT /v1-alpha1/credentials/types/{typeId}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/types/{typeId}/put(CredentialTypesController-createTypeIdempotent-2)`.
    public func credentialTypesControllerCreateTypeIdempotent2(_ input: Operations.CredentialTypesControllerCreateTypeIdempotent2.Input) async throws -> Operations.CredentialTypesControllerCreateTypeIdempotent2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerCreateTypeIdempotent2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/types/{}",
                    parameters: [
                        input.path.typeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Type
    ///
    /// Create a new type
    ///
    /// - Remark: HTTP `POST /v1-alpha1/credentials/types`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/types/post(CredentialTypesController-createType-2)`.
    public func credentialTypesControllerCreateType2(_ input: Operations.CredentialTypesControllerCreateType2.Input) async throws -> Operations.CredentialTypesControllerCreateType2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerCreateType2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/types",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get lit delegation signature
    ///
    /// Get a delegation signature for lit decryption
    ///
    /// - Remark: HTTP `GET /v1-alpha1/credentials/decryption/delegateLitCapacity`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/decryption/delegateLitCapacity/get(CredentialController-getSignature-2)`.
    public func credentialControllerGetSignature2(_ input: Operations.CredentialControllerGetSignature2.Input) async throws -> Operations.CredentialControllerGetSignature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerGetSignature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/decryption/delegateLitCapacity",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Decrypt a credential given a wallet signature
    ///
    /// Requires an encrypted credential and a signature from the subject's wallet
    ///
    /// - Remark: HTTP `POST /v1-alpha1/credentials/decryption/decrypt`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/decryption/decrypt/post(CredentialController-decryptCredential-2)`.
    public func credentialControllerDecryptCredential2(_ input: Operations.CredentialControllerDecryptCredential2.Input) async throws -> Operations.CredentialControllerDecryptCredential2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerDecryptCredential2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/decryption/decrypt",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a challenge for wallet authentication
    ///
    /// Will return a challenge to sign with a given wallet
    ///
    /// - Remark: HTTP `POST /v1-alpha1/credentials/auth/wallet`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/auth/wallet/post(CredentialController-walletAuthRequest-2)`.
    public func credentialControllerWalletAuthRequest2(_ input: Operations.CredentialControllerWalletAuthRequest2.Input) async throws -> Operations.CredentialControllerWalletAuthRequest2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerWalletAuthRequest2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/auth/wallet",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credential
    ///
    /// Get a single credential
    ///
    /// - Remark: HTTP `GET /v1-alpha1/credentials/{credentialId}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/{credentialId}/get(CredentialController-getCredential-2)`.
    public func credentialControllerGetCredential2(_ input: Operations.CredentialControllerGetCredential2.Input) async throws -> Operations.CredentialControllerGetCredential2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerGetCredential2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/{}",
                    parameters: [
                        input.path.credentialId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Revoke credential by id
    ///
    /// Revokes a verifiable credential and burns the associated NFT
    ///
    /// - Remark: HTTP `DELETE /v1-alpha1/credentials/{credentialId}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/credentials/{credentialId}/delete(CredentialController-delete-2)`.
    public func credentialControllerDelete2(_ input: Operations.CredentialControllerDelete2.Input) async throws -> Operations.CredentialControllerDelete2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerDelete2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/credentials/{}",
                    parameters: [
                        input.path.credentialId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/collections/{clientId}/mints`.
    /// - Remark: Generated from `#/paths//v1-alpha1/collections/{clientId}/mints/get(CollectionMintsController-getMints-2)`.
    public func collectionMintsControllerGetMints2(_ input: Operations.CollectionMintsControllerGetMints2.Input) async throws -> Operations.CollectionMintsControllerGetMints2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionMintsControllerGetMints2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/collections/{}/mints",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    value: input.query.cursor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/collections/{clientId}`.
    /// - Remark: Generated from `#/paths//v1-alpha1/collections/{clientId}/get(VerificationStatusController-get-2)`.
    public func verificationStatusControllerGet2(_ input: Operations.VerificationStatusControllerGet2.Input) async throws -> Operations.VerificationStatusControllerGet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.VerificationStatusControllerGet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/collections/{}",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//v1-alpha1/collections/get(ClientIntegrationController-getCollections-2)`.
    public func clientIntegrationControllerGetCollections2(_ input: Operations.ClientIntegrationControllerGetCollections2.Input) async throws -> Operations.ClientIntegrationControllerGetCollections2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerGetCollections2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hideDrafts",
                    value: input.query.hideDrafts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "topology",
                    value: input.query.topology
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//v1-alpha1/collections/post(ClientIntegrationController-create-2)`.
    public func clientIntegrationControllerCreate2(_ input: Operations.ClientIntegrationControllerCreate2.Input) async throws -> Operations.ClientIntegrationControllerCreate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerCreate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//v1-alpha1/collections/put(ClientIntegrationController-update-2)`.
    public func clientIntegrationControllerUpdate2(_ input: Operations.ClientIntegrationControllerUpdate2.Input) async throws -> Operations.ClientIntegrationControllerUpdate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerUpdate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Search listings
    ///
    /// - Remark: HTTP `POST /unstable/ws/search`.
    /// - Remark: Generated from `#/paths//unstable/ws/search/post(WorldstoreWrapperController-getListings-2)`.
    public func worldstoreWrapperControllerGetListings2(_ input: Operations.WorldstoreWrapperControllerGetListings2.Input) async throws -> Operations.WorldstoreWrapperControllerGetListings2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerGetListings2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/ws/search",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an order for a listing
    ///
    /// - Remark: HTTP `POST /unstable/ws/orders`.
    /// - Remark: Generated from `#/paths//unstable/ws/orders/post(WorldstoreWrapperController-createOrder-2)`.
    public func worldstoreWrapperControllerCreateOrder2(_ input: Operations.WorldstoreWrapperControllerCreateOrder2.Input) async throws -> Operations.WorldstoreWrapperControllerCreateOrder2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerCreateOrder2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/ws/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order parameters schema for a seller
    ///
    /// - Remark: HTTP `GET /unstable/ws/orderParameters`.
    /// - Remark: Generated from `#/paths//unstable/ws/orderParameters/get(WorldstoreWrapperController-getOrderParametersSchema-2)`.
    public func worldstoreWrapperControllerGetOrderParametersSchema2(_ input: Operations.WorldstoreWrapperControllerGetOrderParametersSchema2.Input) async throws -> Operations.WorldstoreWrapperControllerGetOrderParametersSchema2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerGetOrderParametersSchema2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/ws/orderParameters",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sellerId",
                    value: input.query.sellerId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify wallet ownership
    ///
    /// Verifies wallet ownership by a given email.
    ///
    /// - Remark: HTTP `POST /unstable/wallets/verify-ownership`.
    /// - Remark: Generated from `#/paths//unstable/wallets/verify-ownership/post(WalletsVerifyRecipientController-verifyWalletOwnership-2)`.
    public func walletsVerifyRecipientControllerVerifyWalletOwnership2(_ input: Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership2.Input) async throws -> Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/verify-ownership",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token For Authenticated User
    ///
    /// Sends a token of any type from the authenticated user's wallet to a recipient
    ///
    /// - Remark: HTTP `POST /unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenController-sendMeToken-2)`.
    public func walletsSendTokenControllerSendMeToken2(_ input: Operations.WalletsSendTokenControllerSendMeToken2.Input) async throws -> Operations.WalletsSendTokenControllerSendMeToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenControllerSendMeToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/me{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletType,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenControllerSendMeToken2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User (Unstable)
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events. This is an unstable API that may change without notice.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /unstable/wallets/me{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//unstable/wallets/me{walletLocator}/activity/get(WalletActivityUnstableController-getMeWalletActivity-2)`.
    public func walletActivityUnstableControllerGetMeWalletActivity2(_ input: Operations.WalletActivityUnstableControllerGetMeWalletActivity2.Input) async throws -> Operations.WalletActivityUnstableControllerGetMeWalletActivity2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletActivityUnstableControllerGetMeWalletActivity2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/me{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetMeWalletActivity2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsActivityResponseUnstableDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetMeWalletActivity2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token
    ///
    /// Sends a token of any type from this wallet to a recipient
    ///
    /// - Remark: HTTP `POST /unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenController-sendToken-2)`.
    public func walletsSendTokenControllerSendToken2(_ input: Operations.WalletsSendTokenControllerSendToken2.Input) async throws -> Operations.WalletsSendTokenControllerSendToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenControllerSendToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenControllerSendToken2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseWithSendParamsDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /unstable/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//unstable/wallets/{walletLocator}/balances/get(BalanceUnstableController-getBalanceForLocator-2)`.
    public func balanceUnstableControllerGetBalanceForLocator2(_ input: Operations.BalanceUnstableControllerGetBalanceForLocator2.Input) async throws -> Operations.BalanceUnstableControllerGetBalanceForLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceUnstableControllerGetBalanceForLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceUnstableControllerGetBalanceForLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceUnstableResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceUnstableControllerGetBalanceForLocator2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity (Unstable)
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events. This is an unstable API that may change without notice.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /unstable/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//unstable/wallets/{walletLocator}/activity/get(WalletActivityUnstableController-getWalletActivity-2)`.
    public func walletActivityUnstableControllerGetWalletActivity2(_ input: Operations.WalletActivityUnstableControllerGetWalletActivity2.Input) async throws -> Operations.WalletActivityUnstableControllerGetWalletActivity2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletActivityUnstableControllerGetWalletActivity2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetWalletActivity2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsActivityResponseUnstableDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetWalletActivity2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /unstable/wallets/{locator}/{currency}/balance`.
    /// - Remark: Generated from `#/paths//unstable/wallets/{locator}/{currency}/balance/get(WalletBalanceController-getBalanceForLocatorAndCurrency-2)`.
    public func walletBalanceControllerGetBalanceForLocatorAndCurrency2(_ input: Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency2.Input) async throws -> Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets/{}/{}/balance",
                    parameters: [
                        input.path.locator,
                        input.path.currency
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /unstable/wallets`.
    /// - Remark: Generated from `#/paths//unstable/wallets/get(GetWalletsController-getWallets-2)`.
    public func getWalletsControllerGetWallets2(_ input: Operations.GetWalletsControllerGetWallets2.Input) async throws -> Operations.GetWalletsControllerGetWallets2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetWalletsControllerGetWallets2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "phoneNumber",
                    value: input.query.phoneNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "address",
                    value: input.query.address
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "handle",
                    value: input.query.handle
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /unstable/setupTokenizeCard/registerToken`.
    /// - Remark: Generated from `#/paths//unstable/setupTokenizeCard/registerToken/post(TokenizedCardController-registerToken-2)`.
    public func tokenizedCardControllerRegisterToken2(_ input: Operations.TokenizedCardControllerRegisterToken2.Input) async throws -> Operations.TokenizedCardControllerRegisterToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerRegisterToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/setupTokenizeCard/registerToken",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /unstable/setupTokenizeCard/createPurchaseIntent`.
    /// - Remark: Generated from `#/paths//unstable/setupTokenizeCard/createPurchaseIntent/post(TokenizedCardController-createPurchaseIntent-2)`.
    public func tokenizedCardControllerCreatePurchaseIntent2(_ input: Operations.TokenizedCardControllerCreatePurchaseIntent2.Input) async throws -> Operations.TokenizedCardControllerCreatePurchaseIntent2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerCreatePurchaseIntent2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/setupTokenizeCard/createPurchaseIntent",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /unstable/setupTokenizeCard`.
    /// - Remark: Generated from `#/paths//unstable/setupTokenizeCard/get(TokenizedCardController-setupTokenizeCard-2)`.
    public func tokenizedCardControllerSetupTokenizeCard2(_ input: Operations.TokenizedCardControllerSetupTokenizeCard2.Input) async throws -> Operations.TokenizedCardControllerSetupTokenizeCard2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerSetupTokenizeCard2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/setupTokenizeCard",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Order Tracking
    ///
    /// Get delivery tracking information for an order
    ///
    /// - Remark: HTTP `GET /unstable/orders/{orderId}/tracking`.
    /// - Remark: Generated from `#/paths//unstable/orders/{orderId}/tracking/get(HeadlessCheckoutUnstableOrdersController-getTracking-2)`.
    public func headlessCheckoutUnstableOrdersControllerGetTracking2(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking2.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/orders/{}/tracking",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get refunds for an order
    ///
    /// Get refunds for an order.
    ///
    /// - Remark: HTTP `GET /unstable/orders/{orderId}/refunds`.
    /// - Remark: Generated from `#/paths//unstable/orders/{orderId}/refunds/get(HeadlessCheckoutUnstableOrdersController-getRefunds-2)`.
    public func headlessCheckoutUnstableOrdersControllerGetRefunds2(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds2.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/orders/{}/refunds",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Refund order
    ///
    /// Refund an order.
    ///
    /// - Remark: HTTP `POST /unstable/orders/{orderId}/refunds`.
    /// - Remark: Generated from `#/paths//unstable/orders/{orderId}/refunds/post(HeadlessCheckoutUnstableOrdersController-refundOrder-2)`.
    public func headlessCheckoutUnstableOrdersControllerRefundOrder2(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder2.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/orders/{}/refunds",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Process payment
    ///
    /// Process payment for an order.
    ///
    /// - Remark: HTTP `POST /unstable/orders/{orderId}/payment`.
    /// - Remark: Generated from `#/paths//unstable/orders/{orderId}/payment/post(HeadlessCheckoutUnstableOrdersController-processPayment-2)`.
    public func headlessCheckoutUnstableOrdersControllerProcessPayment2(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment2.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/unstable/orders/{}/payment",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /session/signout`.
    /// - Remark: Generated from `#/paths//session/signout/post(SessionController-signout-2)`.
    public func sessionControllerSignout2(_ input: Operations.SessionControllerSignout2.Input) async throws -> Operations.SessionControllerSignout2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerSignout2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/session/signout",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /session/exchange-access-token`.
    /// - Remark: Generated from `#/paths//session/exchange-access-token/post(SessionController-exchangeAccessToken-2)`.
    public func sessionControllerExchangeAccessToken2(_ input: Operations.SessionControllerExchangeAccessToken2.Input) async throws -> Operations.SessionControllerExchangeAccessToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerExchangeAccessToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/session/exchange-access-token",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /session/authenticate`.
    /// - Remark: Generated from `#/paths//session/authenticate/get(SessionController-authenticateOAuth-2)`.
    public func sessionControllerAuthenticateOAuth2(_ input: Operations.SessionControllerAuthenticateOAuth2.Input) async throws -> Operations.SessionControllerAuthenticateOAuth2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerAuthenticateOAuth2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/session/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /session/authenticate`.
    /// - Remark: Generated from `#/paths//session/authenticate/post(SessionController-authenticate-2)`.
    public func sessionControllerAuthenticate2(_ input: Operations.SessionControllerAuthenticate2.Input) async throws -> Operations.SessionControllerAuthenticate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerAuthenticate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/session/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /session`.
    /// - Remark: Generated from `#/paths//session/get(SessionController-getSession-2)`.
    public func sessionControllerGetSession2(_ input: Operations.SessionControllerGetSession2.Input) async throws -> Operations.SessionControllerGetSession2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerGetSession2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/session",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /sdk/auth/user/get-or-create`.
    /// - Remark: Generated from `#/paths//sdk/auth/user/get-or-create/post(AuthSdkInternalController-getOrCreateUserOnStytch-2)`.
    public func authSdkInternalControllerGetOrCreateUserOnStytch2(_ input: Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch2.Input) async throws -> Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/sdk/auth/user/get-or-create",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Start the device onboarding process
    ///
    /// - Remark: HTTP `POST /ncs/v1/signers/start-onboarding`.
    /// - Remark: Generated from `#/paths//ncs/v1/signers/start-onboarding/post(NCSController-forwardStartOnboarding-5)`.
    public func ncsControllerForwardStartOnboarding5(_ input: Operations.NCSControllerForwardStartOnboarding5.Input) async throws -> Operations.NCSControllerForwardStartOnboarding5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardStartOnboarding5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ncs/v1/signers/start-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deterministically generate a signer's public key for a specified signing curve
    ///
    /// - Remark: HTTP `POST /ncs/v1/signers/derive-public-key`.
    /// - Remark: Generated from `#/paths//ncs/v1/signers/derive-public-key/post(NCSController-forwardPreGeneration-5)`.
    public func ncsControllerForwardPreGeneration5(_ input: Operations.NCSControllerForwardPreGeneration5.Input) async throws -> Operations.NCSControllerForwardPreGeneration5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardPreGeneration5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ncs/v1/signers/derive-public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Complete the device onboarding process, storing an encrypted master secret, and forwarding it to the device
    ///
    /// - Remark: HTTP `POST /ncs/v1/signers/complete-onboarding`.
    /// - Remark: Generated from `#/paths//ncs/v1/signers/complete-onboarding/post(NCSController-forwardCompleteOnboarding-5)`.
    public func ncsControllerForwardCompleteOnboarding5(_ input: Operations.NCSControllerForwardCompleteOnboarding5.Input) async throws -> Operations.NCSControllerForwardCompleteOnboarding5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardCompleteOnboarding5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ncs/v1/signers/complete-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get everything an NCS device needs to operate, including the encrypted master secret.
    ///
    /// - Remark: HTTP `GET /ncs/v1/devices/{deviceId}`.
    /// - Remark: Generated from `#/paths//ncs/v1/devices/{deviceId}/get(NCSController-getDevice-5)`.
    public func ncsControllerGetDevice5(_ input: Operations.NCSControllerGetDevice5.Input) async throws -> Operations.NCSControllerGetDevice5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetDevice5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ncs/v1/devices/{}",
                    parameters: [
                        input.path.deviceId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the encryption public key for the TEE - for local developement
    ///
    /// - Remark: HTTP `GET /ncs/v1/attestation/public-key`.
    /// - Remark: Generated from `#/paths//ncs/v1/attestation/public-key/get(NCSController-getPublicKey-5)`.
    public func ncsControllerGetPublicKey5(_ input: Operations.NCSControllerGetPublicKey5.Input) async throws -> Operations.NCSControllerGetPublicKey5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetPublicKey5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ncs/v1/attestation/public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the attestation for the TEE
    ///
    /// - Remark: HTTP `GET /ncs/v1/attestation`.
    /// - Remark: Generated from `#/paths//ncs/v1/attestation/get(NCSController-getAttestation-5)`.
    public func ncsControllerGetAttestation5(_ input: Operations.NCSControllerGetAttestation5.Input) async throws -> Operations.NCSControllerGetAttestation5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetAttestation5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/ncs/v1/attestation",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/templates/{templateId}/get(TemplatesController-getTemplate-5)`.
    public func templatesControllerGetTemplate5(_ input: Operations.TemplatesControllerGetTemplate5.Input) async throws -> Operations.TemplatesControllerGetTemplate5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerGetTemplate5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PATCH /minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/templates/{templateId}/patch(TemplatesController-updateTemplate-5)`.
    public func templatesControllerUpdateTemplate5(_ input: Operations.TemplatesControllerUpdateTemplate5.Input) async throws -> Operations.TemplatesControllerUpdateTemplate5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerUpdateTemplate5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/templates/{templateId}/put(TemplatesController-createTemplateIdempotent-5)`.
    public func templatesControllerCreateTemplateIdempotent5(_ input: Operations.TemplatesControllerCreateTemplateIdempotent5.Input) async throws -> Operations.TemplatesControllerCreateTemplateIdempotent5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplateIdempotent5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/templates/{templateId}/delete(TemplatesController-deleteTemplate-5)`.
    public func templatesControllerDeleteTemplate5(_ input: Operations.TemplatesControllerDeleteTemplate5.Input) async throws -> Operations.TemplatesControllerDeleteTemplate5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerDeleteTemplate5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /minting/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/templates/get(TemplatesController-listTemplates-5)`.
    public func templatesControllerListTemplates5(_ input: Operations.TemplatesControllerListTemplates5.Input) async throws -> Operations.TemplatesControllerListTemplates5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerListTemplates5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /minting/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/templates/post(TemplatesController-createTemplate-5)`.
    public func templatesControllerCreateTemplate5(_ input: Operations.TemplatesControllerCreateTemplate5.Input) async throws -> Operations.TemplatesControllerCreateTemplate5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplate5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create SFT
    ///
    /// Create a new SFT
    ///
    /// - Remark: HTTP `POST /minting/collections/{collectionId}/sfts`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/sfts/post(SFTsController-createSft-5)`.
    public func sfTsControllerCreateSft5(_ input: Operations.SFTsControllerCreateSft5.Input) async throws -> Operations.SFTsControllerCreateSft5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SFTsControllerCreateSft5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/sfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "idempotency-key",
                    value: input.headers.idempotencyKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer NFT
    ///
    /// Transfer an existing NFT
    ///
    /// - Remark: HTTP `POST /minting/collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/nfts/{customerFacingId}/send/post(NFTsController-transferNft-5)`.
    public func nfTsControllerTransferNft5(_ input: Operations.NFTsControllerTransferNft5.Input) async throws -> Operations.NFTsControllerTransferNft5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerTransferNft5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFT
    ///
    /// Get a single NFT
    ///
    /// - Remark: HTTP `GET /minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/nfts/{customerFacingId}/get(NFTsController-getNft-5)`.
    public func nfTsControllerGetNft5(_ input: Operations.NFTsControllerGetNft5.Input) async throws -> Operations.NFTsControllerGetNft5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNft5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/nfts/{customerFacingId}/patch(NFTsController-updateNft-5)`.
    public func nfTsControllerUpdateNft5(_ input: Operations.NFTsControllerUpdateNft5.Input) async throws -> Operations.NFTsControllerUpdateNft5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerUpdateNft5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT (Idempotent)
    ///
    /// Create a new NFT with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/nfts/{customerFacingId}/put(NFTsController-createNftIdempotent-5)`.
    public func nfTsControllerCreateNftIdempotent5(_ input: Operations.NFTsControllerCreateNftIdempotent5.Input) async throws -> Operations.NFTsControllerCreateNftIdempotent5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNftIdempotent5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/nfts/{customerFacingId}/delete(NFTsController-deleteNft-5)`.
    public func nfTsControllerDeleteNft5(_ input: Operations.NFTsControllerDeleteNft5.Input) async throws -> Operations.NFTsControllerDeleteNft5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerDeleteNft5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs in a collection
    ///
    /// Get all NFTs in a collection
    ///
    /// - Remark: HTTP `GET /minting/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/nfts/get(NFTsController-getNfts-5)`.
    public func nfTsControllerGetNfts5(_ input: Operations.NFTsControllerGetNfts5.Input) async throws -> Operations.NFTsControllerGetNfts5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNfts5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT
    ///
    /// Create a new NFT
    ///
    /// - Remark: HTTP `POST /minting/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/nfts/post(NFTsController-createNft-5)`.
    public func nfTsControllerCreateNft5(_ input: Operations.NFTsControllerCreateNft5.Input) async throws -> Operations.NFTsControllerCreateNft5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNft5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/get(CollectionsController-getCollection-7)`.
    public func collectionsControllerGetCollection7(_ input: Operations.CollectionsControllerGetCollection7.Input) async throws -> Operations.CollectionsControllerGetCollection7.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection7.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/patch(CollectionsController-updateCollection-7)`.
    public func collectionsControllerUpdateCollection7(_ input: Operations.CollectionsControllerUpdateCollection7.Input) async throws -> Operations.CollectionsControllerUpdateCollection7.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection7.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//minting/collections/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-7)`.
    public func collectionsControllerCreateIdempotentOrGetCollection7(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection7.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection7.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection7.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /minting/collections`.
    /// - Remark: Generated from `#/paths//minting/collections/get(CollectionsController-getCollections-7)`.
    public func collectionsControllerGetCollections7(_ input: Operations.CollectionsControllerGetCollections7.Input) async throws -> Operations.CollectionsControllerGetCollections7.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections7.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /minting/collections`.
    /// - Remark: Generated from `#/paths//minting/collections/post(CollectionsController-createCollection-7)`.
    public func collectionsControllerCreateCollection7(_ input: Operations.CollectionsControllerCreateCollection7.Input) async throws -> Operations.CollectionsControllerCreateCollection7.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection7.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/minting/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify the registration response (cred) and return the results to the client
    ///
    /// - Remark: HTTP `POST /internal/passkeys/register/verify`.
    /// - Remark: Generated from `#/paths//internal/passkeys/register/verify/post(PasskeysController-verifyRegistration-2)`.
    public func passkeysControllerVerifyRegistration2(_ input: Operations.PasskeysControllerVerifyRegistration2.Input) async throws -> Operations.PasskeysControllerVerifyRegistration2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PasskeysControllerVerifyRegistration2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/internal/passkeys/register/verify",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "origin",
                    value: input.headers.origin
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Generate and return registration options to the client
    ///
    /// The client will use these options to prompt the user to create a passkey
    ///
    /// - Remark: HTTP `POST /internal/passkeys/register/options`.
    /// - Remark: Generated from `#/paths//internal/passkeys/register/options/post(PasskeysController-generateRegistrationOptions-2)`.
    public func passkeysControllerGenerateRegistrationOptions2(_ input: Operations.PasskeysControllerGenerateRegistrationOptions2.Input) async throws -> Operations.PasskeysControllerGenerateRegistrationOptions2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PasskeysControllerGenerateRegistrationOptions2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/internal/passkeys/register/options",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "origin",
                    value: input.headers.origin
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /internal/monitoring/outstanding-exports`.
    /// - Remark: Generated from `#/paths//internal/monitoring/outstanding-exports/get(ExportsController-findOutstandingExports-2)`.
    public func exportsControllerFindOutstandingExports2(_ input: Operations.ExportsControllerFindOutstandingExports2.Input) async throws -> Operations.ExportsControllerFindOutstandingExports2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ExportsControllerFindOutstandingExports2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/internal/monitoring/outstanding-exports",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /export-csv`.
    /// - Remark: Generated from `#/paths//export-csv/post(ExportCsvController-createExport-2)`.
    public func exportCsvControllerCreateExport2(_ input: Operations.ExportCsvControllerCreateExport2.Input) async throws -> Operations.ExportCsvControllerCreateExport2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ExportCsvControllerCreateExport2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/export-csv",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//credentials/templates/{collectionId}/get(CollectionsController-getCollection-8)`.
    public func collectionsControllerGetCollection8(_ input: Operations.CollectionsControllerGetCollection8.Input) async throws -> Operations.CollectionsControllerGetCollection8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//credentials/templates/{collectionId}/patch(CollectionsController-updateCollection-8)`.
    public func collectionsControllerUpdateCollection8(_ input: Operations.CollectionsControllerUpdateCollection8.Input) async throws -> Operations.CollectionsControllerUpdateCollection8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//credentials/templates/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-8)`.
    public func collectionsControllerCreateIdempotentOrGetCollection8(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection8.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /credentials/templates`.
    /// - Remark: Generated from `#/paths//credentials/templates/get(CollectionsController-getCollections-8)`.
    public func collectionsControllerGetCollections8(_ input: Operations.CollectionsControllerGetCollections8.Input) async throws -> Operations.CollectionsControllerGetCollections8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/credentials/templates",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /credentials/templates`.
    /// - Remark: Generated from `#/paths//credentials/templates/post(CollectionsController-createCollection-8)`.
    public func collectionsControllerCreateCollection8(_ input: Operations.CollectionsControllerCreateCollection8.Input) async throws -> Operations.CollectionsControllerCreateCollection8.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection8.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/credentials/templates",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /console/projects/{projectId}/billing/subscriptionCosts`.
    /// - Remark: Generated from `#/paths//console/projects/{projectId}/billing/subscriptionCosts/get(SubscriptionCostController-getSubscriptionCosts-2)`.
    public func subscriptionCostControllerGetSubscriptionCosts2(_ input: Operations.SubscriptionCostControllerGetSubscriptionCosts2.Input) async throws -> Operations.SubscriptionCostControllerGetSubscriptionCosts2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SubscriptionCostControllerGetSubscriptionCosts2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/console/projects/{}/billing/subscriptionCosts",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /console/project/{projectId}/privacy-policy`.
    /// - Remark: Generated from `#/paths//console/project/{projectId}/privacy-policy/get(PrivacyPolicyController-getByProjectId-2)`.
    public func privacyPolicyControllerGetByProjectId2(_ input: Operations.PrivacyPolicyControllerGetByProjectId2.Input) async throws -> Operations.PrivacyPolicyControllerGetByProjectId2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PrivacyPolicyControllerGetByProjectId2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/console/project/{}/privacy-policy",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /console/project/{projectId}/privacy-policy`.
    /// - Remark: Generated from `#/paths//console/project/{projectId}/privacy-policy/post(PrivacyPolicyController-create-2)`.
    public func privacyPolicyControllerCreate2(_ input: Operations.PrivacyPolicyControllerCreate2.Input) async throws -> Operations.PrivacyPolicyControllerCreate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PrivacyPolicyControllerCreate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/console/project/{}/privacy-policy",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /console/contact-sales/upgrade-plan-submission`.
    /// - Remark: Generated from `#/paths//console/contact-sales/upgrade-plan-submission/post(UpgradePlanSubmissionController-sendEmailToSales-2)`.
    public func upgradePlanSubmissionControllerSendEmailToSales2(_ input: Operations.UpgradePlanSubmissionControllerSendEmailToSales2.Input) async throws -> Operations.UpgradePlanSubmissionControllerSendEmailToSales2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UpgradePlanSubmissionControllerSendEmailToSales2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/console/contact-sales/upgrade-plan-submission",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /console/contact-sales/new-referral`.
    /// - Remark: Generated from `#/paths//console/contact-sales/new-referral/post(NewReferralRegisteredController-sendEmailToSales-2)`.
    public func newReferralRegisteredControllerSendEmailToSales2(_ input: Operations.NewReferralRegisteredControllerSendEmailToSales2.Input) async throws -> Operations.NewReferralRegisteredControllerSendEmailToSales2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NewReferralRegisteredControllerSendEmailToSales2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/console/contact-sales/new-referral",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update an individual quickstart
    ///
    /// - Remark: HTTP `PATCH /console/admin/quickstarts/{id}`.
    /// - Remark: Generated from `#/paths//console/admin/quickstarts/{id}/patch(QuickstartController-updateQuickstart-2)`.
    public func quickstartControllerUpdateQuickstart2(_ input: Operations.QuickstartControllerUpdateQuickstart2.Input) async throws -> Operations.QuickstartControllerUpdateQuickstart2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerUpdateQuickstart2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/console/admin/quickstarts/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete a quickstart
    ///
    /// - Remark: HTTP `DELETE /console/admin/quickstarts/{id}`.
    /// - Remark: Generated from `#/paths//console/admin/quickstarts/{id}/delete(QuickstartController-deleteQuickstart-2)`.
    public func quickstartControllerDeleteQuickstart2(_ input: Operations.QuickstartControllerDeleteQuickstart2.Input) async throws -> Operations.QuickstartControllerDeleteQuickstart2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerDeleteQuickstart2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/console/admin/quickstarts/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a new quickstart
    ///
    /// - Remark: HTTP `POST /console/admin/quickstarts`.
    /// - Remark: Generated from `#/paths//console/admin/quickstarts/post(QuickstartController-createQuickstart-2)`.
    public func quickstartControllerCreateQuickstart2(_ input: Operations.QuickstartControllerCreateQuickstart2.Input) async throws -> Operations.QuickstartControllerCreateQuickstart2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerCreateQuickstart2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/console/admin/quickstarts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                case 400:
                    return .badRequest(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/templates/{templateId}/get(TemplatesController-getTemplate-4)`.
    public func templatesControllerGetTemplate4(_ input: Operations.TemplatesControllerGetTemplate4.Input) async throws -> Operations.TemplatesControllerGetTemplate4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerGetTemplate4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PATCH /collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/templates/{templateId}/patch(TemplatesController-updateTemplate-4)`.
    public func templatesControllerUpdateTemplate4(_ input: Operations.TemplatesControllerUpdateTemplate4.Input) async throws -> Operations.TemplatesControllerUpdateTemplate4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerUpdateTemplate4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/templates/{templateId}/put(TemplatesController-createTemplateIdempotent-4)`.
    public func templatesControllerCreateTemplateIdempotent4(_ input: Operations.TemplatesControllerCreateTemplateIdempotent4.Input) async throws -> Operations.TemplatesControllerCreateTemplateIdempotent4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplateIdempotent4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/templates/{templateId}/delete(TemplatesController-deleteTemplate-4)`.
    public func templatesControllerDeleteTemplate4(_ input: Operations.TemplatesControllerDeleteTemplate4.Input) async throws -> Operations.TemplatesControllerDeleteTemplate4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerDeleteTemplate4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/templates/get(TemplatesController-listTemplates-4)`.
    public func templatesControllerListTemplates4(_ input: Operations.TemplatesControllerListTemplates4.Input) async throws -> Operations.TemplatesControllerListTemplates4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerListTemplates4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/templates/post(TemplatesController-createTemplate-4)`.
    public func templatesControllerCreateTemplate4(_ input: Operations.TemplatesControllerCreateTemplate4.Input) async throws -> Operations.TemplatesControllerCreateTemplate4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplate4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create SFT
    ///
    /// Create a new SFT
    ///
    /// - Remark: HTTP `POST /collections/{collectionId}/sfts`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/sfts/post(SFTsController-createSft-4)`.
    public func sfTsControllerCreateSft4(_ input: Operations.SFTsControllerCreateSft4.Input) async throws -> Operations.SFTsControllerCreateSft4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SFTsControllerCreateSft4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/sfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "idempotency-key",
                    value: input.headers.idempotencyKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer NFT
    ///
    /// Transfer an existing NFT
    ///
    /// - Remark: HTTP `POST /collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/nfts/{customerFacingId}/send/post(NFTsController-transferNft-4)`.
    public func nfTsControllerTransferNft4(_ input: Operations.NFTsControllerTransferNft4.Input) async throws -> Operations.NFTsControllerTransferNft4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerTransferNft4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFT
    ///
    /// Get a single NFT
    ///
    /// - Remark: HTTP `GET /collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/nfts/{customerFacingId}/get(NFTsController-getNft-4)`.
    public func nfTsControllerGetNft4(_ input: Operations.NFTsControllerGetNft4.Input) async throws -> Operations.NFTsControllerGetNft4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNft4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/nfts/{customerFacingId}/patch(NFTsController-updateNft-4)`.
    public func nfTsControllerUpdateNft4(_ input: Operations.NFTsControllerUpdateNft4.Input) async throws -> Operations.NFTsControllerUpdateNft4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerUpdateNft4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT (Idempotent)
    ///
    /// Create a new NFT with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/nfts/{customerFacingId}/put(NFTsController-createNftIdempotent-4)`.
    public func nfTsControllerCreateNftIdempotent4(_ input: Operations.NFTsControllerCreateNftIdempotent4.Input) async throws -> Operations.NFTsControllerCreateNftIdempotent4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNftIdempotent4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/nfts/{customerFacingId}/delete(NFTsController-deleteNft-4)`.
    public func nfTsControllerDeleteNft4(_ input: Operations.NFTsControllerDeleteNft4.Input) async throws -> Operations.NFTsControllerDeleteNft4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerDeleteNft4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs in a collection
    ///
    /// Get all NFTs in a collection
    ///
    /// - Remark: HTTP `GET /collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/nfts/get(NFTsController-getNfts-4)`.
    public func nfTsControllerGetNfts4(_ input: Operations.NFTsControllerGetNfts4.Input) async throws -> Operations.NFTsControllerGetNfts4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNfts4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT
    ///
    /// Create a new NFT
    ///
    /// - Remark: HTTP `POST /collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/nfts/post(NFTsController-createNft-4)`.
    public func nfTsControllerCreateNft4(_ input: Operations.NFTsControllerCreateNft4.Input) async throws -> Operations.NFTsControllerCreateNft4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNft4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/get(CollectionsController-getCollection-6)`.
    public func collectionsControllerGetCollection6(_ input: Operations.CollectionsControllerGetCollection6.Input) async throws -> Operations.CollectionsControllerGetCollection6.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection6.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/patch(CollectionsController-updateCollection-6)`.
    public func collectionsControllerUpdateCollection6(_ input: Operations.CollectionsControllerUpdateCollection6.Input) async throws -> Operations.CollectionsControllerUpdateCollection6.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection6.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//collections/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-6)`.
    public func collectionsControllerCreateIdempotentOrGetCollection6(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection6.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection6.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection6.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /collections/{clientId}/orders/stats`.
    /// - Remark: Generated from `#/paths//collections/{clientId}/orders/stats/get(CollectionOrdersController-getStatus-2)`.
    public func collectionOrdersControllerGetStatus2(_ input: Operations.CollectionOrdersControllerGetStatus2.Input) async throws -> Operations.CollectionOrdersControllerGetStatus2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetStatus2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/orders/stats",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /collections/{clientId}/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//collections/{clientId}/orders/{orderId}/get(CollectionOrdersController-getOrder-2)`.
    public func collectionOrdersControllerGetOrder2(_ input: Operations.CollectionOrdersControllerGetOrder2.Input) async throws -> Operations.CollectionOrdersControllerGetOrder2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetOrder2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/orders/{}",
                    parameters: [
                        input.path.clientId,
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /collections/{clientId}/orders`.
    /// - Remark: Generated from `#/paths//collections/{clientId}/orders/get(CollectionOrdersController-getOrders-2)`.
    public func collectionOrdersControllerGetOrders2(_ input: Operations.CollectionOrdersControllerGetOrders2.Input) async throws -> Operations.CollectionOrdersControllerGetOrders2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetOrders2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections/{}/orders",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recipient",
                    value: input.query.recipient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderId",
                    value: input.query.orderId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentMethod",
                    value: input.query.paymentMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentStatus",
                    value: input.query.paymentStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "deliveryStatus",
                    value: input.query.deliveryStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeSummary",
                    value: input.query.includeSummary
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "search",
                    value: input.query.search
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "identifier",
                    value: input.query.identifier
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /collections`.
    /// - Remark: Generated from `#/paths//collections/get(CollectionsController-getCollections-6)`.
    public func collectionsControllerGetCollections6(_ input: Operations.CollectionsControllerGetCollections6.Input) async throws -> Operations.CollectionsControllerGetCollections6.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections6.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /collections`.
    /// - Remark: Generated from `#/paths//collections/post(CollectionsController-createCollection-6)`.
    public func collectionsControllerCreateCollection6(_ input: Operations.CollectionsControllerCreateCollection6.Input) async throws -> Operations.CollectionsControllerCreateCollection6.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection6.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /address-autocomplete/suggestions`.
    /// - Remark: Generated from `#/paths//address-autocomplete/suggestions/get(AddressAutocompleteController-getSuggestions-2)`.
    public func addressAutocompleteControllerGetSuggestions2(_ input: Operations.AddressAutocompleteControllerGetSuggestions2.Input) async throws -> Operations.AddressAutocompleteControllerGetSuggestions2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AddressAutocompleteControllerGetSuggestions2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/address-autocomplete/suggestions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "query",
                    value: input.query.query
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /address-autocomplete/details`.
    /// - Remark: Generated from `#/paths//address-autocomplete/details/get(AddressAutocompleteController-getAddressDetails-2)`.
    public func addressAutocompleteControllerGetAddressDetails2(_ input: Operations.AddressAutocompleteControllerGetAddressDetails2.Input) async throws -> Operations.AddressAutocompleteControllerGetAddressDetails2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AddressAutocompleteControllerGetAddressDetails2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/address-autocomplete/details",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "placeId",
                    value: input.query.placeId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /actions/sendEmail/order-confirmation-email/send`.
    /// - Remark: Generated from `#/paths//actions/sendEmail/order-confirmation-email/send/get(EmailContentVerificationController-verify-2)`.
    public func emailContentVerificationControllerVerify2(_ input: Operations.EmailContentVerificationControllerVerify2.Input) async throws -> Operations.EmailContentVerificationControllerVerify2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.EmailContentVerificationControllerVerify2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/actions/sendEmail/order-confirmation-email/send",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderIdentifier",
                    value: input.query.orderIdentifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "templateIdentifier",
                    value: input.query.templateIdentifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /actions/mintAPI/dequeue`.
    /// - Remark: Generated from `#/paths//actions/mintAPI/dequeue/get(DequeueController-dequeueGet-2)`.
    public func dequeueControllerDequeueGet2(_ input: Operations.DequeueControllerDequeueGet2.Input) async throws -> Operations.DequeueControllerDequeueGet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DequeueControllerDequeueGet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/actions/mintAPI/dequeue",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /actions/mintAPI/dequeue`.
    /// - Remark: Generated from `#/paths//actions/mintAPI/dequeue/post(DequeueController-dequeuePost-2)`.
    public func dequeueControllerDequeuePost2(_ input: Operations.DequeueControllerDequeuePost2.Input) async throws -> Operations.DequeueControllerDequeuePost2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DequeueControllerDequeuePost2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/actions/mintAPI/dequeue",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /actions/{actionId}`.
    /// - Remark: Generated from `#/paths//actions/{actionId}/get(ActionsController-getAction-2)`.
    public func actionsControllerGetAction2(_ input: Operations.ActionsControllerGetAction2.Input) async throws -> Operations.ActionsControllerGetAction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ActionsControllerGetAction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/actions/{}",
                    parameters: [
                        input.path.actionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Orders by Project
    ///
    /// Get all orders for a specific project with filtering and pagination support
    ///
    /// - Remark: HTTP `GET /2025-06-15/orders`.
    /// - Remark: Generated from `#/paths//2025-06-15/orders/get(ProjectOrdersController-getProjectOrders-2)`.
    public func projectOrdersControllerGetProjectOrders2(_ input: Operations.ProjectOrdersControllerGetProjectOrders2.Input) async throws -> Operations.ProjectOrdersControllerGetProjectOrders2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectOrdersControllerGetProjectOrders2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-15/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortBy",
                    value: input.query.sortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortOrder",
                    value: input.query.sortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "projectId",
                    value: input.query.projectId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentMethod",
                    value: input.query.paymentMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentStatus",
                    value: input.query.paymentStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "deliveryStatus",
                    value: input.query.deliveryStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "collectionId",
                    value: input.query.collectionId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "createdAfter",
                    value: input.query.createdAfter
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "createdBefore",
                    value: input.query.createdBefore
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeSummary",
                    value: input.query.includeSummary
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "identifier",
                    value: input.query.identifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recipient",
                    value: input.query.recipient
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV2025Controller-submitMeApprovals-2)`.
    public func walletsV2025ControllerSubmitMeApprovals2(_ input: Operations.WalletsV2025ControllerSubmitMeApprovals2.Input) async throws -> Operations.WalletsV2025ControllerSubmitMeApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitMeApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/get(WalletsV2025Controller-getMeTransaction-2)`.
    public func walletsV2025ControllerGetMeTransaction2(_ input: Operations.WalletsV2025ControllerGetMeTransaction2.Input) async throws -> Operations.WalletsV2025ControllerGetMeTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransaction2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/transactions/get(WalletsV2025Controller-getMeTransactionsWithoutChain-2)`.
    public func walletsV2025ControllerGetMeTransactionsWithoutChain2(_ input: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.Input) async throws -> Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/transactions/post(WalletsV2025Controller-createMeTransaction-2)`.
    public func walletsV2025ControllerCreateMeTransaction2(_ input: Operations.WalletsV2025ControllerCreateMeTransaction2.Input) async throws -> Operations.WalletsV2025ControllerCreateMeTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token For Authenticated User
    ///
    /// Sends a token of any type from the authenticated user's wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenV2025Controller-sendMeToken-2)`.
    public func walletsSendTokenV2025ControllerSendMeToken2(_ input: Operations.WalletsSendTokenV2025ControllerSendMeToken2.Input) async throws -> Operations.WalletsSendTokenV2025ControllerSendMeToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenV2025ControllerSendMeToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenV2025ControllerSendMeToken2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signers/{signer}/get(WalletsV2025Controller-getMeDelegatedSigner-2)`.
    public func walletsV2025ControllerGetMeDelegatedSigner2(_ input: Operations.WalletsV2025ControllerGetMeDelegatedSigner2.Input) async throws -> Operations.WalletsV2025ControllerGetMeDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeDelegatedSigner2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signers/post(WalletsV2025Controller-createMeDelegatedSigner-2)`.
    public func walletsV2025ControllerCreateMeDelegatedSigner2(_ input: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Input) async throws -> Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV2025Controller-submitMeSignatureApprovals-2)`.
    public func walletsV2025ControllerSubmitMeSignatureApprovals2(_ input: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Input) async throws -> Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/get(WalletsV2025Controller-getMeSignature-2)`.
    public func walletsV2025ControllerGetMeSignature2(_ input: Operations.WalletsV2025ControllerGetMeSignature2.Input) async throws -> Operations.WalletsV2025ControllerGetMeSignature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeSignature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignature2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignature2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Signatures For Authenticated User
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signatures/get(WalletsV2025Controller-getMeSignatures-2)`.
    public func walletsV2025ControllerGetMeSignatures2(_ input: Operations.WalletsV2025ControllerGetMeSignatures2.Input) async throws -> Operations.WalletsV2025ControllerGetMeSignatures2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeSignatures2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignatures2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignatures2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/signatures/post(WalletsV2025Controller-createMeSignatureRequest-2)`.
    public func walletsV2025ControllerCreateMeSignatureRequest2(_ input: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Input) async throws -> Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/me{walletLocator}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me{walletLocator}/get(WalletsV2025Controller-getMeWallet-2)`.
    public func walletsV2025ControllerGetMeWallet2(_ input: Operations.WalletsV2025ControllerGetMeWallet2.Input) async throws -> Operations.WalletsV2025ControllerGetMeWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeWallet2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/me`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/me/post(WalletsV2025Controller-createMeWallet-2)`.
    public func walletsV2025ControllerCreateMeWallet2(_ input: Operations.WalletsV2025ControllerCreateMeWallet2.Input) async throws -> Operations.WalletsV2025ControllerCreateMeWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeWallet2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV2025Controller-submitApprovals-2)`.
    public func walletsV2025ControllerSubmitApprovals2(_ input: Operations.WalletsV2025ControllerSubmitApprovals2.Input) async throws -> Operations.WalletsV2025ControllerSubmitApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV2025Controller-getTransaction-2)`.
    public func walletsV2025ControllerGetTransaction2(_ input: Operations.WalletsV2025ControllerGetTransaction2.Input) async throws -> Operations.WalletsV2025ControllerGetTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransaction2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/transactions/get(WalletsV2025Controller-getTransactionsWithoutChain-2)`.
    public func walletsV2025ControllerGetTransactionsWithoutChain2(_ input: Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.Input) async throws -> Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransactionsWithoutChain2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/transactions/post(WalletsV2025Controller-createTransaction-2)`.
    public func walletsV2025ControllerCreateTransaction2(_ input: Operations.WalletsV2025ControllerCreateTransaction2.Input) async throws -> Operations.WalletsV2025ControllerCreateTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token
    ///
    /// Sends a token of any type from this wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenV2025Controller-sendToken-2)`.
    public func walletsSendTokenV2025ControllerSendToken2(_ input: Operations.WalletsSendTokenV2025ControllerSendToken2.Input) async throws -> Operations.WalletsSendTokenV2025ControllerSendToken2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenV2025ControllerSendToken2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenV2025ControllerSendToken2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signers/{signer}/get(WalletsV2025Controller-getDelegatedSigner-2)`.
    public func walletsV2025ControllerGetDelegatedSigner2(_ input: Operations.WalletsV2025ControllerGetDelegatedSigner2.Input) async throws -> Operations.WalletsV2025ControllerGetDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetDelegatedSigner2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Delegated Signer
    ///
    /// Create a delegated signer for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signers/post(WalletsV2025Controller-createDelegatedSigner-2)`.
    public func walletsV2025ControllerCreateDelegatedSigner2(_ input: Operations.WalletsV2025ControllerCreateDelegatedSigner2.Input) async throws -> Operations.WalletsV2025ControllerCreateDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV2025Controller-submitSignatureApprovals-2)`.
    public func walletsV2025ControllerSubmitSignatureApprovals2(_ input: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Input) async throws -> Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV2025Controller-getSignature-2)`.
    public func walletsV2025ControllerGetSignature2(_ input: Operations.WalletsV2025ControllerGetSignature2.Input) async throws -> Operations.WalletsV2025ControllerGetSignature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetSignature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetSignature2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetSignature2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signatures/get(WalletsV2025Controller-getAllSignatures-2)`.
    public func walletsV2025ControllerGetAllSignatures2(_ input: Operations.WalletsV2025ControllerGetAllSignatures2.Input) async throws -> Operations.WalletsV2025ControllerGetAllSignatures2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetAllSignatures2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetAllSignatures2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetAllSignatures2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/signatures/post(WalletsV2025Controller-createSignatureRequest-2)`.
    public func walletsV2025ControllerCreateSignatureRequest2(_ input: Operations.WalletsV2025ControllerCreateSignatureRequest2.Input) async throws -> Operations.WalletsV2025ControllerCreateSignatureRequest2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateSignatureRequest2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/balances/get(BalanceV20250609Controller-getBalanceForLocator-2)`.
    public func balanceV20250609ControllerGetBalanceForLocator2(_ input: Operations.BalanceV20250609ControllerGetBalanceForLocator2.Input) async throws -> Operations.BalanceV20250609ControllerGetBalanceForLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceV20250609ControllerGetBalanceForLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceV20250609ControllerGetBalanceForLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceV20250609ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceV20250609ControllerGetBalanceForLocator2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2025-06-09/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/{walletLocator}/get(WalletsV2025Controller-getWalletByLocator-2)`.
    public func walletsV2025ControllerGetWalletByLocator2(_ input: Operations.WalletsV2025ControllerGetWalletByLocator2.Input) async throws -> Operations.WalletsV2025ControllerGetWalletByLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetWalletByLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetWalletByLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetWalletByLocator2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When owner is provided, subsequent calls with the same owner will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2025-06-09/wallets`.
    /// - Remark: Generated from `#/paths//2025-06-09/wallets/post(WalletsV2025Controller-createWallet-2)`.
    public func walletsV2025ControllerCreateWallet2(_ input: Operations.WalletsV2025ControllerCreateWallet2.Input) async throws -> Operations.WalletsV2025ControllerCreateWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2025-06-09/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateWallet2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateWallet2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-09-26/session/sdk/auth/social/{provider}/start`.
    /// - Remark: Generated from `#/paths//2024-09-26/session/sdk/auth/social/{provider}/start/get(AuthSdkSessionController-getOauthUrl-2)`.
    public func authSdkSessionControllerGetOauthUrl2(_ input: Operations.AuthSdkSessionControllerGetOauthUrl2.Input) async throws -> Operations.AuthSdkSessionControllerGetOauthUrl2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerGetOauthUrl2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/session/sdk/auth/social/{}/start",
                    parameters: [
                        input.path.provider
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "appSchema",
                    value: input.query.appSchema
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-api-key",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-app-identifier",
                    value: input.headers.xAppIdentifier
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-09-26/session/sdk/auth/refresh`.
    /// - Remark: Generated from `#/paths//2024-09-26/session/sdk/auth/refresh/post(AuthSdkSessionController-refresh-2)`.
    public func authSdkSessionControllerRefresh2(_ input: Operations.AuthSdkSessionControllerRefresh2.Input) async throws -> Operations.AuthSdkSessionControllerRefresh2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerRefresh2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/session/sdk/auth/refresh",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-09-26/session/sdk/auth/otps/send`.
    /// - Remark: Generated from `#/paths//2024-09-26/session/sdk/auth/otps/send/post(AuthSdkSessionController-initiateEmailAuthentication-2)`.
    public func authSdkSessionControllerInitiateEmailAuthentication2(_ input: Operations.AuthSdkSessionControllerInitiateEmailAuthentication2.Input) async throws -> Operations.AuthSdkSessionControllerInitiateEmailAuthentication2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerInitiateEmailAuthentication2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/session/sdk/auth/otps/send",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-09-26/session/sdk/auth/logout`.
    /// - Remark: Generated from `#/paths//2024-09-26/session/sdk/auth/logout/post(AuthSdkSessionController-logout-2)`.
    public func authSdkSessionControllerLogout2(_ input: Operations.AuthSdkSessionControllerLogout2.Input) async throws -> Operations.AuthSdkSessionControllerLogout2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerLogout2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/session/sdk/auth/logout",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start`.
    /// - Remark: Generated from `#/paths//2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start/post(AuthSdkSessionController-startCryptoWalletAuthentication-2)`.
    public func authSdkSessionControllerStartCryptoWalletAuthentication2(_ input: Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication2.Input) async throws -> Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-09-26/session/sdk/auth/crypto_wallets/authenticate`.
    /// - Remark: Generated from `#/paths//2024-09-26/session/sdk/auth/crypto_wallets/authenticate/post(AuthSdkSessionController-authenticateCryptoWallet-2)`.
    public func authSdkSessionControllerAuthenticateCryptoWallet2(_ input: Operations.AuthSdkSessionControllerAuthenticateCryptoWallet2.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateCryptoWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateCryptoWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/session/sdk/auth/crypto_wallets/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-09-26/session/sdk/auth/authenticate`.
    /// - Remark: Generated from `#/paths//2024-09-26/session/sdk/auth/authenticate/get(AuthSdkSessionController-authenticateOAuthAuthSDK-2)`.
    public func authSdkSessionControllerAuthenticateOAuthAuthSDK2(_ input: Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK2.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/session/sdk/auth/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-09-26/session/sdk/auth/authenticate`.
    /// - Remark: Generated from `#/paths//2024-09-26/session/sdk/auth/authenticate/post(AuthSdkSessionController-authenticateAuthSDK-2)`.
    public func authSdkSessionControllerAuthenticateAuthSDK2(_ input: Operations.AuthSdkSessionControllerAuthenticateAuthSDK2.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateAuthSDK2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateAuthSDK2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/session/sdk/auth/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-09-26/sdk/auth/user/{externalUserId}`.
    /// - Remark: Generated from `#/paths//2024-09-26/sdk/auth/user/{externalUserId}/get(AuthSdkController-getUserServerSide-2)`.
    public func authSdkControllerGetUserServerSide2(_ input: Operations.AuthSdkControllerGetUserServerSide2.Input) async throws -> Operations.AuthSdkControllerGetUserServerSide2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkControllerGetUserServerSide2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/sdk/auth/user/{}",
                    parameters: [
                        input.path.externalUserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-09-26/sdk/auth/user`.
    /// - Remark: Generated from `#/paths//2024-09-26/sdk/auth/user/get(AuthSdkController-getUserClientSide-2)`.
    public func authSdkControllerGetUserClientSide2(_ input: Operations.AuthSdkControllerGetUserClientSide2.Input) async throws -> Operations.AuthSdkControllerGetUserClientSide2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkControllerGetUserClientSide2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-09-26/sdk/auth/user",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-06-09/sdk/smart-wallet/config`.
    /// - Remark: Generated from `#/paths//2024-06-09/sdk/smart-wallet/config/get(SmartWalletSDKController-getConfig-2)`.
    public func smartWalletSDKControllerGetConfig2(_ input: Operations.SmartWalletSDKControllerGetConfig2.Input) async throws -> Operations.SmartWalletSDKControllerGetConfig2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SmartWalletSDKControllerGetConfig2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-06-09/sdk/smart-wallet/config",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2024-06-09/sdk/smart-wallet`.
    /// - Remark: Generated from `#/paths//2024-06-09/sdk/smart-wallet/put(SmartWalletSDKController-save-2)`.
    public func smartWalletSDKControllerSave2(_ input: Operations.SmartWalletSDKControllerSave2.Input) async throws -> Operations.SmartWalletSDKControllerSave2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SmartWalletSDKControllerSave2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-06-09/sdk/smart-wallet",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-06-09/sdk/paymaster`.
    /// - Remark: Generated from `#/paths//2024-06-09/sdk/paymaster/post(PaymasterProxyController-sponsorUserOp-2)`.
    public func paymasterProxyControllerSponsorUserOp2(_ input: Operations.PaymasterProxyControllerSponsorUserOp2.Input) async throws -> Operations.PaymasterProxyControllerSponsorUserOp2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PaymasterProxyControllerSponsorUserOp2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-06-09/sdk/paymaster",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/worldstore/protocol-alpha/webhooks/rye`.
    /// - Remark: Generated from `#/paths//2024-01-01/worldstore/protocol-alpha/webhooks/rye/post(WorldstoreAlphaOrderWebhooksController-ryeWebhook-1)`.
    public func worldstoreAlphaOrderWebhooksControllerRyeWebhook1(_ input: Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook1.Input) async throws -> Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/worldstore/protocol-alpha/webhooks/rye",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order tracking information
    ///
    /// - Remark: HTTP `GET /2024-01-01/worldstore/protocol-alpha/store/amazon/orders/{orderHash}/tracking`.
    /// - Remark: Generated from `#/paths//2024-01-01/worldstore/protocol-alpha/store/amazon/orders/{orderHash}/tracking/get(WorldstoreAlphaController-getOrderTracking-1)`.
    public func worldstoreAlphaControllerGetOrderTracking1(_ input: Operations.WorldstoreAlphaControllerGetOrderTracking1.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrderTracking1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrderTracking1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/worldstore/protocol-alpha/store/amazon/orders/{}/tracking",
                    parameters: [
                        input.path.orderHash
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Webhook for Worldstore Alpha
    ///
    /// - Remark: HTTP `POST /2024-01-01/worldstore/protocol-alpha/store/{store}/webhook`.
    /// - Remark: Generated from `#/paths//2024-01-01/worldstore/protocol-alpha/store/{store}/webhook/post(WorldstoreAlphaController-webhook-1)`.
    public func worldstoreAlphaControllerWebhook1(_ input: Operations.WorldstoreAlphaControllerWebhook1.Input) async throws -> Operations.WorldstoreAlphaControllerWebhook1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerWebhook1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/worldstore/protocol-alpha/store/{}/webhook",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an order for a listing
    ///
    /// - Remark: HTTP `POST /2024-01-01/worldstore/protocol-alpha/store/{store}/orders`.
    /// - Remark: Generated from `#/paths//2024-01-01/worldstore/protocol-alpha/store/{store}/orders/post(WorldstoreAlphaController-getOrder-1)`.
    public func worldstoreAlphaControllerGetOrder1(_ input: Operations.WorldstoreAlphaControllerGetOrder1.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrder1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrder1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/worldstore/protocol-alpha/store/{}/orders",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order parameters schema for a store
    ///
    /// - Remark: HTTP `GET /2024-01-01/worldstore/protocol-alpha/store/{store}/orderParameters`.
    /// - Remark: Generated from `#/paths//2024-01-01/worldstore/protocol-alpha/store/{store}/orderParameters/get(WorldstoreAlphaController-getOrderParametersSchema-1)`.
    public func worldstoreAlphaControllerGetOrderParametersSchema1(_ input: Operations.WorldstoreAlphaControllerGetOrderParametersSchema1.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrderParametersSchema1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrderParametersSchema1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/worldstore/protocol-alpha/store/{}/orderParameters",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get metadata for a store
    ///
    /// - Remark: HTTP `GET /2024-01-01/worldstore/protocol-alpha/store/{store}/metadata`.
    /// - Remark: Generated from `#/paths//2024-01-01/worldstore/protocol-alpha/store/{store}/metadata/get(WorldstoreAlphaController-getMetadata-1)`.
    public func worldstoreAlphaControllerGetMetadata1(_ input: Operations.WorldstoreAlphaControllerGetMetadata1.Input) async throws -> Operations.WorldstoreAlphaControllerGetMetadata1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetMetadata1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/worldstore/protocol-alpha/store/{}/metadata",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get listings for a product
    ///
    /// - Remark: HTTP `GET /2024-01-01/worldstore/protocol-alpha/store/{store}/listings`.
    /// - Remark: Generated from `#/paths//2024-01-01/worldstore/protocol-alpha/store/{store}/listings/get(WorldstoreAlphaController-getListings-1)`.
    public func worldstoreAlphaControllerGetListings1(_ input: Operations.WorldstoreAlphaControllerGetListings1.Input) async throws -> Operations.WorldstoreAlphaControllerGetListings1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetListings1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/worldstore/protocol-alpha/store/{}/listings",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "uid",
                    value: input.query.uid
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/webhooks/internal/lead-scanner`.
    /// - Remark: Generated from `#/paths//2024-01-01/webhooks/internal/lead-scanner/post(LeadScannerController-scan-1)`.
    public func leadScannerControllerScan1(_ input: Operations.LeadScannerControllerScan1.Input) async throws -> Operations.LeadScannerControllerScan1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.LeadScannerControllerScan1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/webhooks/internal/lead-scanner",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Start the device onboarding process
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1/signers/start-onboarding`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/signers/start-onboarding/post(NCSController-forwardStartOnboarding-2)`.
    public func ncsControllerForwardStartOnboarding2(_ input: Operations.NCSControllerForwardStartOnboarding2.Input) async throws -> Operations.NCSControllerForwardStartOnboarding2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardStartOnboarding2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/signers/start-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deterministically generate a signer's public key for a specified signing curve
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1/signers/derive-public-key`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/signers/derive-public-key/post(NCSController-forwardPreGeneration-2)`.
    public func ncsControllerForwardPreGeneration2(_ input: Operations.NCSControllerForwardPreGeneration2.Input) async throws -> Operations.NCSControllerForwardPreGeneration2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardPreGeneration2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/signers/derive-public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Complete the device onboarding process, storing an encrypted master secret, and forwarding it to the device
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1/signers/complete-onboarding`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/signers/complete-onboarding/post(NCSController-forwardCompleteOnboarding-2)`.
    public func ncsControllerForwardCompleteOnboarding2(_ input: Operations.NCSControllerForwardCompleteOnboarding2.Input) async throws -> Operations.NCSControllerForwardCompleteOnboarding2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardCompleteOnboarding2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/signers/complete-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset Licenses
    ///
    /// Get the licenses of an IP Asset
    ///
    /// The ipassetId parameter should be the Story Protocol asset ID (not the Crossmint ID). Must start with '0x' followed by hexadecimal characters.
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/ip/licenses/{ipassetId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/licenses/{ipassetId}/get(StoryApiController-getIpaLicenses-1)`.
    public func storyApiControllerGetIpaLicenses1(_ input: Operations.StoryApiControllerGetIpaLicenses1.Input) async throws -> Operations.StoryApiControllerGetIpaLicenses1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetIpaLicenses1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/licenses/{}",
                    parameters: [
                        input.path.ipassetId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetIpaLicenses1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset Graph
    ///
    /// Get the graph of an IP Asset, by default it will fetch the first level of parents and children (depth = 1). You can customize the depth using the query parameter 'depth' to a maximum of 3. Maximum 100 parents or children will be returned for each level.
    ///
    /// The ipAssetId parameter should be the Story Protocol asset ID (not the Crossmint ID). Must start with '0x' followed by hexadecimal characters.
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/ip/graph/{ipAssetId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/graph/{ipAssetId}/get(StoryApiController-getIpaGraph-1)`.
    public func storyApiControllerGetIpaGraph1(_ input: Operations.StoryApiControllerGetIpaGraph1.Input) async throws -> Operations.StoryApiControllerGetIpaGraph1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetIpaGraph1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/graph/{}",
                    parameters: [
                        input.path.ipAssetId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "depth",
                    value: input.query.depth
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetIpaGraph1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetGraphDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset
    ///
    /// Get a single IP Asset
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/get(StoryApiController-getNft-1)`.
    public func storyApiControllerGetNft1(_ input: Operations.StoryApiControllerGetNft1.Input) async throws -> Operations.StoryApiControllerGetNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetNft1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update IP Asset
    ///
    /// Update an existing IP Asset
    ///
    /// **API scope required**: `nfts.update`
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/patch(StoryApiController-updateNft-1)`.
    public func storyApiControllerUpdateNft1(_ input: Operations.StoryApiControllerUpdateNft1.Input) async throws -> Operations.StoryApiControllerUpdateNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerUpdateNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerUpdateNft1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetUpdateResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create IP Asset (Idempotent)
    ///
    /// Create a new IP Asset with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `PUT /2024-01-01/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/put(StoryApiController-createIPAssetIdempotent-1)`.
    public func storyApiControllerCreateIPAssetIdempotent1(_ input: Operations.StoryApiControllerCreateIPAssetIdempotent1.Input) async throws -> Operations.StoryApiControllerCreateIPAssetIdempotent1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIPAssetIdempotent1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIPAssetIdempotent1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Assets in a collection
    ///
    /// Get all IP Assets in a collection
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/ip/collections/{collectionId}/ipassets`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/{collectionId}/ipassets/get(StoryApiController-getNfts-1)`.
    public func storyApiControllerGetNfts1(_ input: Operations.StoryApiControllerGetNfts1.Input) async throws -> Operations.StoryApiControllerGetNfts1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetNfts1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections/{}/ipassets",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetNfts1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultipleIPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create IP Asset
    ///
    /// Create a new IP Asset
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1/ip/collections/{collectionId}/ipassets`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/{collectionId}/ipassets/post(StoryApiController-createIPAsset-1)`.
    public func storyApiControllerCreateIPAsset1(_ input: Operations.StoryApiControllerCreateIPAsset1.Input) async throws -> Operations.StoryApiControllerCreateIPAsset1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIPAsset1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections/{}/ipassets",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIPAsset1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a Collection
    ///
    /// Get a collection by its id deployed on the Story chain
    ///
    /// **API scope required**: `collections.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/ip/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/{collectionId}/get(StoryApiController-getCollection-1)`.
    public func storyApiControllerGetCollection1(_ input: Operations.StoryApiControllerGetCollection1.Input) async throws -> Operations.StoryApiControllerGetCollection1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetCollection1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetCollection1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `collections.create`
    ///
    /// - Remark: HTTP `PUT /2024-01-01/v1/ip/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/{collectionId}/put(StoryApiController-createIdempotent-1)`.
    public func storyApiControllerCreateIdempotent1(_ input: Operations.StoryApiControllerCreateIdempotent1.Input) async throws -> Operations.StoryApiControllerCreateIdempotent1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIdempotent1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIdempotent1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Collections
    ///
    /// Get all collections associated with the Developer Project
    ///
    /// **API scope required**: `collections.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/ip/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/get(StoryApiController-getCollections-1)`.
    public func storyApiControllerGetCollections1(_ input: Operations.StoryApiControllerGetCollections1.Input) async throws -> Operations.StoryApiControllerGetCollections1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetCollections1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetCollections1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultipleCollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `collections.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1/ip/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/collections/post(StoryApiController-create-1)`.
    public func storyApiControllerCreate1(_ input: Operations.StoryApiControllerCreate1.Input) async throws -> Operations.StoryApiControllerCreate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreate1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Action
    ///
    /// Get an action by its id
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/ip/actions/{actionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/ip/actions/{actionId}/get(StoryApiController-getAction-1)`.
    public func storyApiControllerGetAction1(_ input: Operations.StoryApiControllerGetAction1.Input) async throws -> Operations.StoryApiControllerGetAction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetAction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/ip/actions/{}",
                    parameters: [
                        input.path.actionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetAction1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.StoryActionsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get everything an NCS device needs to operate, including the encrypted master secret.
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/devices/{deviceId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/devices/{deviceId}/get(NCSController-getDevice-2)`.
    public func ncsControllerGetDevice2(_ input: Operations.NCSControllerGetDevice2.Input) async throws -> Operations.NCSControllerGetDevice2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetDevice2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/devices/{}",
                    parameters: [
                        input.path.deviceId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the encryption public key for the TEE - for local developement
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/attestation/public-key`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/attestation/public-key/get(NCSController-getPublicKey-2)`.
    public func ncsControllerGetPublicKey2(_ input: Operations.NCSControllerGetPublicKey2.Input) async throws -> Operations.NCSControllerGetPublicKey2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetPublicKey2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/attestation/public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the attestation for the TEE
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1/attestation`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1/attestation/get(NCSController-getAttestation-2)`.
    public func ncsControllerGetAttestation2(_ input: Operations.NCSControllerGetAttestation2.Input) async throws -> Operations.NCSControllerGetAttestation2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetAttestation2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1/attestation",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitMeApprovals-3)`.
    public func walletsV1ControllerSubmitMeApprovals3(_ input: Operations.WalletsV1ControllerSubmitMeApprovals3.Input) async throws -> Operations.WalletsV1ControllerSubmitMeApprovals3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeApprovals3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals3.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals3.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/get(WalletsV1Controller-getMeTransaction-3)`.
    public func walletsV1ControllerGetMeTransaction3(_ input: Operations.WalletsV1ControllerGetMeTransaction3.Input) async throws -> Operations.WalletsV1ControllerGetMeTransaction3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransaction3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/transactions/get(WalletsV1Controller-getMeTransactionsWithoutChain-3)`.
    public func walletsV1ControllerGetMeTransactionsWithoutChain3(_ input: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain3.Input) async throws -> Operations.WalletsV1ControllerGetMeTransactionsWithoutChain3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/transactions/post(WalletsV1Controller-createMeTransaction-3)`.
    public func walletsV1ControllerCreateMeTransaction3(_ input: Operations.WalletsV1ControllerCreateMeTransaction3.Input) async throws -> Operations.WalletsV1ControllerCreateMeTransaction3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeTransaction3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction3.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/me{walletType}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/signers/{signer}/get(WalletsV1Controller-getMeDelegatedSigner-3)`.
    public func walletsV1ControllerGetMeDelegatedSigner3(_ input: Operations.WalletsV1ControllerGetMeDelegatedSigner3.Input) async throws -> Operations.WalletsV1ControllerGetMeDelegatedSigner3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeDelegatedSigner3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/me{walletType}/signers`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/signers/post(WalletsV1Controller-createMeDelegatedSigner-3)`.
    public func walletsV1ControllerCreateMeDelegatedSigner3(_ input: Operations.WalletsV1ControllerCreateMeDelegatedSigner3.Input) async throws -> Operations.WalletsV1ControllerCreateMeDelegatedSigner3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeDelegatedSigner3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/signers",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitMeSignatureApprovals-3)`.
    public func walletsV1ControllerSubmitMeSignatureApprovals3(_ input: Operations.WalletsV1ControllerSubmitMeSignatureApprovals3.Input) async throws -> Operations.WalletsV1ControllerSubmitMeSignatureApprovals3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeSignatureApprovals3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/get(WalletsV1Controller-getMeSignature-3)`.
    public func walletsV1ControllerGetMeSignature3(_ input: Operations.WalletsV1ControllerGetMeSignature3.Input) async throws -> Operations.WalletsV1ControllerGetMeSignature3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeSignature3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/me{walletType}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/signatures/post(WalletsV1Controller-createMeSignatureRequest-3)`.
    public func walletsV1ControllerCreateMeSignatureRequest3(_ input: Operations.WalletsV1ControllerCreateMeSignatureRequest3.Input) async throws -> Operations.WalletsV1ControllerCreateMeSignatureRequest3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeSignatureRequest3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/me{walletType}/activity`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/activity/get(WalletsV1Controller-getMeWalletActivity-3)`.
    public func walletsV1ControllerGetMeWalletActivity3(_ input: Operations.WalletsV1ControllerGetMeWalletActivity3.Input) async throws -> Operations.WalletsV1ControllerGetMeWalletActivity3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWalletActivity3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}/activity",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/me{walletType}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me{walletType}/get(WalletsV1Controller-getMeWallet-3)`.
    public func walletsV1ControllerGetMeWallet3(_ input: Operations.WalletsV1ControllerGetMeWallet3.Input) async throws -> Operations.WalletsV1ControllerGetMeWallet3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWallet3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me{}",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWallet3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/me`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/me/post(WalletsV1Controller-createMeWallet-3)`.
    public func walletsV1ControllerCreateMeWallet3(_ input: Operations.WalletsV1ControllerCreateMeWallet3.Input) async throws -> Operations.WalletsV1ControllerCreateMeWallet3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeWallet3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeWallet3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitApprovals-3)`.
    public func walletsV1ControllerSubmitApprovals3(_ input: Operations.WalletsV1ControllerSubmitApprovals3.Input) async throws -> Operations.WalletsV1ControllerSubmitApprovals3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitApprovals3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals3.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals3.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV1Controller-getTransaction-3)`.
    public func walletsV1ControllerGetTransaction3(_ input: Operations.WalletsV1ControllerGetTransaction3.Input) async throws -> Operations.WalletsV1ControllerGetTransaction3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransaction3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/transactions/get(WalletsV1Controller-getTransactionsWithoutChain-3)`.
    public func walletsV1ControllerGetTransactionsWithoutChain3(_ input: Operations.WalletsV1ControllerGetTransactionsWithoutChain3.Input) async throws -> Operations.WalletsV1ControllerGetTransactionsWithoutChain3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransactionsWithoutChain3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/transactions/post(WalletsV1Controller-createTransaction-3)`.
    public func walletsV1ControllerCreateTransaction3(_ input: Operations.WalletsV1ControllerCreateTransaction3.Input) async throws -> Operations.WalletsV1ControllerCreateTransaction3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateTransaction3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction3.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/signers/{signer}/get(WalletsV1Controller-getDelegatedSigner-3)`.
    public func walletsV1ControllerGetDelegatedSigner3(_ input: Operations.WalletsV1ControllerGetDelegatedSigner3.Input) async throws -> Operations.WalletsV1ControllerGetDelegatedSigner3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetDelegatedSigner3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/signers/post(WalletsV1Controller-createDelegatedSigner-3)`.
    public func walletsV1ControllerCreateDelegatedSigner3(_ input: Operations.WalletsV1ControllerCreateDelegatedSigner3.Input) async throws -> Operations.WalletsV1ControllerCreateDelegatedSigner3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateDelegatedSigner3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitSignatureApprovals-3)`.
    public func walletsV1ControllerSubmitSignatureApprovals3(_ input: Operations.WalletsV1ControllerSubmitSignatureApprovals3.Input) async throws -> Operations.WalletsV1ControllerSubmitSignatureApprovals3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitSignatureApprovals3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV1Controller-getSignature-3)`.
    public func walletsV1ControllerGetSignature3(_ input: Operations.WalletsV1ControllerGetSignature3.Input) async throws -> Operations.WalletsV1ControllerGetSignature3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetSignature3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/signatures/get(WalletsV1Controller-getAllSignatures-3)`.
    public func walletsV1ControllerGetAllSignatures3(_ input: Operations.WalletsV1ControllerGetAllSignatures3.Input) async throws -> Operations.WalletsV1ControllerGetAllSignatures3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetAllSignatures3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2MultipleSignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/signatures/post(WalletsV1Controller-createSignatureRequest-3)`.
    public func walletsV1ControllerCreateSignatureRequest3(_ input: Operations.WalletsV1ControllerCreateSignatureRequest3.Input) async throws -> Operations.WalletsV1ControllerCreateSignatureRequest3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateSignatureRequest3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/balances/get(BalanceController-getBalanceForLocator-1)`.
    public func balanceControllerGetBalanceForLocator1(_ input: Operations.BalanceControllerGetBalanceForLocator1.Input) async throws -> Operations.BalanceControllerGetBalanceForLocator1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceControllerGetBalanceForLocator1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerGetBalanceForLocator1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerGetBalanceForLocator1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Fund Wallet
    ///
    /// Send funds to a wallet.
    ///
    /// **API scope required**: `wallets.fund`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/balances/post(BalanceController-fundWallet-1)`.
    public func balanceControllerFundWallet1(_ input: Operations.BalanceControllerFundWallet1.Input) async throws -> Operations.BalanceControllerFundWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceControllerFundWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerFundWallet1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerFundWallet1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/activity/get(WalletsV1Controller-getWalletActivity-3)`.
    public func walletsV1ControllerGetWalletActivity3(_ input: Operations.WalletsV1ControllerGetWalletActivity3.Input) async throws -> Operations.WalletsV1ControllerGetWalletActivity3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletActivity3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/{walletLocator}/get(WalletsV1Controller-getWalletByLocator-3)`.
    public func walletsV1ControllerGetWalletByLocator3(_ input: Operations.WalletsV1ControllerGetWalletByLocator3.Input) async throws -> Operations.WalletsV1ControllerGetWalletByLocator3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletByLocator3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator3.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When linkedUser is provided, subsequent calls with the same linkedUser will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha2/wallets`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/wallets/post(WalletsV1Controller-createWallet-3)`.
    public func walletsV1ControllerCreateWallet3(_ input: Operations.WalletsV1ControllerCreateWallet3.Input) async throws -> Operations.WalletsV1ControllerCreateWallet3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateWallet3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet3.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet3.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a token and its available features by its locator
    ///
    /// Get a token by its locator
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha2/tokens/{tokenLocator}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha2/tokens/{tokenLocator}/get(TokensController-getToken-1)`.
    public func tokensControllerGetToken1(_ input: Operations.TokensControllerGetToken1.Input) async throws -> Operations.TokensControllerGetToken1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokensControllerGetToken1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha2/tokens/{}",
                    parameters: [
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TokensControllerGetToken1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SupportedTokenResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/wallets/{walletLocator}/credential_nfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/wallets/{walletLocator}/credential_nfts/get(WalletCredentialsController-getNFTsFromWallet-1)`.
    public func walletCredentialsControllerGetNFTsFromWallet1(_ input: Operations.WalletCredentialsControllerGetNFTsFromWallet1.Input) async throws -> Operations.WalletCredentialsControllerGetNFTsFromWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletCredentialsControllerGetNFTsFromWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/wallets/{}/credential_nfts",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs from Wallet
    ///
    /// Retrieves NFTs from a wallet.
    ///
    /// **API scope required**: `wallets:nfts.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/wallets/{locator}/nfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/wallets/{locator}/nfts/get(WalletNFTController-getNFTsFromWallet-3)`.
    public func walletNFTControllerGetNFTsFromWallet3(_ input: Operations.WalletNFTControllerGetNFTsFromWallet3.Input) async throws -> Operations.WalletNFTControllerGetNFTsFromWallet3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletNFTControllerGetNFTsFromWallet3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/wallets/{}/nfts",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "contractAddress",
                    value: input.query.contractAddress
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokenId",
                    value: input.query.tokenId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletNFTControllerGetNFTsFromWallet3.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNFTsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/wallets`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/wallets/get(WalletController-getWalletForUser-1)`.
    public func walletControllerGetWalletForUser1(_ input: Operations.WalletControllerGetWalletForUser1.Input) async throws -> Operations.WalletControllerGetWalletForUser1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletControllerGetWalletForUser1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "uid",
                    value: input.query.uid
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "phoneNumber",
                    value: input.query.phoneNumber
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha1/wallets`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/wallets/post(WalletController-createWalletForUser-1)`.
    public func walletControllerCreateWalletForUser1(_ input: Operations.WalletControllerCreateWalletForUser1.Input) async throws -> Operations.WalletControllerCreateWalletForUser1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletControllerCreateWalletForUser1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/projects/{projectId}/wallets-created`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/projects/{projectId}/wallets-created/get(WalletsCreatedController-getWalletsCreated-1)`.
    public func walletsCreatedControllerGetWalletsCreated1(_ input: Operations.WalletsCreatedControllerGetWalletsCreated1.Input) async throws -> Operations.WalletsCreatedControllerGetWalletsCreated1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsCreatedControllerGetWalletsCreated1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/projects/{}/wallets-created",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/projects/{projectId}/usage`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/projects/{projectId}/usage/get(ProjectUsageController-getUsage-1)`.
    public func projectUsageControllerGetUsage1(_ input: Operations.ProjectUsageControllerGetUsage1.Input) async throws -> Operations.ProjectUsageControllerGetUsage1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectUsageControllerGetUsage1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/projects/{}/usage",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "dimension",
                    value: input.query.dimension
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "startDate",
                    value: input.query.startDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "endDate",
                    value: input.query.endDate
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2024-01-01/v1-alpha1/projects/{projectId}/domains/{domain}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/projects/{projectId}/domains/{domain}/put(ProjectDomainsController-updateDomain-1)`.
    public func projectDomainsControllerUpdateDomain1(_ input: Operations.ProjectDomainsControllerUpdateDomain1.Input) async throws -> Operations.ProjectDomainsControllerUpdateDomain1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectDomainsControllerUpdateDomain1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/projects/{}/domains/{}",
                    parameters: [
                        input.path.projectId,
                        input.path.domain
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /2024-01-01/v1-alpha1/projects/{projectId}/domains/{domain}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/projects/{projectId}/domains/{domain}/delete(ProjectDomainsController-deleteDomain-1)`.
    public func projectDomainsControllerDeleteDomain1(_ input: Operations.ProjectDomainsControllerDeleteDomain1.Input) async throws -> Operations.ProjectDomainsControllerDeleteDomain1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectDomainsControllerDeleteDomain1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/projects/{}/domains/{}",
                    parameters: [
                        input.path.projectId,
                        input.path.domain
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/projects/{projectId}/branding`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/projects/{projectId}/branding/get(BrandingController-get-1)`.
    public func brandingControllerGet1(_ input: Operations.BrandingControllerGet1.Input) async throws -> Operations.BrandingControllerGet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BrandingControllerGet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/projects/{}/branding",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha1/projects/{projectId}/branding`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/projects/{projectId}/branding/post(BrandingController-update-1)`.
    public func brandingControllerUpdate1(_ input: Operations.BrandingControllerUpdate1.Input) async throws -> Operations.BrandingControllerUpdate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BrandingControllerUpdate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/projects/{}/branding",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credential by token locator
    ///
    /// Get a single credential by token locator <chain:contract:tokenId>
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/nfts/{locator}/credentials`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/nfts/{locator}/credentials/get(AlphaTokenLocatorController-getCredential-1)`.
    public func alphaTokenLocatorControllerGetCredential1(_ input: Operations.AlphaTokenLocatorControllerGetCredential1.Input) async throws -> Operations.AlphaTokenLocatorControllerGetCredential1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AlphaTokenLocatorControllerGetCredential1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/nfts/{}/credentials",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Token by Locator
    ///
    /// Updates a token's metadata using a Crossmint token locator
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/v1-alpha1/nfts/{locator}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/nfts/{locator}/patch(TokenLocatorController-update-1)`.
    public func tokenLocatorControllerUpdate1(_ input: Operations.TokenLocatorControllerUpdate1.Input) async throws -> Operations.TokenLocatorControllerUpdate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenLocatorControllerUpdate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/nfts/{}",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn Token by locator
    ///
    /// Burn an existing token
    ///
    /// - Remark: HTTP `DELETE /2024-01-01/v1-alpha1/nfts/{locator}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/nfts/{locator}/delete(TokenLocatorController-delete-1)`.
    public func tokenLocatorControllerDelete1(_ input: Operations.TokenLocatorControllerDelete1.Input) async throws -> Operations.TokenLocatorControllerDelete1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenLocatorControllerDelete1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/nfts/{}",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/send/post(MintingAPIV1AlphaController-sendNft-1)`.
    public func mintingAPIV1AlphaControllerSendNft1(_ input: Operations.MintingAPIV1AlphaControllerSendNft1.Input) async throws -> Operations.MintingAPIV1AlphaControllerSendNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerSendNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/minting/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/patch(MintingAPIV1AlphaController-updateNft-1)`.
    public func mintingAPIV1AlphaControllerUpdateNft1(_ input: Operations.MintingAPIV1AlphaControllerUpdateNft1.Input) async throws -> Operations.MintingAPIV1AlphaControllerUpdateNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerUpdateNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /2024-01-01/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/delete(MintingAPIV1AlphaController-deleteNft-1)`.
    public func mintingAPIV1AlphaControllerDeleteNft1(_ input: Operations.MintingAPIV1AlphaControllerDeleteNft1.Input) async throws -> Operations.MintingAPIV1AlphaControllerDeleteNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerDeleteNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/minting/collections/{collectionId}/{featureSlug}/get(MintingAPIV1AlphaController-getFeature-1)`.
    public func mintingAPIV1AlphaControllerGetFeature1(_ input: Operations.MintingAPIV1AlphaControllerGetFeature1.Input) async throws -> Operations.MintingAPIV1AlphaControllerGetFeature1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerGetFeature1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2024-01-01/v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/minting/collections/{collectionId}/{featureSlug}/put(MintingAPIV1AlphaController-updateFeature-1)`.
    public func mintingAPIV1AlphaControllerUpdateFeature1(_ input: Operations.MintingAPIV1AlphaControllerUpdateFeature1.Input) async throws -> Operations.MintingAPIV1AlphaControllerUpdateFeature1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerUpdateFeature1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /2024-01-01/v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/minting/collections/{collectionId}/{featureSlug}/delete(MintingAPIV1AlphaController-disableFeature-1)`.
    public func mintingAPIV1AlphaControllerDisableFeature1(_ input: Operations.MintingAPIV1AlphaControllerDisableFeature1.Input) async throws -> Operations.MintingAPIV1AlphaControllerDisableFeature1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerDisableFeature1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify a Credential
    ///
    /// Verify a Verifiable Credential
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha1/credentials/verification/verify`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/verification/verify/post(CredentialController-verifyCredential-1)`.
    public func credentialControllerVerifyCredential1(_ input: Operations.CredentialControllerVerifyCredential1.Input) async throws -> Operations.CredentialControllerVerifyCredential1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerVerifyCredential1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/verification/verify",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Type
    ///
    /// Get a Verifiable Credential Type by id
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/credentials/types/{typeId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/types/{typeId}/get(CredentialTypesController-getType-1)`.
    public func credentialTypesControllerGetType1(_ input: Operations.CredentialTypesControllerGetType1.Input) async throws -> Operations.CredentialTypesControllerGetType1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerGetType1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/types/{}",
                    parameters: [
                        input.path.typeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Type (Idempotent)
    ///
    /// Create a new type with a given name
    ///
    /// - Remark: HTTP `PUT /2024-01-01/v1-alpha1/credentials/types/{typeId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/types/{typeId}/put(CredentialTypesController-createTypeIdempotent-1)`.
    public func credentialTypesControllerCreateTypeIdempotent1(_ input: Operations.CredentialTypesControllerCreateTypeIdempotent1.Input) async throws -> Operations.CredentialTypesControllerCreateTypeIdempotent1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerCreateTypeIdempotent1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/types/{}",
                    parameters: [
                        input.path.typeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Type
    ///
    /// Create a new type
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha1/credentials/types`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/types/post(CredentialTypesController-createType-1)`.
    public func credentialTypesControllerCreateType1(_ input: Operations.CredentialTypesControllerCreateType1.Input) async throws -> Operations.CredentialTypesControllerCreateType1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerCreateType1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/types",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get lit delegation signature
    ///
    /// Get a delegation signature for lit decryption
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/credentials/decryption/delegateLitCapacity`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/decryption/delegateLitCapacity/get(CredentialController-getSignature-1)`.
    public func credentialControllerGetSignature1(_ input: Operations.CredentialControllerGetSignature1.Input) async throws -> Operations.CredentialControllerGetSignature1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerGetSignature1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/decryption/delegateLitCapacity",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Decrypt a credential given a wallet signature
    ///
    /// Requires an encrypted credential and a signature from the subject's wallet
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha1/credentials/decryption/decrypt`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/decryption/decrypt/post(CredentialController-decryptCredential-1)`.
    public func credentialControllerDecryptCredential1(_ input: Operations.CredentialControllerDecryptCredential1.Input) async throws -> Operations.CredentialControllerDecryptCredential1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerDecryptCredential1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/decryption/decrypt",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a challenge for wallet authentication
    ///
    /// Will return a challenge to sign with a given wallet
    ///
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha1/credentials/auth/wallet`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/auth/wallet/post(CredentialController-walletAuthRequest-1)`.
    public func credentialControllerWalletAuthRequest1(_ input: Operations.CredentialControllerWalletAuthRequest1.Input) async throws -> Operations.CredentialControllerWalletAuthRequest1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerWalletAuthRequest1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/auth/wallet",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credential
    ///
    /// Get a single credential
    ///
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/credentials/{credentialId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/{credentialId}/get(CredentialController-getCredential-1)`.
    public func credentialControllerGetCredential1(_ input: Operations.CredentialControllerGetCredential1.Input) async throws -> Operations.CredentialControllerGetCredential1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerGetCredential1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/{}",
                    parameters: [
                        input.path.credentialId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Revoke credential by id
    ///
    /// Revokes a verifiable credential and burns the associated NFT
    ///
    /// - Remark: HTTP `DELETE /2024-01-01/v1-alpha1/credentials/{credentialId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/credentials/{credentialId}/delete(CredentialController-delete-1)`.
    public func credentialControllerDelete1(_ input: Operations.CredentialControllerDelete1.Input) async throws -> Operations.CredentialControllerDelete1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerDelete1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/credentials/{}",
                    parameters: [
                        input.path.credentialId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/collections/{clientId}/mints`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/collections/{clientId}/mints/get(CollectionMintsController-getMints-1)`.
    public func collectionMintsControllerGetMints1(_ input: Operations.CollectionMintsControllerGetMints1.Input) async throws -> Operations.CollectionMintsControllerGetMints1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionMintsControllerGetMints1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/collections/{}/mints",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    value: input.query.cursor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/collections/{clientId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/collections/{clientId}/get(VerificationStatusController-get-1)`.
    public func verificationStatusControllerGet1(_ input: Operations.VerificationStatusControllerGet1.Input) async throws -> Operations.VerificationStatusControllerGet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.VerificationStatusControllerGet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/collections/{}",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/collections/get(ClientIntegrationController-getCollections-1)`.
    public func clientIntegrationControllerGetCollections1(_ input: Operations.ClientIntegrationControllerGetCollections1.Input) async throws -> Operations.ClientIntegrationControllerGetCollections1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerGetCollections1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hideDrafts",
                    value: input.query.hideDrafts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "topology",
                    value: input.query.topology
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/collections/post(ClientIntegrationController-create-1)`.
    public func clientIntegrationControllerCreate1(_ input: Operations.ClientIntegrationControllerCreate1.Input) async throws -> Operations.ClientIntegrationControllerCreate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerCreate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2024-01-01/v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/v1-alpha1/collections/put(ClientIntegrationController-update-1)`.
    public func clientIntegrationControllerUpdate1(_ input: Operations.ClientIntegrationControllerUpdate1.Input) async throws -> Operations.ClientIntegrationControllerUpdate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerUpdate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Search listings
    ///
    /// - Remark: HTTP `POST /2024-01-01/unstable/ws/search`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/ws/search/post(WorldstoreWrapperController-getListings-1)`.
    public func worldstoreWrapperControllerGetListings1(_ input: Operations.WorldstoreWrapperControllerGetListings1.Input) async throws -> Operations.WorldstoreWrapperControllerGetListings1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerGetListings1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/ws/search",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an order for a listing
    ///
    /// - Remark: HTTP `POST /2024-01-01/unstable/ws/orders`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/ws/orders/post(WorldstoreWrapperController-createOrder-1)`.
    public func worldstoreWrapperControllerCreateOrder1(_ input: Operations.WorldstoreWrapperControllerCreateOrder1.Input) async throws -> Operations.WorldstoreWrapperControllerCreateOrder1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerCreateOrder1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/ws/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order parameters schema for a seller
    ///
    /// - Remark: HTTP `GET /2024-01-01/unstable/ws/orderParameters`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/ws/orderParameters/get(WorldstoreWrapperController-getOrderParametersSchema-1)`.
    public func worldstoreWrapperControllerGetOrderParametersSchema1(_ input: Operations.WorldstoreWrapperControllerGetOrderParametersSchema1.Input) async throws -> Operations.WorldstoreWrapperControllerGetOrderParametersSchema1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerGetOrderParametersSchema1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/ws/orderParameters",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sellerId",
                    value: input.query.sellerId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify wallet ownership
    ///
    /// Verifies wallet ownership by a given email.
    ///
    /// - Remark: HTTP `POST /2024-01-01/unstable/wallets/verify-ownership`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/wallets/verify-ownership/post(WalletsVerifyRecipientController-verifyWalletOwnership-1)`.
    public func walletsVerifyRecipientControllerVerifyWalletOwnership1(_ input: Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership1.Input) async throws -> Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/wallets/verify-ownership",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token For Authenticated User
    ///
    /// Sends a token of any type from the authenticated user's wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2024-01-01/unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenController-sendMeToken-1)`.
    public func walletsSendTokenControllerSendMeToken1(_ input: Operations.WalletsSendTokenControllerSendMeToken1.Input) async throws -> Operations.WalletsSendTokenControllerSendMeToken1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenControllerSendMeToken1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/wallets/me{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletType,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenControllerSendMeToken1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User (Unstable)
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events. This is an unstable API that may change without notice.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/unstable/wallets/me{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/wallets/me{walletLocator}/activity/get(WalletActivityUnstableController-getMeWalletActivity-1)`.
    public func walletActivityUnstableControllerGetMeWalletActivity1(_ input: Operations.WalletActivityUnstableControllerGetMeWalletActivity1.Input) async throws -> Operations.WalletActivityUnstableControllerGetMeWalletActivity1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletActivityUnstableControllerGetMeWalletActivity1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/wallets/me{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetMeWalletActivity1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsActivityResponseUnstableDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetMeWalletActivity1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token
    ///
    /// Sends a token of any type from this wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2024-01-01/unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenController-sendToken-1)`.
    public func walletsSendTokenControllerSendToken1(_ input: Operations.WalletsSendTokenControllerSendToken1.Input) async throws -> Operations.WalletsSendTokenControllerSendToken1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenControllerSendToken1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/wallets/{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenControllerSendToken1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseWithSendParamsDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/unstable/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/wallets/{walletLocator}/balances/get(BalanceUnstableController-getBalanceForLocator-1)`.
    public func balanceUnstableControllerGetBalanceForLocator1(_ input: Operations.BalanceUnstableControllerGetBalanceForLocator1.Input) async throws -> Operations.BalanceUnstableControllerGetBalanceForLocator1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceUnstableControllerGetBalanceForLocator1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceUnstableControllerGetBalanceForLocator1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceUnstableResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceUnstableControllerGetBalanceForLocator1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity (Unstable)
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events. This is an unstable API that may change without notice.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/unstable/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/wallets/{walletLocator}/activity/get(WalletActivityUnstableController-getWalletActivity-1)`.
    public func walletActivityUnstableControllerGetWalletActivity1(_ input: Operations.WalletActivityUnstableControllerGetWalletActivity1.Input) async throws -> Operations.WalletActivityUnstableControllerGetWalletActivity1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletActivityUnstableControllerGetWalletActivity1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetWalletActivity1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsActivityResponseUnstableDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetWalletActivity1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/unstable/wallets/{locator}/{currency}/balance`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/wallets/{locator}/{currency}/balance/get(WalletBalanceController-getBalanceForLocatorAndCurrency-1)`.
    public func walletBalanceControllerGetBalanceForLocatorAndCurrency1(_ input: Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency1.Input) async throws -> Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/wallets/{}/{}/balance",
                    parameters: [
                        input.path.locator,
                        input.path.currency
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/unstable/wallets`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/wallets/get(GetWalletsController-getWallets-1)`.
    public func getWalletsControllerGetWallets1(_ input: Operations.GetWalletsControllerGetWallets1.Input) async throws -> Operations.GetWalletsControllerGetWallets1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetWalletsControllerGetWallets1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "phoneNumber",
                    value: input.query.phoneNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "address",
                    value: input.query.address
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "handle",
                    value: input.query.handle
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/unstable/setupTokenizeCard/registerToken`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/setupTokenizeCard/registerToken/post(TokenizedCardController-registerToken-1)`.
    public func tokenizedCardControllerRegisterToken1(_ input: Operations.TokenizedCardControllerRegisterToken1.Input) async throws -> Operations.TokenizedCardControllerRegisterToken1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerRegisterToken1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/setupTokenizeCard/registerToken",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/unstable/setupTokenizeCard/createPurchaseIntent`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/setupTokenizeCard/createPurchaseIntent/post(TokenizedCardController-createPurchaseIntent-1)`.
    public func tokenizedCardControllerCreatePurchaseIntent1(_ input: Operations.TokenizedCardControllerCreatePurchaseIntent1.Input) async throws -> Operations.TokenizedCardControllerCreatePurchaseIntent1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerCreatePurchaseIntent1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/setupTokenizeCard/createPurchaseIntent",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/unstable/setupTokenizeCard`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/setupTokenizeCard/get(TokenizedCardController-setupTokenizeCard-1)`.
    public func tokenizedCardControllerSetupTokenizeCard1(_ input: Operations.TokenizedCardControllerSetupTokenizeCard1.Input) async throws -> Operations.TokenizedCardControllerSetupTokenizeCard1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerSetupTokenizeCard1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/setupTokenizeCard",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Order Tracking
    ///
    /// Get delivery tracking information for an order
    ///
    /// - Remark: HTTP `GET /2024-01-01/unstable/orders/{orderId}/tracking`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/orders/{orderId}/tracking/get(HeadlessCheckoutUnstableOrdersController-getTracking-1)`.
    public func headlessCheckoutUnstableOrdersControllerGetTracking1(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking1.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/orders/{}/tracking",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get refunds for an order
    ///
    /// Get refunds for an order.
    ///
    /// - Remark: HTTP `GET /2024-01-01/unstable/orders/{orderId}/refunds`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/orders/{orderId}/refunds/get(HeadlessCheckoutUnstableOrdersController-getRefunds-1)`.
    public func headlessCheckoutUnstableOrdersControllerGetRefunds1(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds1.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/orders/{}/refunds",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Refund order
    ///
    /// Refund an order.
    ///
    /// - Remark: HTTP `POST /2024-01-01/unstable/orders/{orderId}/refunds`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/orders/{orderId}/refunds/post(HeadlessCheckoutUnstableOrdersController-refundOrder-1)`.
    public func headlessCheckoutUnstableOrdersControllerRefundOrder1(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder1.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/orders/{}/refunds",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Process payment
    ///
    /// Process payment for an order.
    ///
    /// - Remark: HTTP `POST /2024-01-01/unstable/orders/{orderId}/payment`.
    /// - Remark: Generated from `#/paths//2024-01-01/unstable/orders/{orderId}/payment/post(HeadlessCheckoutUnstableOrdersController-processPayment-1)`.
    public func headlessCheckoutUnstableOrdersControllerProcessPayment1(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment1.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/unstable/orders/{}/payment",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/session/signout`.
    /// - Remark: Generated from `#/paths//2024-01-01/session/signout/post(SessionController-signout-1)`.
    public func sessionControllerSignout1(_ input: Operations.SessionControllerSignout1.Input) async throws -> Operations.SessionControllerSignout1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerSignout1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/session/signout",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/session/exchange-access-token`.
    /// - Remark: Generated from `#/paths//2024-01-01/session/exchange-access-token/post(SessionController-exchangeAccessToken-1)`.
    public func sessionControllerExchangeAccessToken1(_ input: Operations.SessionControllerExchangeAccessToken1.Input) async throws -> Operations.SessionControllerExchangeAccessToken1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerExchangeAccessToken1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/session/exchange-access-token",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/session/authenticate`.
    /// - Remark: Generated from `#/paths//2024-01-01/session/authenticate/get(SessionController-authenticateOAuth-1)`.
    public func sessionControllerAuthenticateOAuth1(_ input: Operations.SessionControllerAuthenticateOAuth1.Input) async throws -> Operations.SessionControllerAuthenticateOAuth1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerAuthenticateOAuth1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/session/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/session/authenticate`.
    /// - Remark: Generated from `#/paths//2024-01-01/session/authenticate/post(SessionController-authenticate-1)`.
    public func sessionControllerAuthenticate1(_ input: Operations.SessionControllerAuthenticate1.Input) async throws -> Operations.SessionControllerAuthenticate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerAuthenticate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/session/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/session`.
    /// - Remark: Generated from `#/paths//2024-01-01/session/get(SessionController-getSession-1)`.
    public func sessionControllerGetSession1(_ input: Operations.SessionControllerGetSession1.Input) async throws -> Operations.SessionControllerGetSession1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerGetSession1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/session",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/sdk/auth/user/get-or-create`.
    /// - Remark: Generated from `#/paths//2024-01-01/sdk/auth/user/get-or-create/post(AuthSdkInternalController-getOrCreateUserOnStytch-1)`.
    public func authSdkInternalControllerGetOrCreateUserOnStytch1(_ input: Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch1.Input) async throws -> Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/sdk/auth/user/get-or-create",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Start the device onboarding process
    ///
    /// - Remark: HTTP `POST /2024-01-01/ncs/v1/signers/start-onboarding`.
    /// - Remark: Generated from `#/paths//2024-01-01/ncs/v1/signers/start-onboarding/post(NCSController-forwardStartOnboarding-3)`.
    public func ncsControllerForwardStartOnboarding3(_ input: Operations.NCSControllerForwardStartOnboarding3.Input) async throws -> Operations.NCSControllerForwardStartOnboarding3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardStartOnboarding3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/ncs/v1/signers/start-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deterministically generate a signer's public key for a specified signing curve
    ///
    /// - Remark: HTTP `POST /2024-01-01/ncs/v1/signers/derive-public-key`.
    /// - Remark: Generated from `#/paths//2024-01-01/ncs/v1/signers/derive-public-key/post(NCSController-forwardPreGeneration-3)`.
    public func ncsControllerForwardPreGeneration3(_ input: Operations.NCSControllerForwardPreGeneration3.Input) async throws -> Operations.NCSControllerForwardPreGeneration3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardPreGeneration3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/ncs/v1/signers/derive-public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Complete the device onboarding process, storing an encrypted master secret, and forwarding it to the device
    ///
    /// - Remark: HTTP `POST /2024-01-01/ncs/v1/signers/complete-onboarding`.
    /// - Remark: Generated from `#/paths//2024-01-01/ncs/v1/signers/complete-onboarding/post(NCSController-forwardCompleteOnboarding-3)`.
    public func ncsControllerForwardCompleteOnboarding3(_ input: Operations.NCSControllerForwardCompleteOnboarding3.Input) async throws -> Operations.NCSControllerForwardCompleteOnboarding3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardCompleteOnboarding3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/ncs/v1/signers/complete-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get everything an NCS device needs to operate, including the encrypted master secret.
    ///
    /// - Remark: HTTP `GET /2024-01-01/ncs/v1/devices/{deviceId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/ncs/v1/devices/{deviceId}/get(NCSController-getDevice-3)`.
    public func ncsControllerGetDevice3(_ input: Operations.NCSControllerGetDevice3.Input) async throws -> Operations.NCSControllerGetDevice3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetDevice3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/ncs/v1/devices/{}",
                    parameters: [
                        input.path.deviceId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the encryption public key for the TEE - for local developement
    ///
    /// - Remark: HTTP `GET /2024-01-01/ncs/v1/attestation/public-key`.
    /// - Remark: Generated from `#/paths//2024-01-01/ncs/v1/attestation/public-key/get(NCSController-getPublicKey-3)`.
    public func ncsControllerGetPublicKey3(_ input: Operations.NCSControllerGetPublicKey3.Input) async throws -> Operations.NCSControllerGetPublicKey3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetPublicKey3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/ncs/v1/attestation/public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the attestation for the TEE
    ///
    /// - Remark: HTTP `GET /2024-01-01/ncs/v1/attestation`.
    /// - Remark: Generated from `#/paths//2024-01-01/ncs/v1/attestation/get(NCSController-getAttestation-3)`.
    public func ncsControllerGetAttestation3(_ input: Operations.NCSControllerGetAttestation3.Input) async throws -> Operations.NCSControllerGetAttestation3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetAttestation3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/ncs/v1/attestation",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/templates/{templateId}/get(TemplatesController-getTemplate-3)`.
    public func templatesControllerGetTemplate3(_ input: Operations.TemplatesControllerGetTemplate3.Input) async throws -> Operations.TemplatesControllerGetTemplate3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerGetTemplate3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PATCH /2024-01-01/minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/templates/{templateId}/patch(TemplatesController-updateTemplate-3)`.
    public func templatesControllerUpdateTemplate3(_ input: Operations.TemplatesControllerUpdateTemplate3.Input) async throws -> Operations.TemplatesControllerUpdateTemplate3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerUpdateTemplate3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2024-01-01/minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/templates/{templateId}/put(TemplatesController-createTemplateIdempotent-3)`.
    public func templatesControllerCreateTemplateIdempotent3(_ input: Operations.TemplatesControllerCreateTemplateIdempotent3.Input) async throws -> Operations.TemplatesControllerCreateTemplateIdempotent3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplateIdempotent3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /2024-01-01/minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/templates/{templateId}/delete(TemplatesController-deleteTemplate-3)`.
    public func templatesControllerDeleteTemplate3(_ input: Operations.TemplatesControllerDeleteTemplate3.Input) async throws -> Operations.TemplatesControllerDeleteTemplate3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerDeleteTemplate3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/minting/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/templates/get(TemplatesController-listTemplates-3)`.
    public func templatesControllerListTemplates3(_ input: Operations.TemplatesControllerListTemplates3.Input) async throws -> Operations.TemplatesControllerListTemplates3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerListTemplates3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/minting/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/templates/post(TemplatesController-createTemplate-3)`.
    public func templatesControllerCreateTemplate3(_ input: Operations.TemplatesControllerCreateTemplate3.Input) async throws -> Operations.TemplatesControllerCreateTemplate3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplate3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create SFT
    ///
    /// Create a new SFT
    ///
    /// - Remark: HTTP `POST /2024-01-01/minting/collections/{collectionId}/sfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/sfts/post(SFTsController-createSft-3)`.
    public func sfTsControllerCreateSft3(_ input: Operations.SFTsControllerCreateSft3.Input) async throws -> Operations.SFTsControllerCreateSft3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SFTsControllerCreateSft3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/sfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "idempotency-key",
                    value: input.headers.idempotencyKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer NFT
    ///
    /// Transfer an existing NFT
    ///
    /// - Remark: HTTP `POST /2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}/send/post(NFTsController-transferNft-3)`.
    public func nfTsControllerTransferNft3(_ input: Operations.NFTsControllerTransferNft3.Input) async throws -> Operations.NFTsControllerTransferNft3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerTransferNft3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFT
    ///
    /// Get a single NFT
    ///
    /// - Remark: HTTP `GET /2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}/get(NFTsController-getNft-3)`.
    public func nfTsControllerGetNft3(_ input: Operations.NFTsControllerGetNft3.Input) async throws -> Operations.NFTsControllerGetNft3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNft3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}/patch(NFTsController-updateNft-3)`.
    public func nfTsControllerUpdateNft3(_ input: Operations.NFTsControllerUpdateNft3.Input) async throws -> Operations.NFTsControllerUpdateNft3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerUpdateNft3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT (Idempotent)
    ///
    /// Create a new NFT with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}/put(NFTsController-createNftIdempotent-3)`.
    public func nfTsControllerCreateNftIdempotent3(_ input: Operations.NFTsControllerCreateNftIdempotent3.Input) async throws -> Operations.NFTsControllerCreateNftIdempotent3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNftIdempotent3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/nfts/{customerFacingId}/delete(NFTsController-deleteNft-3)`.
    public func nfTsControllerDeleteNft3(_ input: Operations.NFTsControllerDeleteNft3.Input) async throws -> Operations.NFTsControllerDeleteNft3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerDeleteNft3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs in a collection
    ///
    /// Get all NFTs in a collection
    ///
    /// - Remark: HTTP `GET /2024-01-01/minting/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/nfts/get(NFTsController-getNfts-3)`.
    public func nfTsControllerGetNfts3(_ input: Operations.NFTsControllerGetNfts3.Input) async throws -> Operations.NFTsControllerGetNfts3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNfts3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT
    ///
    /// Create a new NFT
    ///
    /// - Remark: HTTP `POST /2024-01-01/minting/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/nfts/post(NFTsController-createNft-3)`.
    public func nfTsControllerCreateNft3(_ input: Operations.NFTsControllerCreateNft3.Input) async throws -> Operations.NFTsControllerCreateNft3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNft3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /2024-01-01/minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/get(CollectionsController-getCollection-4)`.
    public func collectionsControllerGetCollection4(_ input: Operations.CollectionsControllerGetCollection4.Input) async throws -> Operations.CollectionsControllerGetCollection4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/patch(CollectionsController-updateCollection-4)`.
    public func collectionsControllerUpdateCollection4(_ input: Operations.CollectionsControllerUpdateCollection4.Input) async throws -> Operations.CollectionsControllerUpdateCollection4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2024-01-01/minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-4)`.
    public func collectionsControllerCreateIdempotentOrGetCollection4(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection4.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /2024-01-01/minting/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/get(CollectionsController-getCollections-4)`.
    public func collectionsControllerGetCollections4(_ input: Operations.CollectionsControllerGetCollections4.Input) async throws -> Operations.CollectionsControllerGetCollections4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /2024-01-01/minting/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/minting/collections/post(CollectionsController-createCollection-4)`.
    public func collectionsControllerCreateCollection4(_ input: Operations.CollectionsControllerCreateCollection4.Input) async throws -> Operations.CollectionsControllerCreateCollection4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/minting/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify the registration response (cred) and return the results to the client
    ///
    /// - Remark: HTTP `POST /2024-01-01/internal/passkeys/register/verify`.
    /// - Remark: Generated from `#/paths//2024-01-01/internal/passkeys/register/verify/post(PasskeysController-verifyRegistration-1)`.
    public func passkeysControllerVerifyRegistration1(_ input: Operations.PasskeysControllerVerifyRegistration1.Input) async throws -> Operations.PasskeysControllerVerifyRegistration1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PasskeysControllerVerifyRegistration1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/internal/passkeys/register/verify",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "origin",
                    value: input.headers.origin
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Generate and return registration options to the client
    ///
    /// The client will use these options to prompt the user to create a passkey
    ///
    /// - Remark: HTTP `POST /2024-01-01/internal/passkeys/register/options`.
    /// - Remark: Generated from `#/paths//2024-01-01/internal/passkeys/register/options/post(PasskeysController-generateRegistrationOptions-1)`.
    public func passkeysControllerGenerateRegistrationOptions1(_ input: Operations.PasskeysControllerGenerateRegistrationOptions1.Input) async throws -> Operations.PasskeysControllerGenerateRegistrationOptions1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PasskeysControllerGenerateRegistrationOptions1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/internal/passkeys/register/options",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "origin",
                    value: input.headers.origin
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/internal/monitoring/outstanding-exports`.
    /// - Remark: Generated from `#/paths//2024-01-01/internal/monitoring/outstanding-exports/get(ExportsController-findOutstandingExports-1)`.
    public func exportsControllerFindOutstandingExports1(_ input: Operations.ExportsControllerFindOutstandingExports1.Input) async throws -> Operations.ExportsControllerFindOutstandingExports1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ExportsControllerFindOutstandingExports1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/internal/monitoring/outstanding-exports",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/export-csv`.
    /// - Remark: Generated from `#/paths//2024-01-01/export-csv/post(ExportCsvController-createExport-1)`.
    public func exportCsvControllerCreateExport1(_ input: Operations.ExportCsvControllerCreateExport1.Input) async throws -> Operations.ExportCsvControllerCreateExport1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ExportCsvControllerCreateExport1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/export-csv",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /2024-01-01/credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/credentials/templates/{collectionId}/get(CollectionsController-getCollection-5)`.
    public func collectionsControllerGetCollection5(_ input: Operations.CollectionsControllerGetCollection5.Input) async throws -> Operations.CollectionsControllerGetCollection5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/credentials/templates/{collectionId}/patch(CollectionsController-updateCollection-5)`.
    public func collectionsControllerUpdateCollection5(_ input: Operations.CollectionsControllerUpdateCollection5.Input) async throws -> Operations.CollectionsControllerUpdateCollection5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2024-01-01/credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/credentials/templates/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-5)`.
    public func collectionsControllerCreateIdempotentOrGetCollection5(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection5.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /2024-01-01/credentials/templates`.
    /// - Remark: Generated from `#/paths//2024-01-01/credentials/templates/get(CollectionsController-getCollections-5)`.
    public func collectionsControllerGetCollections5(_ input: Operations.CollectionsControllerGetCollections5.Input) async throws -> Operations.CollectionsControllerGetCollections5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/credentials/templates",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /2024-01-01/credentials/templates`.
    /// - Remark: Generated from `#/paths//2024-01-01/credentials/templates/post(CollectionsController-createCollection-5)`.
    public func collectionsControllerCreateCollection5(_ input: Operations.CollectionsControllerCreateCollection5.Input) async throws -> Operations.CollectionsControllerCreateCollection5.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection5.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/credentials/templates",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/console/projects/{projectId}/billing/subscriptionCosts`.
    /// - Remark: Generated from `#/paths//2024-01-01/console/projects/{projectId}/billing/subscriptionCosts/get(SubscriptionCostController-getSubscriptionCosts-1)`.
    public func subscriptionCostControllerGetSubscriptionCosts1(_ input: Operations.SubscriptionCostControllerGetSubscriptionCosts1.Input) async throws -> Operations.SubscriptionCostControllerGetSubscriptionCosts1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SubscriptionCostControllerGetSubscriptionCosts1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/console/projects/{}/billing/subscriptionCosts",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/console/project/{projectId}/privacy-policy`.
    /// - Remark: Generated from `#/paths//2024-01-01/console/project/{projectId}/privacy-policy/get(PrivacyPolicyController-getByProjectId-1)`.
    public func privacyPolicyControllerGetByProjectId1(_ input: Operations.PrivacyPolicyControllerGetByProjectId1.Input) async throws -> Operations.PrivacyPolicyControllerGetByProjectId1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PrivacyPolicyControllerGetByProjectId1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/console/project/{}/privacy-policy",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/console/project/{projectId}/privacy-policy`.
    /// - Remark: Generated from `#/paths//2024-01-01/console/project/{projectId}/privacy-policy/post(PrivacyPolicyController-create-1)`.
    public func privacyPolicyControllerCreate1(_ input: Operations.PrivacyPolicyControllerCreate1.Input) async throws -> Operations.PrivacyPolicyControllerCreate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PrivacyPolicyControllerCreate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/console/project/{}/privacy-policy",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/console/contact-sales/upgrade-plan-submission`.
    /// - Remark: Generated from `#/paths//2024-01-01/console/contact-sales/upgrade-plan-submission/post(UpgradePlanSubmissionController-sendEmailToSales-1)`.
    public func upgradePlanSubmissionControllerSendEmailToSales1(_ input: Operations.UpgradePlanSubmissionControllerSendEmailToSales1.Input) async throws -> Operations.UpgradePlanSubmissionControllerSendEmailToSales1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UpgradePlanSubmissionControllerSendEmailToSales1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/console/contact-sales/upgrade-plan-submission",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/console/contact-sales/new-referral`.
    /// - Remark: Generated from `#/paths//2024-01-01/console/contact-sales/new-referral/post(NewReferralRegisteredController-sendEmailToSales-1)`.
    public func newReferralRegisteredControllerSendEmailToSales1(_ input: Operations.NewReferralRegisteredControllerSendEmailToSales1.Input) async throws -> Operations.NewReferralRegisteredControllerSendEmailToSales1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NewReferralRegisteredControllerSendEmailToSales1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/console/contact-sales/new-referral",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update an individual quickstart
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/console/admin/quickstarts/{id}`.
    /// - Remark: Generated from `#/paths//2024-01-01/console/admin/quickstarts/{id}/patch(QuickstartController-updateQuickstart-1)`.
    public func quickstartControllerUpdateQuickstart1(_ input: Operations.QuickstartControllerUpdateQuickstart1.Input) async throws -> Operations.QuickstartControllerUpdateQuickstart1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerUpdateQuickstart1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/console/admin/quickstarts/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete a quickstart
    ///
    /// - Remark: HTTP `DELETE /2024-01-01/console/admin/quickstarts/{id}`.
    /// - Remark: Generated from `#/paths//2024-01-01/console/admin/quickstarts/{id}/delete(QuickstartController-deleteQuickstart-1)`.
    public func quickstartControllerDeleteQuickstart1(_ input: Operations.QuickstartControllerDeleteQuickstart1.Input) async throws -> Operations.QuickstartControllerDeleteQuickstart1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerDeleteQuickstart1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/console/admin/quickstarts/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a new quickstart
    ///
    /// - Remark: HTTP `POST /2024-01-01/console/admin/quickstarts`.
    /// - Remark: Generated from `#/paths//2024-01-01/console/admin/quickstarts/post(QuickstartController-createQuickstart-1)`.
    public func quickstartControllerCreateQuickstart1(_ input: Operations.QuickstartControllerCreateQuickstart1.Input) async throws -> Operations.QuickstartControllerCreateQuickstart1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerCreateQuickstart1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/console/admin/quickstarts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                case 400:
                    return .badRequest(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/templates/{templateId}/get(TemplatesController-getTemplate-2)`.
    public func templatesControllerGetTemplate2(_ input: Operations.TemplatesControllerGetTemplate2.Input) async throws -> Operations.TemplatesControllerGetTemplate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerGetTemplate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PATCH /2024-01-01/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/templates/{templateId}/patch(TemplatesController-updateTemplate-2)`.
    public func templatesControllerUpdateTemplate2(_ input: Operations.TemplatesControllerUpdateTemplate2.Input) async throws -> Operations.TemplatesControllerUpdateTemplate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerUpdateTemplate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2024-01-01/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/templates/{templateId}/put(TemplatesController-createTemplateIdempotent-2)`.
    public func templatesControllerCreateTemplateIdempotent2(_ input: Operations.TemplatesControllerCreateTemplateIdempotent2.Input) async throws -> Operations.TemplatesControllerCreateTemplateIdempotent2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplateIdempotent2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /2024-01-01/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/templates/{templateId}/delete(TemplatesController-deleteTemplate-2)`.
    public func templatesControllerDeleteTemplate2(_ input: Operations.TemplatesControllerDeleteTemplate2.Input) async throws -> Operations.TemplatesControllerDeleteTemplate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerDeleteTemplate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/templates/get(TemplatesController-listTemplates-2)`.
    public func templatesControllerListTemplates2(_ input: Operations.TemplatesControllerListTemplates2.Input) async throws -> Operations.TemplatesControllerListTemplates2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerListTemplates2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/templates/post(TemplatesController-createTemplate-2)`.
    public func templatesControllerCreateTemplate2(_ input: Operations.TemplatesControllerCreateTemplate2.Input) async throws -> Operations.TemplatesControllerCreateTemplate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create SFT
    ///
    /// Create a new SFT
    ///
    /// - Remark: HTTP `POST /2024-01-01/collections/{collectionId}/sfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/sfts/post(SFTsController-createSft-2)`.
    public func sfTsControllerCreateSft2(_ input: Operations.SFTsControllerCreateSft2.Input) async throws -> Operations.SFTsControllerCreateSft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SFTsControllerCreateSft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/sfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "idempotency-key",
                    value: input.headers.idempotencyKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer NFT
    ///
    /// Transfer an existing NFT
    ///
    /// - Remark: HTTP `POST /2024-01-01/collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/nfts/{customerFacingId}/send/post(NFTsController-transferNft-2)`.
    public func nfTsControllerTransferNft2(_ input: Operations.NFTsControllerTransferNft2.Input) async throws -> Operations.NFTsControllerTransferNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerTransferNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFT
    ///
    /// Get a single NFT
    ///
    /// - Remark: HTTP `GET /2024-01-01/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/nfts/{customerFacingId}/get(NFTsController-getNft-2)`.
    public func nfTsControllerGetNft2(_ input: Operations.NFTsControllerGetNft2.Input) async throws -> Operations.NFTsControllerGetNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/nfts/{customerFacingId}/patch(NFTsController-updateNft-2)`.
    public func nfTsControllerUpdateNft2(_ input: Operations.NFTsControllerUpdateNft2.Input) async throws -> Operations.NFTsControllerUpdateNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerUpdateNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT (Idempotent)
    ///
    /// Create a new NFT with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2024-01-01/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/nfts/{customerFacingId}/put(NFTsController-createNftIdempotent-2)`.
    public func nfTsControllerCreateNftIdempotent2(_ input: Operations.NFTsControllerCreateNftIdempotent2.Input) async throws -> Operations.NFTsControllerCreateNftIdempotent2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNftIdempotent2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /2024-01-01/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/nfts/{customerFacingId}/delete(NFTsController-deleteNft-2)`.
    public func nfTsControllerDeleteNft2(_ input: Operations.NFTsControllerDeleteNft2.Input) async throws -> Operations.NFTsControllerDeleteNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerDeleteNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs in a collection
    ///
    /// Get all NFTs in a collection
    ///
    /// - Remark: HTTP `GET /2024-01-01/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/nfts/get(NFTsController-getNfts-2)`.
    public func nfTsControllerGetNfts2(_ input: Operations.NFTsControllerGetNfts2.Input) async throws -> Operations.NFTsControllerGetNfts2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNfts2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT
    ///
    /// Create a new NFT
    ///
    /// - Remark: HTTP `POST /2024-01-01/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/nfts/post(NFTsController-createNft-2)`.
    public func nfTsControllerCreateNft2(_ input: Operations.NFTsControllerCreateNft2.Input) async throws -> Operations.NFTsControllerCreateNft2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNft2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /2024-01-01/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/get(CollectionsController-getCollection-3)`.
    public func collectionsControllerGetCollection3(_ input: Operations.CollectionsControllerGetCollection3.Input) async throws -> Operations.CollectionsControllerGetCollection3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/patch(CollectionsController-updateCollection-3)`.
    public func collectionsControllerUpdateCollection3(_ input: Operations.CollectionsControllerUpdateCollection3.Input) async throws -> Operations.CollectionsControllerUpdateCollection3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2024-01-01/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-3)`.
    public func collectionsControllerCreateIdempotentOrGetCollection3(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection3.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/collections/{clientId}/orders/stats`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{clientId}/orders/stats/get(CollectionOrdersController-getStatus-1)`.
    public func collectionOrdersControllerGetStatus1(_ input: Operations.CollectionOrdersControllerGetStatus1.Input) async throws -> Operations.CollectionOrdersControllerGetStatus1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetStatus1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/orders/stats",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/collections/{clientId}/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{clientId}/orders/{orderId}/get(CollectionOrdersController-getOrder-1)`.
    public func collectionOrdersControllerGetOrder1(_ input: Operations.CollectionOrdersControllerGetOrder1.Input) async throws -> Operations.CollectionOrdersControllerGetOrder1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetOrder1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/orders/{}",
                    parameters: [
                        input.path.clientId,
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/collections/{clientId}/orders`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/{clientId}/orders/get(CollectionOrdersController-getOrders-1)`.
    public func collectionOrdersControllerGetOrders1(_ input: Operations.CollectionOrdersControllerGetOrders1.Input) async throws -> Operations.CollectionOrdersControllerGetOrders1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetOrders1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections/{}/orders",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recipient",
                    value: input.query.recipient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderId",
                    value: input.query.orderId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentMethod",
                    value: input.query.paymentMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentStatus",
                    value: input.query.paymentStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "deliveryStatus",
                    value: input.query.deliveryStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeSummary",
                    value: input.query.includeSummary
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "search",
                    value: input.query.search
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "identifier",
                    value: input.query.identifier
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /2024-01-01/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/get(CollectionsController-getCollections-3)`.
    public func collectionsControllerGetCollections3(_ input: Operations.CollectionsControllerGetCollections3.Input) async throws -> Operations.CollectionsControllerGetCollections3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /2024-01-01/collections`.
    /// - Remark: Generated from `#/paths//2024-01-01/collections/post(CollectionsController-createCollection-3)`.
    public func collectionsControllerCreateCollection3(_ input: Operations.CollectionsControllerCreateCollection3.Input) async throws -> Operations.CollectionsControllerCreateCollection3.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection3.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/address-autocomplete/suggestions`.
    /// - Remark: Generated from `#/paths//2024-01-01/address-autocomplete/suggestions/get(AddressAutocompleteController-getSuggestions-1)`.
    public func addressAutocompleteControllerGetSuggestions1(_ input: Operations.AddressAutocompleteControllerGetSuggestions1.Input) async throws -> Operations.AddressAutocompleteControllerGetSuggestions1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AddressAutocompleteControllerGetSuggestions1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/address-autocomplete/suggestions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "query",
                    value: input.query.query
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/address-autocomplete/details`.
    /// - Remark: Generated from `#/paths//2024-01-01/address-autocomplete/details/get(AddressAutocompleteController-getAddressDetails-1)`.
    public func addressAutocompleteControllerGetAddressDetails1(_ input: Operations.AddressAutocompleteControllerGetAddressDetails1.Input) async throws -> Operations.AddressAutocompleteControllerGetAddressDetails1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AddressAutocompleteControllerGetAddressDetails1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/address-autocomplete/details",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "placeId",
                    value: input.query.placeId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/actions/sendEmail/order-confirmation-email/send`.
    /// - Remark: Generated from `#/paths//2024-01-01/actions/sendEmail/order-confirmation-email/send/get(EmailContentVerificationController-verify-1)`.
    public func emailContentVerificationControllerVerify1(_ input: Operations.EmailContentVerificationControllerVerify1.Input) async throws -> Operations.EmailContentVerificationControllerVerify1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.EmailContentVerificationControllerVerify1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/actions/sendEmail/order-confirmation-email/send",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderIdentifier",
                    value: input.query.orderIdentifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "templateIdentifier",
                    value: input.query.templateIdentifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/actions/mintAPI/dequeue`.
    /// - Remark: Generated from `#/paths//2024-01-01/actions/mintAPI/dequeue/get(DequeueController-dequeueGet-1)`.
    public func dequeueControllerDequeueGet1(_ input: Operations.DequeueControllerDequeueGet1.Input) async throws -> Operations.DequeueControllerDequeueGet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DequeueControllerDequeueGet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/actions/mintAPI/dequeue",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/actions/mintAPI/dequeue`.
    /// - Remark: Generated from `#/paths//2024-01-01/actions/mintAPI/dequeue/post(DequeueController-dequeuePost-1)`.
    public func dequeueControllerDequeuePost1(_ input: Operations.DequeueControllerDequeuePost1.Input) async throws -> Operations.DequeueControllerDequeuePost1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DequeueControllerDequeuePost1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/actions/mintAPI/dequeue",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/actions/{actionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/actions/{actionId}/get(ActionsController-getAction-1)`.
    public func actionsControllerGetAction1(_ input: Operations.ActionsControllerGetAction1.Input) async throws -> Operations.ActionsControllerGetAction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ActionsControllerGetAction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/actions/{}",
                    parameters: [
                        input.path.actionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Orders by Project
    ///
    /// Get all orders for a specific project with filtering and pagination support
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-15/orders`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-15/orders/get(ProjectOrdersController-getProjectOrders-1)`.
    public func projectOrdersControllerGetProjectOrders1(_ input: Operations.ProjectOrdersControllerGetProjectOrders1.Input) async throws -> Operations.ProjectOrdersControllerGetProjectOrders1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectOrdersControllerGetProjectOrders1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-15/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortBy",
                    value: input.query.sortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortOrder",
                    value: input.query.sortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "projectId",
                    value: input.query.projectId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentMethod",
                    value: input.query.paymentMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentStatus",
                    value: input.query.paymentStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "deliveryStatus",
                    value: input.query.deliveryStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "collectionId",
                    value: input.query.collectionId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "createdAfter",
                    value: input.query.createdAfter
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "createdBefore",
                    value: input.query.createdBefore
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeSummary",
                    value: input.query.includeSummary
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "identifier",
                    value: input.query.identifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recipient",
                    value: input.query.recipient
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV2025Controller-submitMeApprovals-1)`.
    public func walletsV2025ControllerSubmitMeApprovals1(_ input: Operations.WalletsV2025ControllerSubmitMeApprovals1.Input) async throws -> Operations.WalletsV2025ControllerSubmitMeApprovals1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitMeApprovals1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals1.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals1.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/get(WalletsV2025Controller-getMeTransaction-1)`.
    public func walletsV2025ControllerGetMeTransaction1(_ input: Operations.WalletsV2025ControllerGetMeTransaction1.Input) async throws -> Operations.WalletsV2025ControllerGetMeTransaction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeTransaction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransaction1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransaction1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/me{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/transactions/get(WalletsV2025Controller-getMeTransactionsWithoutChain-1)`.
    public func walletsV2025ControllerGetMeTransactionsWithoutChain1(_ input: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain1.Input) async throws -> Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/me{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/transactions/post(WalletsV2025Controller-createMeTransaction-1)`.
    public func walletsV2025ControllerCreateMeTransaction1(_ input: Operations.WalletsV2025ControllerCreateMeTransaction1.Input) async throws -> Operations.WalletsV2025ControllerCreateMeTransaction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeTransaction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction1.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token For Authenticated User
    ///
    /// Sends a token of any type from the authenticated user's wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenV2025Controller-sendMeToken-1)`.
    public func walletsSendTokenV2025ControllerSendMeToken1(_ input: Operations.WalletsSendTokenV2025ControllerSendMeToken1.Input) async throws -> Operations.WalletsSendTokenV2025ControllerSendMeToken1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenV2025ControllerSendMeToken1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenV2025ControllerSendMeToken1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/me{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/signers/{signer}/get(WalletsV2025Controller-getMeDelegatedSigner-1)`.
    public func walletsV2025ControllerGetMeDelegatedSigner1(_ input: Operations.WalletsV2025ControllerGetMeDelegatedSigner1.Input) async throws -> Operations.WalletsV2025ControllerGetMeDelegatedSigner1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeDelegatedSigner1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeDelegatedSigner1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeDelegatedSigner1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/me{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/signers/post(WalletsV2025Controller-createMeDelegatedSigner-1)`.
    public func walletsV2025ControllerCreateMeDelegatedSigner1(_ input: Operations.WalletsV2025ControllerCreateMeDelegatedSigner1.Input) async throws -> Operations.WalletsV2025ControllerCreateMeDelegatedSigner1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeDelegatedSigner1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV2025Controller-submitMeSignatureApprovals-1)`.
    public func walletsV2025ControllerSubmitMeSignatureApprovals1(_ input: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals1.Input) async throws -> Operations.WalletsV2025ControllerSubmitMeSignatureApprovals1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/get(WalletsV2025Controller-getMeSignature-1)`.
    public func walletsV2025ControllerGetMeSignature1(_ input: Operations.WalletsV2025ControllerGetMeSignature1.Input) async throws -> Operations.WalletsV2025ControllerGetMeSignature1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeSignature1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignature1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignature1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Signatures For Authenticated User
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/me{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/signatures/get(WalletsV2025Controller-getMeSignatures-1)`.
    public func walletsV2025ControllerGetMeSignatures1(_ input: Operations.WalletsV2025ControllerGetMeSignatures1.Input) async throws -> Operations.WalletsV2025ControllerGetMeSignatures1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeSignatures1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignatures1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignatures1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/me{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/signatures/post(WalletsV2025Controller-createMeSignatureRequest-1)`.
    public func walletsV2025ControllerCreateMeSignatureRequest1(_ input: Operations.WalletsV2025ControllerCreateMeSignatureRequest1.Input) async throws -> Operations.WalletsV2025ControllerCreateMeSignatureRequest1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeSignatureRequest1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/me{walletLocator}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me{walletLocator}/get(WalletsV2025Controller-getMeWallet-1)`.
    public func walletsV2025ControllerGetMeWallet1(_ input: Operations.WalletsV2025ControllerGetMeWallet1.Input) async throws -> Operations.WalletsV2025ControllerGetMeWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeWallet1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/me`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/me/post(WalletsV2025Controller-createMeWallet-1)`.
    public func walletsV2025ControllerCreateMeWallet1(_ input: Operations.WalletsV2025ControllerCreateMeWallet1.Input) async throws -> Operations.WalletsV2025ControllerCreateMeWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeWallet1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV2025Controller-submitApprovals-1)`.
    public func walletsV2025ControllerSubmitApprovals1(_ input: Operations.WalletsV2025ControllerSubmitApprovals1.Input) async throws -> Operations.WalletsV2025ControllerSubmitApprovals1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitApprovals1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals1.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals1.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV2025Controller-getTransaction-1)`.
    public func walletsV2025ControllerGetTransaction1(_ input: Operations.WalletsV2025ControllerGetTransaction1.Input) async throws -> Operations.WalletsV2025ControllerGetTransaction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetTransaction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransaction1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransaction1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/transactions/get(WalletsV2025Controller-getTransactionsWithoutChain-1)`.
    public func walletsV2025ControllerGetTransactionsWithoutChain1(_ input: Operations.WalletsV2025ControllerGetTransactionsWithoutChain1.Input) async throws -> Operations.WalletsV2025ControllerGetTransactionsWithoutChain1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetTransactionsWithoutChain1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransactionsWithoutChain1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransactionsWithoutChain1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/transactions/post(WalletsV2025Controller-createTransaction-1)`.
    public func walletsV2025ControllerCreateTransaction1(_ input: Operations.WalletsV2025ControllerCreateTransaction1.Input) async throws -> Operations.WalletsV2025ControllerCreateTransaction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateTransaction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction1.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token
    ///
    /// Sends a token of any type from this wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenV2025Controller-sendToken-1)`.
    public func walletsSendTokenV2025ControllerSendToken1(_ input: Operations.WalletsSendTokenV2025ControllerSendToken1.Input) async throws -> Operations.WalletsSendTokenV2025ControllerSendToken1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenV2025ControllerSendToken1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenV2025ControllerSendToken1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/signers/{signer}/get(WalletsV2025Controller-getDelegatedSigner-1)`.
    public func walletsV2025ControllerGetDelegatedSigner1(_ input: Operations.WalletsV2025ControllerGetDelegatedSigner1.Input) async throws -> Operations.WalletsV2025ControllerGetDelegatedSigner1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetDelegatedSigner1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetDelegatedSigner1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetDelegatedSigner1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Delegated Signer
    ///
    /// Create a delegated signer for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/signers/post(WalletsV2025Controller-createDelegatedSigner-1)`.
    public func walletsV2025ControllerCreateDelegatedSigner1(_ input: Operations.WalletsV2025ControllerCreateDelegatedSigner1.Input) async throws -> Operations.WalletsV2025ControllerCreateDelegatedSigner1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateDelegatedSigner1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV2025Controller-submitSignatureApprovals-1)`.
    public func walletsV2025ControllerSubmitSignatureApprovals1(_ input: Operations.WalletsV2025ControllerSubmitSignatureApprovals1.Input) async throws -> Operations.WalletsV2025ControllerSubmitSignatureApprovals1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitSignatureApprovals1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV2025Controller-getSignature-1)`.
    public func walletsV2025ControllerGetSignature1(_ input: Operations.WalletsV2025ControllerGetSignature1.Input) async throws -> Operations.WalletsV2025ControllerGetSignature1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetSignature1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetSignature1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetSignature1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/signatures/get(WalletsV2025Controller-getAllSignatures-1)`.
    public func walletsV2025ControllerGetAllSignatures1(_ input: Operations.WalletsV2025ControllerGetAllSignatures1.Input) async throws -> Operations.WalletsV2025ControllerGetAllSignatures1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetAllSignatures1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetAllSignatures1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetAllSignatures1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/signatures/post(WalletsV2025Controller-createSignatureRequest-1)`.
    public func walletsV2025ControllerCreateSignatureRequest1(_ input: Operations.WalletsV2025ControllerCreateSignatureRequest1.Input) async throws -> Operations.WalletsV2025ControllerCreateSignatureRequest1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateSignatureRequest1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/balances/get(BalanceV20250609Controller-getBalanceForLocator-1)`.
    public func balanceV20250609ControllerGetBalanceForLocator1(_ input: Operations.BalanceV20250609ControllerGetBalanceForLocator1.Input) async throws -> Operations.BalanceV20250609ControllerGetBalanceForLocator1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceV20250609ControllerGetBalanceForLocator1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceV20250609ControllerGetBalanceForLocator1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceV20250609ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceV20250609ControllerGetBalanceForLocator1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2025-06-09/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/{walletLocator}/get(WalletsV2025Controller-getWalletByLocator-1)`.
    public func walletsV2025ControllerGetWalletByLocator1(_ input: Operations.WalletsV2025ControllerGetWalletByLocator1.Input) async throws -> Operations.WalletsV2025ControllerGetWalletByLocator1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetWalletByLocator1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetWalletByLocator1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetWalletByLocator1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When owner is provided, subsequent calls with the same owner will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2025-06-09/wallets`.
    /// - Remark: Generated from `#/paths//2024-01-01/2025-06-09/wallets/post(WalletsV2025Controller-createWallet-1)`.
    public func walletsV2025ControllerCreateWallet1(_ input: Operations.WalletsV2025ControllerCreateWallet1.Input) async throws -> Operations.WalletsV2025ControllerCreateWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2025-06-09/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateWallet1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateWallet1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/2024-09-26/session/sdk/auth/social/{provider}/start`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/session/sdk/auth/social/{provider}/start/get(AuthSdkSessionController-getOauthUrl-1)`.
    public func authSdkSessionControllerGetOauthUrl1(_ input: Operations.AuthSdkSessionControllerGetOauthUrl1.Input) async throws -> Operations.AuthSdkSessionControllerGetOauthUrl1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerGetOauthUrl1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/session/sdk/auth/social/{}/start",
                    parameters: [
                        input.path.provider
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "appSchema",
                    value: input.query.appSchema
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-api-key",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-app-identifier",
                    value: input.headers.xAppIdentifier
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/2024-09-26/session/sdk/auth/refresh`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/session/sdk/auth/refresh/post(AuthSdkSessionController-refresh-1)`.
    public func authSdkSessionControllerRefresh1(_ input: Operations.AuthSdkSessionControllerRefresh1.Input) async throws -> Operations.AuthSdkSessionControllerRefresh1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerRefresh1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/session/sdk/auth/refresh",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/2024-09-26/session/sdk/auth/otps/send`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/session/sdk/auth/otps/send/post(AuthSdkSessionController-initiateEmailAuthentication-1)`.
    public func authSdkSessionControllerInitiateEmailAuthentication1(_ input: Operations.AuthSdkSessionControllerInitiateEmailAuthentication1.Input) async throws -> Operations.AuthSdkSessionControllerInitiateEmailAuthentication1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerInitiateEmailAuthentication1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/session/sdk/auth/otps/send",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/2024-09-26/session/sdk/auth/logout`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/session/sdk/auth/logout/post(AuthSdkSessionController-logout-1)`.
    public func authSdkSessionControllerLogout1(_ input: Operations.AuthSdkSessionControllerLogout1.Input) async throws -> Operations.AuthSdkSessionControllerLogout1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerLogout1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/session/sdk/auth/logout",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start/post(AuthSdkSessionController-startCryptoWalletAuthentication-1)`.
    public func authSdkSessionControllerStartCryptoWalletAuthentication1(_ input: Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication1.Input) async throws -> Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/2024-09-26/session/sdk/auth/crypto_wallets/authenticate`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/post(AuthSdkSessionController-authenticateCryptoWallet-1)`.
    public func authSdkSessionControllerAuthenticateCryptoWallet1(_ input: Operations.AuthSdkSessionControllerAuthenticateCryptoWallet1.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateCryptoWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateCryptoWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/session/sdk/auth/crypto_wallets/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/2024-09-26/session/sdk/auth/authenticate`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/session/sdk/auth/authenticate/get(AuthSdkSessionController-authenticateOAuthAuthSDK-1)`.
    public func authSdkSessionControllerAuthenticateOAuthAuthSDK1(_ input: Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK1.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/session/sdk/auth/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/2024-09-26/session/sdk/auth/authenticate`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/session/sdk/auth/authenticate/post(AuthSdkSessionController-authenticateAuthSDK-1)`.
    public func authSdkSessionControllerAuthenticateAuthSDK1(_ input: Operations.AuthSdkSessionControllerAuthenticateAuthSDK1.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateAuthSDK1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateAuthSDK1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/session/sdk/auth/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/2024-09-26/sdk/auth/user/{externalUserId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/sdk/auth/user/{externalUserId}/get(AuthSdkController-getUserServerSide-1)`.
    public func authSdkControllerGetUserServerSide1(_ input: Operations.AuthSdkControllerGetUserServerSide1.Input) async throws -> Operations.AuthSdkControllerGetUserServerSide1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkControllerGetUserServerSide1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/sdk/auth/user/{}",
                    parameters: [
                        input.path.externalUserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/2024-09-26/sdk/auth/user`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-09-26/sdk/auth/user/get(AuthSdkController-getUserClientSide-1)`.
    public func authSdkControllerGetUserClientSide1(_ input: Operations.AuthSdkControllerGetUserClientSide1.Input) async throws -> Operations.AuthSdkControllerGetUserClientSide1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkControllerGetUserClientSide1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-09-26/sdk/auth/user",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2024-01-01/2024-06-09/sdk/smart-wallet/config`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-06-09/sdk/smart-wallet/config/get(SmartWalletSDKController-getConfig-1)`.
    public func smartWalletSDKControllerGetConfig1(_ input: Operations.SmartWalletSDKControllerGetConfig1.Input) async throws -> Operations.SmartWalletSDKControllerGetConfig1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SmartWalletSDKControllerGetConfig1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-06-09/sdk/smart-wallet/config",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2024-01-01/2024-06-09/sdk/smart-wallet`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-06-09/sdk/smart-wallet/put(SmartWalletSDKController-save-1)`.
    public func smartWalletSDKControllerSave1(_ input: Operations.SmartWalletSDKControllerSave1.Input) async throws -> Operations.SmartWalletSDKControllerSave1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SmartWalletSDKControllerSave1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-06-09/sdk/smart-wallet",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/2024-06-09/sdk/paymaster`.
    /// - Remark: Generated from `#/paths//2024-01-01/2024-06-09/sdk/paymaster/post(PaymasterProxyController-sponsorUserOp-1)`.
    public func paymasterProxyControllerSponsorUserOp1(_ input: Operations.PaymasterProxyControllerSponsorUserOp1.Input) async throws -> Operations.PaymasterProxyControllerSponsorUserOp1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PaymasterProxyControllerSponsorUserOp1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2024-06-09/sdk/paymaster",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitMeApprovals-2)`.
    public func walletsV1ControllerSubmitMeApprovals2(_ input: Operations.WalletsV1ControllerSubmitMeApprovals2.Input) async throws -> Operations.WalletsV1ControllerSubmitMeApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals2.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/me{walletType}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/transactions/{transactionId}/get(WalletsV1Controller-getMeTransaction-2)`.
    public func walletsV1ControllerGetMeTransaction2(_ input: Operations.WalletsV1ControllerGetMeTransaction2.Input) async throws -> Operations.WalletsV1ControllerGetMeTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/transactions/get(WalletsV1Controller-getMeTransactionsWithoutChain-2)`.
    public func walletsV1ControllerGetMeTransactionsWithoutChain2(_ input: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain2.Input) async throws -> Operations.WalletsV1ControllerGetMeTransactionsWithoutChain2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/transactions/post(WalletsV1Controller-createMeTransaction-2)`.
    public func walletsV1ControllerCreateMeTransaction2(_ input: Operations.WalletsV1ControllerCreateMeTransaction2.Input) async throws -> Operations.WalletsV1ControllerCreateMeTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/me{walletType}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/signers/{signer}/get(WalletsV1Controller-getMeDelegatedSigner-2)`.
    public func walletsV1ControllerGetMeDelegatedSigner2(_ input: Operations.WalletsV1ControllerGetMeDelegatedSigner2.Input) async throws -> Operations.WalletsV1ControllerGetMeDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/me{walletType}/signers`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/signers/post(WalletsV1Controller-createMeDelegatedSigner-2)`.
    public func walletsV1ControllerCreateMeDelegatedSigner2(_ input: Operations.WalletsV1ControllerCreateMeDelegatedSigner2.Input) async throws -> Operations.WalletsV1ControllerCreateMeDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/signers",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitMeSignatureApprovals-2)`.
    public func walletsV1ControllerSubmitMeSignatureApprovals2(_ input: Operations.WalletsV1ControllerSubmitMeSignatureApprovals2.Input) async throws -> Operations.WalletsV1ControllerSubmitMeSignatureApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeSignatureApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/me{walletType}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/signatures/{signatureId}/get(WalletsV1Controller-getMeSignature-2)`.
    public func walletsV1ControllerGetMeSignature2(_ input: Operations.WalletsV1ControllerGetMeSignature2.Input) async throws -> Operations.WalletsV1ControllerGetMeSignature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeSignature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/me{walletType}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/signatures/post(WalletsV1Controller-createMeSignatureRequest-2)`.
    public func walletsV1ControllerCreateMeSignatureRequest2(_ input: Operations.WalletsV1ControllerCreateMeSignatureRequest2.Input) async throws -> Operations.WalletsV1ControllerCreateMeSignatureRequest2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeSignatureRequest2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/me{walletType}/activity`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/activity/get(WalletsV1Controller-getMeWalletActivity-2)`.
    public func walletsV1ControllerGetMeWalletActivity2(_ input: Operations.WalletsV1ControllerGetMeWalletActivity2.Input) async throws -> Operations.WalletsV1ControllerGetMeWalletActivity2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWalletActivity2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}/activity",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/me{walletType}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me{walletType}/get(WalletsV1Controller-getMeWallet-2)`.
    public func walletsV1ControllerGetMeWallet2(_ input: Operations.WalletsV1ControllerGetMeWallet2.Input) async throws -> Operations.WalletsV1ControllerGetMeWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me{}",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWallet2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/me`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/me/post(WalletsV1Controller-createMeWallet-2)`.
    public func walletsV1ControllerCreateMeWallet2(_ input: Operations.WalletsV1ControllerCreateMeWallet2.Input) async throws -> Operations.WalletsV1ControllerCreateMeWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeWallet2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitApprovals-2)`.
    public func walletsV1ControllerSubmitApprovals2(_ input: Operations.WalletsV1ControllerSubmitApprovals2.Input) async throws -> Operations.WalletsV1ControllerSubmitApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals2.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV1Controller-getTransaction-2)`.
    public func walletsV1ControllerGetTransaction2(_ input: Operations.WalletsV1ControllerGetTransaction2.Input) async throws -> Operations.WalletsV1ControllerGetTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/transactions/get(WalletsV1Controller-getTransactionsWithoutChain-2)`.
    public func walletsV1ControllerGetTransactionsWithoutChain2(_ input: Operations.WalletsV1ControllerGetTransactionsWithoutChain2.Input) async throws -> Operations.WalletsV1ControllerGetTransactionsWithoutChain2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransactionsWithoutChain2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/transactions/post(WalletsV1Controller-createTransaction-2)`.
    public func walletsV1ControllerCreateTransaction2(_ input: Operations.WalletsV1ControllerCreateTransaction2.Input) async throws -> Operations.WalletsV1ControllerCreateTransaction2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateTransaction2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction2.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/signers/{signer}/get(WalletsV1Controller-getDelegatedSigner-2)`.
    public func walletsV1ControllerGetDelegatedSigner2(_ input: Operations.WalletsV1ControllerGetDelegatedSigner2.Input) async throws -> Operations.WalletsV1ControllerGetDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/signers/post(WalletsV1Controller-createDelegatedSigner-2)`.
    public func walletsV1ControllerCreateDelegatedSigner2(_ input: Operations.WalletsV1ControllerCreateDelegatedSigner2.Input) async throws -> Operations.WalletsV1ControllerCreateDelegatedSigner2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateDelegatedSigner2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitSignatureApprovals-2)`.
    public func walletsV1ControllerSubmitSignatureApprovals2(_ input: Operations.WalletsV1ControllerSubmitSignatureApprovals2.Input) async throws -> Operations.WalletsV1ControllerSubmitSignatureApprovals2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitSignatureApprovals2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV1Controller-getSignature-2)`.
    public func walletsV1ControllerGetSignature2(_ input: Operations.WalletsV1ControllerGetSignature2.Input) async throws -> Operations.WalletsV1ControllerGetSignature2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetSignature2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/signatures/get(WalletsV1Controller-getAllSignatures-2)`.
    public func walletsV1ControllerGetAllSignatures2(_ input: Operations.WalletsV1ControllerGetAllSignatures2.Input) async throws -> Operations.WalletsV1ControllerGetAllSignatures2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetAllSignatures2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2MultipleSignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/signatures/post(WalletsV1Controller-createSignatureRequest-2)`.
    public func walletsV1ControllerCreateSignatureRequest2(_ input: Operations.WalletsV1ControllerCreateSignatureRequest2.Input) async throws -> Operations.WalletsV1ControllerCreateSignatureRequest2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateSignatureRequest2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/activity/get(WalletsV1Controller-getWalletActivity-2)`.
    public func walletsV1ControllerGetWalletActivity2(_ input: Operations.WalletsV1ControllerGetWalletActivity2.Input) async throws -> Operations.WalletsV1ControllerGetWalletActivity2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletActivity2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{walletLocator}/get(WalletsV1Controller-getWalletByLocator-2)`.
    public func walletsV1ControllerGetWalletByLocator2(_ input: Operations.WalletsV1ControllerGetWalletByLocator2.Input) async throws -> Operations.WalletsV1ControllerGetWalletByLocator2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletByLocator2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator2.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs from Wallet
    ///
    /// Retrieves NFTs from a wallet.
    ///
    /// **API scope required**: `wallets:nfts.read`
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/wallets/{locator}/nfts`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/{locator}/nfts/get(WalletNFTController-getNFTsFromWallet-2)`.
    public func walletNFTControllerGetNFTsFromWallet2(_ input: Operations.WalletNFTControllerGetNFTsFromWallet2.Input) async throws -> Operations.WalletNFTControllerGetNFTsFromWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletNFTControllerGetNFTsFromWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets/{}/nfts",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "contractAddress",
                    value: input.query.contractAddress
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokenId",
                    value: input.query.tokenId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletNFTControllerGetNFTsFromWallet2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNFTsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When linkedUser is provided, subsequent calls with the same linkedUser will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/wallets`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/wallets/post(WalletsV1Controller-createWallet-2)`.
    public func walletsV1ControllerCreateWallet2(_ input: Operations.WalletsV1ControllerCreateWallet2.Input) async throws -> Operations.WalletsV1ControllerCreateWallet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateWallet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet2.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet2.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Subscription
    ///
    /// Retrieve information about an existing subscription, including expiry time, payment information and recurrency status.
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/subscriptions/{subscriptionId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/subscriptions/{subscriptionId}/get(SubscriptionsController-getSubscription-1)`.
    public func subscriptionsControllerGetSubscription1(_ input: Operations.SubscriptionsControllerGetSubscription1.Input) async throws -> Operations.SubscriptionsControllerGetSubscription1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SubscriptionsControllerGetSubscription1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/subscriptions/{}",
                    parameters: [
                        input.path.subscriptionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SubscriptionsControllerGetSubscription1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SubscriptionDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Refresh Order
    ///
    /// Refreshes the quote and availability for a given order.
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/orders/{orderId}/refresh`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/orders/{orderId}/refresh/post(HeadlessCheckoutOrdersController-refreshOrder-1)`.
    public func headlessCheckoutOrdersControllerRefreshOrder1(_ input: Operations.HeadlessCheckoutOrdersControllerRefreshOrder1.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerRefreshOrder1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerRefreshOrder1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/orders/{}/refresh",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerRefreshOrder1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Process payment
    ///
    /// Process payment for an order.
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/orders/{orderId}/payment`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/orders/{orderId}/payment/post(HeadlessCheckoutOrdersController-processPayment-1)`.
    public func headlessCheckoutOrdersControllerProcessPayment1(_ input: Operations.HeadlessCheckoutOrdersControllerProcessPayment1.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerProcessPayment1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerProcessPayment1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/orders/{}/payment",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/orders/{orderId}/3ds/sessions/{sessionId}/authenticate`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/orders/{orderId}/3ds/sessions/{sessionId}/authenticate/post(HeadlessCheckout3DSSController-authenticate-1)`.
    public func headlessCheckout3DSSControllerAuthenticate1(_ input: Operations.HeadlessCheckout3DSSControllerAuthenticate1.Input) async throws -> Operations.HeadlessCheckout3DSSControllerAuthenticate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckout3DSSControllerAuthenticate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/orders/{}/3ds/sessions/{}/authenticate",
                    parameters: [
                        input.path.orderId,
                        input.path.sessionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Order
    ///
    /// Get specific order by ID
    ///
    /// - Remark: HTTP `GET /2024-01-01/2022-06-09/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/orders/{orderId}/get(HeadlessCheckoutOrdersController-get-1)`.
    public func headlessCheckoutOrdersControllerGet1(_ input: Operations.HeadlessCheckoutOrdersControllerGet1.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerGet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerGet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/orders/{}",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerGet1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Order
    ///
    /// Update an existing order. You can update the recipient, the payment method and the locale.
    ///
    /// - Remark: HTTP `PATCH /2024-01-01/2022-06-09/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/orders/{orderId}/patch(HeadlessCheckoutOrdersController-update-1)`.
    public func headlessCheckoutOrdersControllerUpdate1(_ input: Operations.HeadlessCheckoutOrdersControllerUpdate1.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerUpdate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerUpdate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/orders/{}",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerUpdate1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Order
    ///
    /// Create a new order
    ///
    /// - Remark: HTTP `POST /2024-01-01/2022-06-09/orders`.
    /// - Remark: Generated from `#/paths//2024-01-01/2022-06-09/orders/post(HeadlessCheckoutOrdersController-create-1)`.
    public func headlessCheckoutOrdersControllerCreate1(_ input: Operations.HeadlessCheckoutOrdersControllerCreate1.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerCreate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerCreate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2024-01-01/2022-06-09/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerCreate1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/worldstore/protocol-alpha/webhooks/rye`.
    /// - Remark: Generated from `#/paths//2022-06-09/worldstore/protocol-alpha/webhooks/rye/post(WorldstoreAlphaOrderWebhooksController-ryeWebhook-0)`.
    public func worldstoreAlphaOrderWebhooksControllerRyeWebhook0(_ input: Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook0.Input) async throws -> Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaOrderWebhooksControllerRyeWebhook0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/worldstore/protocol-alpha/webhooks/rye",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order tracking information
    ///
    /// - Remark: HTTP `GET /2022-06-09/worldstore/protocol-alpha/store/amazon/orders/{orderHash}/tracking`.
    /// - Remark: Generated from `#/paths//2022-06-09/worldstore/protocol-alpha/store/amazon/orders/{orderHash}/tracking/get(WorldstoreAlphaController-getOrderTracking-0)`.
    public func worldstoreAlphaControllerGetOrderTracking0(_ input: Operations.WorldstoreAlphaControllerGetOrderTracking0.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrderTracking0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrderTracking0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/worldstore/protocol-alpha/store/amazon/orders/{}/tracking",
                    parameters: [
                        input.path.orderHash
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Webhook for Worldstore Alpha
    ///
    /// - Remark: HTTP `POST /2022-06-09/worldstore/protocol-alpha/store/{store}/webhook`.
    /// - Remark: Generated from `#/paths//2022-06-09/worldstore/protocol-alpha/store/{store}/webhook/post(WorldstoreAlphaController-webhook-0)`.
    public func worldstoreAlphaControllerWebhook0(_ input: Operations.WorldstoreAlphaControllerWebhook0.Input) async throws -> Operations.WorldstoreAlphaControllerWebhook0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerWebhook0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/worldstore/protocol-alpha/store/{}/webhook",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an order for a listing
    ///
    /// - Remark: HTTP `POST /2022-06-09/worldstore/protocol-alpha/store/{store}/orders`.
    /// - Remark: Generated from `#/paths//2022-06-09/worldstore/protocol-alpha/store/{store}/orders/post(WorldstoreAlphaController-getOrder-0)`.
    public func worldstoreAlphaControllerGetOrder0(_ input: Operations.WorldstoreAlphaControllerGetOrder0.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrder0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrder0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/worldstore/protocol-alpha/store/{}/orders",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order parameters schema for a store
    ///
    /// - Remark: HTTP `GET /2022-06-09/worldstore/protocol-alpha/store/{store}/orderParameters`.
    /// - Remark: Generated from `#/paths//2022-06-09/worldstore/protocol-alpha/store/{store}/orderParameters/get(WorldstoreAlphaController-getOrderParametersSchema-0)`.
    public func worldstoreAlphaControllerGetOrderParametersSchema0(_ input: Operations.WorldstoreAlphaControllerGetOrderParametersSchema0.Input) async throws -> Operations.WorldstoreAlphaControllerGetOrderParametersSchema0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetOrderParametersSchema0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/worldstore/protocol-alpha/store/{}/orderParameters",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get metadata for a store
    ///
    /// - Remark: HTTP `GET /2022-06-09/worldstore/protocol-alpha/store/{store}/metadata`.
    /// - Remark: Generated from `#/paths//2022-06-09/worldstore/protocol-alpha/store/{store}/metadata/get(WorldstoreAlphaController-getMetadata-0)`.
    public func worldstoreAlphaControllerGetMetadata0(_ input: Operations.WorldstoreAlphaControllerGetMetadata0.Input) async throws -> Operations.WorldstoreAlphaControllerGetMetadata0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetMetadata0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/worldstore/protocol-alpha/store/{}/metadata",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get listings for a product
    ///
    /// - Remark: HTTP `GET /2022-06-09/worldstore/protocol-alpha/store/{store}/listings`.
    /// - Remark: Generated from `#/paths//2022-06-09/worldstore/protocol-alpha/store/{store}/listings/get(WorldstoreAlphaController-getListings-0)`.
    public func worldstoreAlphaControllerGetListings0(_ input: Operations.WorldstoreAlphaControllerGetListings0.Input) async throws -> Operations.WorldstoreAlphaControllerGetListings0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreAlphaControllerGetListings0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/worldstore/protocol-alpha/store/{}/listings",
                    parameters: [
                        input.path.store
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "uid",
                    value: input.query.uid
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/webhooks/internal/lead-scanner`.
    /// - Remark: Generated from `#/paths//2022-06-09/webhooks/internal/lead-scanner/post(LeadScannerController-scan-0)`.
    public func leadScannerControllerScan0(_ input: Operations.LeadScannerControllerScan0.Input) async throws -> Operations.LeadScannerControllerScan0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.LeadScannerControllerScan0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/webhooks/internal/lead-scanner",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitMeApprovals-4)`.
    public func walletsV1ControllerSubmitMeApprovals4(_ input: Operations.WalletsV1ControllerSubmitMeApprovals4.Input) async throws -> Operations.WalletsV1ControllerSubmitMeApprovals4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeApprovals4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals4.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/transactions/{transactionId}/get(WalletsV1Controller-getMeTransaction-4)`.
    public func walletsV1ControllerGetMeTransaction4(_ input: Operations.WalletsV1ControllerGetMeTransaction4.Input) async throws -> Operations.WalletsV1ControllerGetMeTransaction4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransaction4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/transactions/get(WalletsV1Controller-getMeTransactionsWithoutChain-4)`.
    public func walletsV1ControllerGetMeTransactionsWithoutChain4(_ input: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.Input) async throws -> Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/transactions/post(WalletsV1Controller-createMeTransaction-4)`.
    public func walletsV1ControllerCreateMeTransaction4(_ input: Operations.WalletsV1ControllerCreateMeTransaction4.Input) async throws -> Operations.WalletsV1ControllerCreateMeTransaction4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeTransaction4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction4.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signers/{signer}/get(WalletsV1Controller-getMeDelegatedSigner-4)`.
    public func walletsV1ControllerGetMeDelegatedSigner4(_ input: Operations.WalletsV1ControllerGetMeDelegatedSigner4.Input) async throws -> Operations.WalletsV1ControllerGetMeDelegatedSigner4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeDelegatedSigner4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signers/post(WalletsV1Controller-createMeDelegatedSigner-4)`.
    public func walletsV1ControllerCreateMeDelegatedSigner4(_ input: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Input) async throws -> Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signers",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitMeSignatureApprovals-4)`.
    public func walletsV1ControllerSubmitMeSignatureApprovals4(_ input: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Input) async throws -> Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signatures/{signatureId}/get(WalletsV1Controller-getMeSignature-4)`.
    public func walletsV1ControllerGetMeSignature4(_ input: Operations.WalletsV1ControllerGetMeSignature4.Input) async throws -> Operations.WalletsV1ControllerGetMeSignature4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeSignature4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me{walletType}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/signatures/post(WalletsV1Controller-createMeSignatureRequest-4)`.
    public func walletsV1ControllerCreateMeSignatureRequest4(_ input: Operations.WalletsV1ControllerCreateMeSignatureRequest4.Input) async throws -> Operations.WalletsV1ControllerCreateMeSignatureRequest4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeSignatureRequest4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/activity/get(WalletsV1Controller-getMeWalletActivity-4)`.
    public func walletsV1ControllerGetMeWalletActivity4(_ input: Operations.WalletsV1ControllerGetMeWalletActivity4.Input) async throws -> Operations.WalletsV1ControllerGetMeWalletActivity4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWalletActivity4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}/activity",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/me{walletType}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me{walletType}/get(WalletsV1Controller-getMeWallet-4)`.
    public func walletsV1ControllerGetMeWallet4(_ input: Operations.WalletsV1ControllerGetMeWallet4.Input) async throws -> Operations.WalletsV1ControllerGetMeWallet4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWallet4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me{}",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWallet4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/me`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/me/post(WalletsV1Controller-createMeWallet-4)`.
    public func walletsV1ControllerCreateMeWallet4(_ input: Operations.WalletsV1ControllerCreateMeWallet4.Input) async throws -> Operations.WalletsV1ControllerCreateMeWallet4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeWallet4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeWallet4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitApprovals-4)`.
    public func walletsV1ControllerSubmitApprovals4(_ input: Operations.WalletsV1ControllerSubmitApprovals4.Input) async throws -> Operations.WalletsV1ControllerSubmitApprovals4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitApprovals4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals4.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV1Controller-getTransaction-4)`.
    public func walletsV1ControllerGetTransaction4(_ input: Operations.WalletsV1ControllerGetTransaction4.Input) async throws -> Operations.WalletsV1ControllerGetTransaction4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransaction4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/transactions/get(WalletsV1Controller-getTransactionsWithoutChain-4)`.
    public func walletsV1ControllerGetTransactionsWithoutChain4(_ input: Operations.WalletsV1ControllerGetTransactionsWithoutChain4.Input) async throws -> Operations.WalletsV1ControllerGetTransactionsWithoutChain4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransactionsWithoutChain4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/transactions/post(WalletsV1Controller-createTransaction-4)`.
    public func walletsV1ControllerCreateTransaction4(_ input: Operations.WalletsV1ControllerCreateTransaction4.Input) async throws -> Operations.WalletsV1ControllerCreateTransaction4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateTransaction4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction4.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signers/{signer}/get(WalletsV1Controller-getDelegatedSigner-4)`.
    public func walletsV1ControllerGetDelegatedSigner4(_ input: Operations.WalletsV1ControllerGetDelegatedSigner4.Input) async throws -> Operations.WalletsV1ControllerGetDelegatedSigner4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetDelegatedSigner4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signers/post(WalletsV1Controller-createDelegatedSigner-4)`.
    public func walletsV1ControllerCreateDelegatedSigner4(_ input: Operations.WalletsV1ControllerCreateDelegatedSigner4.Input) async throws -> Operations.WalletsV1ControllerCreateDelegatedSigner4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateDelegatedSigner4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitSignatureApprovals-4)`.
    public func walletsV1ControllerSubmitSignatureApprovals4(_ input: Operations.WalletsV1ControllerSubmitSignatureApprovals4.Input) async throws -> Operations.WalletsV1ControllerSubmitSignatureApprovals4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitSignatureApprovals4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV1Controller-getSignature-4)`.
    public func walletsV1ControllerGetSignature4(_ input: Operations.WalletsV1ControllerGetSignature4.Input) async throws -> Operations.WalletsV1ControllerGetSignature4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetSignature4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signatures/get(WalletsV1Controller-getAllSignatures-4)`.
    public func walletsV1ControllerGetAllSignatures4(_ input: Operations.WalletsV1ControllerGetAllSignatures4.Input) async throws -> Operations.WalletsV1ControllerGetAllSignatures4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetAllSignatures4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2MultipleSignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/signatures/post(WalletsV1Controller-createSignatureRequest-4)`.
    public func walletsV1ControllerCreateSignatureRequest4(_ input: Operations.WalletsV1ControllerCreateSignatureRequest4.Input) async throws -> Operations.WalletsV1ControllerCreateSignatureRequest4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateSignatureRequest4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/activity/get(WalletsV1Controller-getWalletActivity-4)`.
    public func walletsV1ControllerGetWalletActivity4(_ input: Operations.WalletsV1ControllerGetWalletActivity4.Input) async throws -> Operations.WalletsV1ControllerGetWalletActivity4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletActivity4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{walletLocator}/get(WalletsV1Controller-getWalletByLocator-4)`.
    public func walletsV1ControllerGetWalletByLocator4(_ input: Operations.WalletsV1ControllerGetWalletByLocator4.Input) async throws -> Operations.WalletsV1ControllerGetWalletByLocator4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletByLocator4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator4.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs from Wallet
    ///
    /// Retrieves NFTs from a wallet.
    ///
    /// **API scope required**: `wallets:nfts.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/wallets/{locator}/nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/{locator}/nfts/get(WalletNFTController-getNFTsFromWallet-4)`.
    public func walletNFTControllerGetNFTsFromWallet4(_ input: Operations.WalletNFTControllerGetNFTsFromWallet4.Input) async throws -> Operations.WalletNFTControllerGetNFTsFromWallet4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletNFTControllerGetNFTsFromWallet4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets/{}/nfts",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "contractAddress",
                    value: input.query.contractAddress
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokenId",
                    value: input.query.tokenId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletNFTControllerGetNFTsFromWallet4.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNFTsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When linkedUser is provided, subsequent calls with the same linkedUser will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/wallets`.
    /// - Remark: Generated from `#/paths//2022-06-09/wallets/post(WalletsV1Controller-createWallet-4)`.
    public func walletsV1ControllerCreateWallet4(_ input: Operations.WalletsV1ControllerCreateWallet4.Input) async throws -> Operations.WalletsV1ControllerCreateWallet4.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateWallet4.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet4.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet4.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Start the device onboarding process
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1/signers/start-onboarding`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/signers/start-onboarding/post(NCSController-forwardStartOnboarding-0)`.
    public func ncsControllerForwardStartOnboarding0(_ input: Operations.NCSControllerForwardStartOnboarding0.Input) async throws -> Operations.NCSControllerForwardStartOnboarding0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardStartOnboarding0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/signers/start-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deterministically generate a signer's public key for a specified signing curve
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1/signers/derive-public-key`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/signers/derive-public-key/post(NCSController-forwardPreGeneration-0)`.
    public func ncsControllerForwardPreGeneration0(_ input: Operations.NCSControllerForwardPreGeneration0.Input) async throws -> Operations.NCSControllerForwardPreGeneration0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardPreGeneration0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/signers/derive-public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Complete the device onboarding process, storing an encrypted master secret, and forwarding it to the device
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1/signers/complete-onboarding`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/signers/complete-onboarding/post(NCSController-forwardCompleteOnboarding-0)`.
    public func ncsControllerForwardCompleteOnboarding0(_ input: Operations.NCSControllerForwardCompleteOnboarding0.Input) async throws -> Operations.NCSControllerForwardCompleteOnboarding0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardCompleteOnboarding0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/signers/complete-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset Licenses
    ///
    /// Get the licenses of an IP Asset
    ///
    /// The ipassetId parameter should be the Story Protocol asset ID (not the Crossmint ID). Must start with '0x' followed by hexadecimal characters.
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/ip/licenses/{ipassetId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/licenses/{ipassetId}/get(StoryApiController-getIpaLicenses-0)`.
    public func storyApiControllerGetIpaLicenses0(_ input: Operations.StoryApiControllerGetIpaLicenses0.Input) async throws -> Operations.StoryApiControllerGetIpaLicenses0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetIpaLicenses0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/licenses/{}",
                    parameters: [
                        input.path.ipassetId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetIpaLicenses0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset Graph
    ///
    /// Get the graph of an IP Asset, by default it will fetch the first level of parents and children (depth = 1). You can customize the depth using the query parameter 'depth' to a maximum of 3. Maximum 100 parents or children will be returned for each level.
    ///
    /// The ipAssetId parameter should be the Story Protocol asset ID (not the Crossmint ID). Must start with '0x' followed by hexadecimal characters.
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/ip/graph/{ipAssetId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/graph/{ipAssetId}/get(StoryApiController-getIpaGraph-0)`.
    public func storyApiControllerGetIpaGraph0(_ input: Operations.StoryApiControllerGetIpaGraph0.Input) async throws -> Operations.StoryApiControllerGetIpaGraph0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetIpaGraph0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/graph/{}",
                    parameters: [
                        input.path.ipAssetId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "depth",
                    value: input.query.depth
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetIpaGraph0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetGraphDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Asset
    ///
    /// Get a single IP Asset
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/get(StoryApiController-getNft-0)`.
    public func storyApiControllerGetNft0(_ input: Operations.StoryApiControllerGetNft0.Input) async throws -> Operations.StoryApiControllerGetNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetNft0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update IP Asset
    ///
    /// Update an existing IP Asset
    ///
    /// **API scope required**: `nfts.update`
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/patch(StoryApiController-updateNft-0)`.
    public func storyApiControllerUpdateNft0(_ input: Operations.StoryApiControllerUpdateNft0.Input) async throws -> Operations.StoryApiControllerUpdateNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerUpdateNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerUpdateNft0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetUpdateResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create IP Asset (Idempotent)
    ///
    /// Create a new IP Asset with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `PUT /2022-06-09/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/{collectionId}/ipassets/{customerFacingId}/put(StoryApiController-createIPAssetIdempotent-0)`.
    public func storyApiControllerCreateIPAssetIdempotent0(_ input: Operations.StoryApiControllerCreateIPAssetIdempotent0.Input) async throws -> Operations.StoryApiControllerCreateIPAssetIdempotent0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIPAssetIdempotent0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections/{}/ipassets/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIPAssetIdempotent0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get IP Assets in a collection
    ///
    /// Get all IP Assets in a collection
    ///
    /// **API scope required**: `nfts.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/ip/collections/{collectionId}/ipassets`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/{collectionId}/ipassets/get(StoryApiController-getNfts-0)`.
    public func storyApiControllerGetNfts0(_ input: Operations.StoryApiControllerGetNfts0.Input) async throws -> Operations.StoryApiControllerGetNfts0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetNfts0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections/{}/ipassets",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetNfts0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultipleIPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create IP Asset
    ///
    /// Create a new IP Asset
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1/ip/collections/{collectionId}/ipassets`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/{collectionId}/ipassets/post(StoryApiController-createIPAsset-0)`.
    public func storyApiControllerCreateIPAsset0(_ input: Operations.StoryApiControllerCreateIPAsset0.Input) async throws -> Operations.StoryApiControllerCreateIPAsset0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIPAsset0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections/{}/ipassets",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIPAsset0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.IPAssetResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a Collection
    ///
    /// Get a collection by its id deployed on the Story chain
    ///
    /// **API scope required**: `collections.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/ip/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/{collectionId}/get(StoryApiController-getCollection-0)`.
    public func storyApiControllerGetCollection0(_ input: Operations.StoryApiControllerGetCollection0.Input) async throws -> Operations.StoryApiControllerGetCollection0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetCollection0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetCollection0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `collections.create`
    ///
    /// - Remark: HTTP `PUT /2022-06-09/v1/ip/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/{collectionId}/put(StoryApiController-createIdempotent-0)`.
    public func storyApiControllerCreateIdempotent0(_ input: Operations.StoryApiControllerCreateIdempotent0.Input) async throws -> Operations.StoryApiControllerCreateIdempotent0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreateIdempotent0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreateIdempotent0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Collections
    ///
    /// Get all collections associated with the Developer Project
    ///
    /// **API scope required**: `collections.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/ip/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/get(StoryApiController-getCollections-0)`.
    public func storyApiControllerGetCollections0(_ input: Operations.StoryApiControllerGetCollections0.Input) async throws -> Operations.StoryApiControllerGetCollections0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetCollections0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetCollections0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MultipleCollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// **API scope required**: `collections.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1/ip/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/collections/post(StoryApiController-create-0)`.
    public func storyApiControllerCreate0(_ input: Operations.StoryApiControllerCreate0.Input) async throws -> Operations.StoryApiControllerCreate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerCreate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerCreate0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CollectionResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Action
    ///
    /// Get an action by its id
    ///
    /// **API scope required**: `nfts.create`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/ip/actions/{actionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/ip/actions/{actionId}/get(StoryApiController-getAction-0)`.
    public func storyApiControllerGetAction0(_ input: Operations.StoryApiControllerGetAction0.Input) async throws -> Operations.StoryApiControllerGetAction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.StoryApiControllerGetAction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/ip/actions/{}",
                    parameters: [
                        input.path.actionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.StoryApiControllerGetAction0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.StoryActionsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get everything an NCS device needs to operate, including the encrypted master secret.
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/devices/{deviceId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/devices/{deviceId}/get(NCSController-getDevice-0)`.
    public func ncsControllerGetDevice0(_ input: Operations.NCSControllerGetDevice0.Input) async throws -> Operations.NCSControllerGetDevice0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetDevice0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/devices/{}",
                    parameters: [
                        input.path.deviceId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the encryption public key for the TEE - for local developement
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/attestation/public-key`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/attestation/public-key/get(NCSController-getPublicKey-0)`.
    public func ncsControllerGetPublicKey0(_ input: Operations.NCSControllerGetPublicKey0.Input) async throws -> Operations.NCSControllerGetPublicKey0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetPublicKey0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/attestation/public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the attestation for the TEE
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1/attestation`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1/attestation/get(NCSController-getAttestation-0)`.
    public func ncsControllerGetAttestation0(_ input: Operations.NCSControllerGetAttestation0.Input) async throws -> Operations.NCSControllerGetAttestation0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetAttestation0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1/attestation",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitMeApprovals-1)`.
    public func walletsV1ControllerSubmitMeApprovals1(_ input: Operations.WalletsV1ControllerSubmitMeApprovals1.Input) async throws -> Operations.WalletsV1ControllerSubmitMeApprovals1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeApprovals1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals1.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals1.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/transactions/{transactionId}/get(WalletsV1Controller-getMeTransaction-1)`.
    public func walletsV1ControllerGetMeTransaction1(_ input: Operations.WalletsV1ControllerGetMeTransaction1.Input) async throws -> Operations.WalletsV1ControllerGetMeTransaction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransaction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/transactions/get(WalletsV1Controller-getMeTransactionsWithoutChain-1)`.
    public func walletsV1ControllerGetMeTransactionsWithoutChain1(_ input: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain1.Input) async throws -> Operations.WalletsV1ControllerGetMeTransactionsWithoutChain1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/transactions/post(WalletsV1Controller-createMeTransaction-1)`.
    public func walletsV1ControllerCreateMeTransaction1(_ input: Operations.WalletsV1ControllerCreateMeTransaction1.Input) async throws -> Operations.WalletsV1ControllerCreateMeTransaction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeTransaction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction1.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/me{walletType}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/signers/{signer}/get(WalletsV1Controller-getMeDelegatedSigner-1)`.
    public func walletsV1ControllerGetMeDelegatedSigner1(_ input: Operations.WalletsV1ControllerGetMeDelegatedSigner1.Input) async throws -> Operations.WalletsV1ControllerGetMeDelegatedSigner1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeDelegatedSigner1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/me{walletType}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/signers/post(WalletsV1Controller-createMeDelegatedSigner-1)`.
    public func walletsV1ControllerCreateMeDelegatedSigner1(_ input: Operations.WalletsV1ControllerCreateMeDelegatedSigner1.Input) async throws -> Operations.WalletsV1ControllerCreateMeDelegatedSigner1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeDelegatedSigner1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/signers",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitMeSignatureApprovals-1)`.
    public func walletsV1ControllerSubmitMeSignatureApprovals1(_ input: Operations.WalletsV1ControllerSubmitMeSignatureApprovals1.Input) async throws -> Operations.WalletsV1ControllerSubmitMeSignatureApprovals1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeSignatureApprovals1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/signatures/{signatureId}/get(WalletsV1Controller-getMeSignature-1)`.
    public func walletsV1ControllerGetMeSignature1(_ input: Operations.WalletsV1ControllerGetMeSignature1.Input) async throws -> Operations.WalletsV1ControllerGetMeSignature1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeSignature1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/me{walletType}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/signatures/post(WalletsV1Controller-createMeSignatureRequest-1)`.
    public func walletsV1ControllerCreateMeSignatureRequest1(_ input: Operations.WalletsV1ControllerCreateMeSignatureRequest1.Input) async throws -> Operations.WalletsV1ControllerCreateMeSignatureRequest1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeSignatureRequest1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/me{walletType}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/activity/get(WalletsV1Controller-getMeWalletActivity-1)`.
    public func walletsV1ControllerGetMeWalletActivity1(_ input: Operations.WalletsV1ControllerGetMeWalletActivity1.Input) async throws -> Operations.WalletsV1ControllerGetMeWalletActivity1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWalletActivity1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}/activity",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/me{walletType}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me{walletType}/get(WalletsV1Controller-getMeWallet-1)`.
    public func walletsV1ControllerGetMeWallet1(_ input: Operations.WalletsV1ControllerGetMeWallet1.Input) async throws -> Operations.WalletsV1ControllerGetMeWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me{}",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWallet1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/me`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/me/post(WalletsV1Controller-createMeWallet-1)`.
    public func walletsV1ControllerCreateMeWallet1(_ input: Operations.WalletsV1ControllerCreateMeWallet1.Input) async throws -> Operations.WalletsV1ControllerCreateMeWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeWallet1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitApprovals-1)`.
    public func walletsV1ControllerSubmitApprovals1(_ input: Operations.WalletsV1ControllerSubmitApprovals1.Input) async throws -> Operations.WalletsV1ControllerSubmitApprovals1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitApprovals1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals1.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals1.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV1Controller-getTransaction-1)`.
    public func walletsV1ControllerGetTransaction1(_ input: Operations.WalletsV1ControllerGetTransaction1.Input) async throws -> Operations.WalletsV1ControllerGetTransaction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransaction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/transactions/get(WalletsV1Controller-getTransactionsWithoutChain-1)`.
    public func walletsV1ControllerGetTransactionsWithoutChain1(_ input: Operations.WalletsV1ControllerGetTransactionsWithoutChain1.Input) async throws -> Operations.WalletsV1ControllerGetTransactionsWithoutChain1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransactionsWithoutChain1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/transactions/post(WalletsV1Controller-createTransaction-1)`.
    public func walletsV1ControllerCreateTransaction1(_ input: Operations.WalletsV1ControllerCreateTransaction1.Input) async throws -> Operations.WalletsV1ControllerCreateTransaction1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateTransaction1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction1.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/signers/{signer}/get(WalletsV1Controller-getDelegatedSigner-1)`.
    public func walletsV1ControllerGetDelegatedSigner1(_ input: Operations.WalletsV1ControllerGetDelegatedSigner1.Input) async throws -> Operations.WalletsV1ControllerGetDelegatedSigner1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetDelegatedSigner1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/signers/post(WalletsV1Controller-createDelegatedSigner-1)`.
    public func walletsV1ControllerCreateDelegatedSigner1(_ input: Operations.WalletsV1ControllerCreateDelegatedSigner1.Input) async throws -> Operations.WalletsV1ControllerCreateDelegatedSigner1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateDelegatedSigner1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitSignatureApprovals-1)`.
    public func walletsV1ControllerSubmitSignatureApprovals1(_ input: Operations.WalletsV1ControllerSubmitSignatureApprovals1.Input) async throws -> Operations.WalletsV1ControllerSubmitSignatureApprovals1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitSignatureApprovals1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV1Controller-getSignature-1)`.
    public func walletsV1ControllerGetSignature1(_ input: Operations.WalletsV1ControllerGetSignature1.Input) async throws -> Operations.WalletsV1ControllerGetSignature1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetSignature1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/signatures/get(WalletsV1Controller-getAllSignatures-1)`.
    public func walletsV1ControllerGetAllSignatures1(_ input: Operations.WalletsV1ControllerGetAllSignatures1.Input) async throws -> Operations.WalletsV1ControllerGetAllSignatures1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetAllSignatures1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2MultipleSignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/signatures/post(WalletsV1Controller-createSignatureRequest-1)`.
    public func walletsV1ControllerCreateSignatureRequest1(_ input: Operations.WalletsV1ControllerCreateSignatureRequest1.Input) async throws -> Operations.WalletsV1ControllerCreateSignatureRequest1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateSignatureRequest1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/balances/get(BalanceController-getBalanceForLocator-0)`.
    public func balanceControllerGetBalanceForLocator0(_ input: Operations.BalanceControllerGetBalanceForLocator0.Input) async throws -> Operations.BalanceControllerGetBalanceForLocator0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceControllerGetBalanceForLocator0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerGetBalanceForLocator0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerGetBalanceForLocator0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Fund Wallet
    ///
    /// Send funds to a wallet.
    ///
    /// **API scope required**: `wallets.fund`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/balances/post(BalanceController-fundWallet-0)`.
    public func balanceControllerFundWallet0(_ input: Operations.BalanceControllerFundWallet0.Input) async throws -> Operations.BalanceControllerFundWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceControllerFundWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerFundWallet0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceControllerFundWallet0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/activity/get(WalletsV1Controller-getWalletActivity-1)`.
    public func walletsV1ControllerGetWalletActivity1(_ input: Operations.WalletsV1ControllerGetWalletActivity1.Input) async throws -> Operations.WalletsV1ControllerGetWalletActivity1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletActivity1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/{walletLocator}/get(WalletsV1Controller-getWalletByLocator-1)`.
    public func walletsV1ControllerGetWalletByLocator1(_ input: Operations.WalletsV1ControllerGetWalletByLocator1.Input) async throws -> Operations.WalletsV1ControllerGetWalletByLocator1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletByLocator1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator1.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When linkedUser is provided, subsequent calls with the same linkedUser will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha2/wallets`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/wallets/post(WalletsV1Controller-createWallet-1)`.
    public func walletsV1ControllerCreateWallet1(_ input: Operations.WalletsV1ControllerCreateWallet1.Input) async throws -> Operations.WalletsV1ControllerCreateWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet1.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet1.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a token and its available features by its locator
    ///
    /// Get a token by its locator
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha2/tokens/{tokenLocator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha2/tokens/{tokenLocator}/get(TokensController-getToken-0)`.
    public func tokensControllerGetToken0(_ input: Operations.TokensControllerGetToken0.Input) async throws -> Operations.TokensControllerGetToken0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokensControllerGetToken0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha2/tokens/{}",
                    parameters: [
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.TokensControllerGetToken0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SupportedTokenResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    return .badRequest(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/wallets/{walletLocator}/credential_nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/wallets/{walletLocator}/credential_nfts/get(WalletCredentialsController-getNFTsFromWallet-0)`.
    public func walletCredentialsControllerGetNFTsFromWallet0(_ input: Operations.WalletCredentialsControllerGetNFTsFromWallet0.Input) async throws -> Operations.WalletCredentialsControllerGetNFTsFromWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletCredentialsControllerGetNFTsFromWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/wallets/{}/credential_nfts",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs from Wallet
    ///
    /// Retrieves NFTs from a wallet.
    ///
    /// **API scope required**: `wallets:nfts.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/wallets/{locator}/nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/wallets/{locator}/nfts/get(WalletNFTController-getNFTsFromWallet-1)`.
    public func walletNFTControllerGetNFTsFromWallet1(_ input: Operations.WalletNFTControllerGetNFTsFromWallet1.Input) async throws -> Operations.WalletNFTControllerGetNFTsFromWallet1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletNFTControllerGetNFTsFromWallet1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/wallets/{}/nfts",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "contractAddress",
                    value: input.query.contractAddress
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokenId",
                    value: input.query.tokenId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletNFTControllerGetNFTsFromWallet1.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNFTsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/wallets`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/wallets/get(WalletController-getWalletForUser-0)`.
    public func walletControllerGetWalletForUser0(_ input: Operations.WalletControllerGetWalletForUser0.Input) async throws -> Operations.WalletControllerGetWalletForUser0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletControllerGetWalletForUser0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "uid",
                    value: input.query.uid
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "phoneNumber",
                    value: input.query.phoneNumber
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha1/wallets`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/wallets/post(WalletController-createWalletForUser-0)`.
    public func walletControllerCreateWalletForUser0(_ input: Operations.WalletControllerCreateWalletForUser0.Input) async throws -> Operations.WalletControllerCreateWalletForUser0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletControllerCreateWalletForUser0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/projects/{projectId}/wallets-created`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/projects/{projectId}/wallets-created/get(WalletsCreatedController-getWalletsCreated-0)`.
    public func walletsCreatedControllerGetWalletsCreated0(_ input: Operations.WalletsCreatedControllerGetWalletsCreated0.Input) async throws -> Operations.WalletsCreatedControllerGetWalletsCreated0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsCreatedControllerGetWalletsCreated0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/projects/{}/wallets-created",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/projects/{projectId}/usage`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/projects/{projectId}/usage/get(ProjectUsageController-getUsage-0)`.
    public func projectUsageControllerGetUsage0(_ input: Operations.ProjectUsageControllerGetUsage0.Input) async throws -> Operations.ProjectUsageControllerGetUsage0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectUsageControllerGetUsage0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/projects/{}/usage",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "dimension",
                    value: input.query.dimension
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "startDate",
                    value: input.query.startDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "endDate",
                    value: input.query.endDate
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2022-06-09/v1-alpha1/projects/{projectId}/domains/{domain}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/projects/{projectId}/domains/{domain}/put(ProjectDomainsController-updateDomain-0)`.
    public func projectDomainsControllerUpdateDomain0(_ input: Operations.ProjectDomainsControllerUpdateDomain0.Input) async throws -> Operations.ProjectDomainsControllerUpdateDomain0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectDomainsControllerUpdateDomain0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/projects/{}/domains/{}",
                    parameters: [
                        input.path.projectId,
                        input.path.domain
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /2022-06-09/v1-alpha1/projects/{projectId}/domains/{domain}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/projects/{projectId}/domains/{domain}/delete(ProjectDomainsController-deleteDomain-0)`.
    public func projectDomainsControllerDeleteDomain0(_ input: Operations.ProjectDomainsControllerDeleteDomain0.Input) async throws -> Operations.ProjectDomainsControllerDeleteDomain0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectDomainsControllerDeleteDomain0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/projects/{}/domains/{}",
                    parameters: [
                        input.path.projectId,
                        input.path.domain
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/projects/{projectId}/branding`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/projects/{projectId}/branding/get(BrandingController-get-0)`.
    public func brandingControllerGet0(_ input: Operations.BrandingControllerGet0.Input) async throws -> Operations.BrandingControllerGet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BrandingControllerGet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/projects/{}/branding",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha1/projects/{projectId}/branding`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/projects/{projectId}/branding/post(BrandingController-update-0)`.
    public func brandingControllerUpdate0(_ input: Operations.BrandingControllerUpdate0.Input) async throws -> Operations.BrandingControllerUpdate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BrandingControllerUpdate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/projects/{}/branding",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credential by token locator
    ///
    /// Get a single credential by token locator <chain:contract:tokenId>
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/nfts/{locator}/credentials`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/nfts/{locator}/credentials/get(AlphaTokenLocatorController-getCredential-0)`.
    public func alphaTokenLocatorControllerGetCredential0(_ input: Operations.AlphaTokenLocatorControllerGetCredential0.Input) async throws -> Operations.AlphaTokenLocatorControllerGetCredential0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AlphaTokenLocatorControllerGetCredential0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/nfts/{}/credentials",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Token by Locator
    ///
    /// Updates a token's metadata using a Crossmint token locator
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/v1-alpha1/nfts/{locator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/nfts/{locator}/patch(TokenLocatorController-update-0)`.
    public func tokenLocatorControllerUpdate0(_ input: Operations.TokenLocatorControllerUpdate0.Input) async throws -> Operations.TokenLocatorControllerUpdate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenLocatorControllerUpdate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/nfts/{}",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn Token by locator
    ///
    /// Burn an existing token
    ///
    /// - Remark: HTTP `DELETE /2022-06-09/v1-alpha1/nfts/{locator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/nfts/{locator}/delete(TokenLocatorController-delete-0)`.
    public func tokenLocatorControllerDelete0(_ input: Operations.TokenLocatorControllerDelete0.Input) async throws -> Operations.TokenLocatorControllerDelete0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenLocatorControllerDelete0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/nfts/{}",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/send/post(MintingAPIV1AlphaController-sendNft-0)`.
    public func mintingAPIV1AlphaControllerSendNft0(_ input: Operations.MintingAPIV1AlphaControllerSendNft0.Input) async throws -> Operations.MintingAPIV1AlphaControllerSendNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerSendNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/minting/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/patch(MintingAPIV1AlphaController-updateNft-0)`.
    public func mintingAPIV1AlphaControllerUpdateNft0(_ input: Operations.MintingAPIV1AlphaControllerUpdateNft0.Input) async throws -> Operations.MintingAPIV1AlphaControllerUpdateNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerUpdateNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /2022-06-09/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/minting/collections/{collectionId}/nfts/{customerFacingId}/delete(MintingAPIV1AlphaController-deleteNft-0)`.
    public func mintingAPIV1AlphaControllerDeleteNft0(_ input: Operations.MintingAPIV1AlphaControllerDeleteNft0.Input) async throws -> Operations.MintingAPIV1AlphaControllerDeleteNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerDeleteNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/minting/collections/{collectionId}/{featureSlug}/get(MintingAPIV1AlphaController-getFeature-0)`.
    public func mintingAPIV1AlphaControllerGetFeature0(_ input: Operations.MintingAPIV1AlphaControllerGetFeature0.Input) async throws -> Operations.MintingAPIV1AlphaControllerGetFeature0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerGetFeature0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2022-06-09/v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/minting/collections/{collectionId}/{featureSlug}/put(MintingAPIV1AlphaController-updateFeature-0)`.
    public func mintingAPIV1AlphaControllerUpdateFeature0(_ input: Operations.MintingAPIV1AlphaControllerUpdateFeature0.Input) async throws -> Operations.MintingAPIV1AlphaControllerUpdateFeature0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerUpdateFeature0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /2022-06-09/v1-alpha1/minting/collections/{collectionId}/{featureSlug}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/minting/collections/{collectionId}/{featureSlug}/delete(MintingAPIV1AlphaController-disableFeature-0)`.
    public func mintingAPIV1AlphaControllerDisableFeature0(_ input: Operations.MintingAPIV1AlphaControllerDisableFeature0.Input) async throws -> Operations.MintingAPIV1AlphaControllerDisableFeature0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MintingAPIV1AlphaControllerDisableFeature0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/minting/collections/{}/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.featureSlug
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify a Credential
    ///
    /// Verify a Verifiable Credential
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha1/credentials/verification/verify`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/verification/verify/post(CredentialController-verifyCredential-0)`.
    public func credentialControllerVerifyCredential0(_ input: Operations.CredentialControllerVerifyCredential0.Input) async throws -> Operations.CredentialControllerVerifyCredential0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerVerifyCredential0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/verification/verify",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Type
    ///
    /// Get a Verifiable Credential Type by id
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/credentials/types/{typeId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/types/{typeId}/get(CredentialTypesController-getType-0)`.
    public func credentialTypesControllerGetType0(_ input: Operations.CredentialTypesControllerGetType0.Input) async throws -> Operations.CredentialTypesControllerGetType0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerGetType0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/types/{}",
                    parameters: [
                        input.path.typeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Type (Idempotent)
    ///
    /// Create a new type with a given name
    ///
    /// - Remark: HTTP `PUT /2022-06-09/v1-alpha1/credentials/types/{typeId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/types/{typeId}/put(CredentialTypesController-createTypeIdempotent-0)`.
    public func credentialTypesControllerCreateTypeIdempotent0(_ input: Operations.CredentialTypesControllerCreateTypeIdempotent0.Input) async throws -> Operations.CredentialTypesControllerCreateTypeIdempotent0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerCreateTypeIdempotent0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/types/{}",
                    parameters: [
                        input.path.typeId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Type
    ///
    /// Create a new type
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha1/credentials/types`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/types/post(CredentialTypesController-createType-0)`.
    public func credentialTypesControllerCreateType0(_ input: Operations.CredentialTypesControllerCreateType0.Input) async throws -> Operations.CredentialTypesControllerCreateType0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialTypesControllerCreateType0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/types",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get lit delegation signature
    ///
    /// Get a delegation signature for lit decryption
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/credentials/decryption/delegateLitCapacity`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/decryption/delegateLitCapacity/get(CredentialController-getSignature-0)`.
    public func credentialControllerGetSignature0(_ input: Operations.CredentialControllerGetSignature0.Input) async throws -> Operations.CredentialControllerGetSignature0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerGetSignature0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/decryption/delegateLitCapacity",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Decrypt a credential given a wallet signature
    ///
    /// Requires an encrypted credential and a signature from the subject's wallet
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha1/credentials/decryption/decrypt`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/decryption/decrypt/post(CredentialController-decryptCredential-0)`.
    public func credentialControllerDecryptCredential0(_ input: Operations.CredentialControllerDecryptCredential0.Input) async throws -> Operations.CredentialControllerDecryptCredential0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerDecryptCredential0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/decryption/decrypt",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get a challenge for wallet authentication
    ///
    /// Will return a challenge to sign with a given wallet
    ///
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha1/credentials/auth/wallet`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/auth/wallet/post(CredentialController-walletAuthRequest-0)`.
    public func credentialControllerWalletAuthRequest0(_ input: Operations.CredentialControllerWalletAuthRequest0.Input) async throws -> Operations.CredentialControllerWalletAuthRequest0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerWalletAuthRequest0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/auth/wallet",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get credential
    ///
    /// Get a single credential
    ///
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/credentials/{credentialId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/{credentialId}/get(CredentialController-getCredential-0)`.
    public func credentialControllerGetCredential0(_ input: Operations.CredentialControllerGetCredential0.Input) async throws -> Operations.CredentialControllerGetCredential0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerGetCredential0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/{}",
                    parameters: [
                        input.path.credentialId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Revoke credential by id
    ///
    /// Revokes a verifiable credential and burns the associated NFT
    ///
    /// - Remark: HTTP `DELETE /2022-06-09/v1-alpha1/credentials/{credentialId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/credentials/{credentialId}/delete(CredentialController-delete-0)`.
    public func credentialControllerDelete0(_ input: Operations.CredentialControllerDelete0.Input) async throws -> Operations.CredentialControllerDelete0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CredentialControllerDelete0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/credentials/{}",
                    parameters: [
                        input.path.credentialId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/collections/{clientId}/mints`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/collections/{clientId}/mints/get(CollectionMintsController-getMints-0)`.
    public func collectionMintsControllerGetMints0(_ input: Operations.CollectionMintsControllerGetMints0.Input) async throws -> Operations.CollectionMintsControllerGetMints0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionMintsControllerGetMints0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/collections/{}/mints",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    value: input.query.cursor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/collections/{clientId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/collections/{clientId}/get(VerificationStatusController-get-0)`.
    public func verificationStatusControllerGet0(_ input: Operations.VerificationStatusControllerGet0.Input) async throws -> Operations.VerificationStatusControllerGet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.VerificationStatusControllerGet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/collections/{}",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/collections/get(ClientIntegrationController-getCollections-0)`.
    public func clientIntegrationControllerGetCollections0(_ input: Operations.ClientIntegrationControllerGetCollections0.Input) async throws -> Operations.ClientIntegrationControllerGetCollections0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerGetCollections0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hideDrafts",
                    value: input.query.hideDrafts
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "topology",
                    value: input.query.topology
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/collections/post(ClientIntegrationController-create-0)`.
    public func clientIntegrationControllerCreate0(_ input: Operations.ClientIntegrationControllerCreate0.Input) async throws -> Operations.ClientIntegrationControllerCreate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerCreate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2022-06-09/v1-alpha1/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/v1-alpha1/collections/put(ClientIntegrationController-update-0)`.
    public func clientIntegrationControllerUpdate0(_ input: Operations.ClientIntegrationControllerUpdate0.Input) async throws -> Operations.ClientIntegrationControllerUpdate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ClientIntegrationControllerUpdate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/v1-alpha1/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Search listings
    ///
    /// - Remark: HTTP `POST /2022-06-09/unstable/ws/search`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/ws/search/post(WorldstoreWrapperController-getListings-0)`.
    public func worldstoreWrapperControllerGetListings0(_ input: Operations.WorldstoreWrapperControllerGetListings0.Input) async throws -> Operations.WorldstoreWrapperControllerGetListings0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerGetListings0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/ws/search",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create an order for a listing
    ///
    /// - Remark: HTTP `POST /2022-06-09/unstable/ws/orders`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/ws/orders/post(WorldstoreWrapperController-createOrder-0)`.
    public func worldstoreWrapperControllerCreateOrder0(_ input: Operations.WorldstoreWrapperControllerCreateOrder0.Input) async throws -> Operations.WorldstoreWrapperControllerCreateOrder0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerCreateOrder0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/ws/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get order parameters schema for a seller
    ///
    /// - Remark: HTTP `GET /2022-06-09/unstable/ws/orderParameters`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/ws/orderParameters/get(WorldstoreWrapperController-getOrderParametersSchema-0)`.
    public func worldstoreWrapperControllerGetOrderParametersSchema0(_ input: Operations.WorldstoreWrapperControllerGetOrderParametersSchema0.Input) async throws -> Operations.WorldstoreWrapperControllerGetOrderParametersSchema0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WorldstoreWrapperControllerGetOrderParametersSchema0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/ws/orderParameters",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sellerId",
                    value: input.query.sellerId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify wallet ownership
    ///
    /// Verifies wallet ownership by a given email.
    ///
    /// - Remark: HTTP `POST /2022-06-09/unstable/wallets/verify-ownership`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/wallets/verify-ownership/post(WalletsVerifyRecipientController-verifyWalletOwnership-0)`.
    public func walletsVerifyRecipientControllerVerifyWalletOwnership0(_ input: Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership0.Input) async throws -> Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsVerifyRecipientControllerVerifyWalletOwnership0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/wallets/verify-ownership",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token For Authenticated User
    ///
    /// Sends a token of any type from the authenticated user's wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2022-06-09/unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/wallets/me{walletType}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenController-sendMeToken-0)`.
    public func walletsSendTokenControllerSendMeToken0(_ input: Operations.WalletsSendTokenControllerSendMeToken0.Input) async throws -> Operations.WalletsSendTokenControllerSendMeToken0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenControllerSendMeToken0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/wallets/me{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletType,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenControllerSendMeToken0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User (Unstable)
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events. This is an unstable API that may change without notice.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/unstable/wallets/me{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/wallets/me{walletLocator}/activity/get(WalletActivityUnstableController-getMeWalletActivity-0)`.
    public func walletActivityUnstableControllerGetMeWalletActivity0(_ input: Operations.WalletActivityUnstableControllerGetMeWalletActivity0.Input) async throws -> Operations.WalletActivityUnstableControllerGetMeWalletActivity0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletActivityUnstableControllerGetMeWalletActivity0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/wallets/me{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetMeWalletActivity0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsActivityResponseUnstableDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetMeWalletActivity0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token
    ///
    /// Sends a token of any type from this wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2022-06-09/unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/wallets/{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenController-sendToken-0)`.
    public func walletsSendTokenControllerSendToken0(_ input: Operations.WalletsSendTokenControllerSendToken0.Input) async throws -> Operations.WalletsSendTokenControllerSendToken0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenControllerSendToken0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/wallets/{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenControllerSendToken0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseWithSendParamsDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/unstable/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/wallets/{walletLocator}/balances/get(BalanceUnstableController-getBalanceForLocator-0)`.
    public func balanceUnstableControllerGetBalanceForLocator0(_ input: Operations.BalanceUnstableControllerGetBalanceForLocator0.Input) async throws -> Operations.BalanceUnstableControllerGetBalanceForLocator0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceUnstableControllerGetBalanceForLocator0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceUnstableControllerGetBalanceForLocator0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceUnstableResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceUnstableControllerGetBalanceForLocator0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity (Unstable)
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events. This is an unstable API that may change without notice.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/unstable/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/wallets/{walletLocator}/activity/get(WalletActivityUnstableController-getWalletActivity-0)`.
    public func walletActivityUnstableControllerGetWalletActivity0(_ input: Operations.WalletActivityUnstableControllerGetWalletActivity0.Input) async throws -> Operations.WalletActivityUnstableControllerGetWalletActivity0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletActivityUnstableControllerGetWalletActivity0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetWalletActivity0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsActivityResponseUnstableDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletActivityUnstableControllerGetWalletActivity0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/unstable/wallets/{locator}/{currency}/balance`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/wallets/{locator}/{currency}/balance/get(WalletBalanceController-getBalanceForLocatorAndCurrency-0)`.
    public func walletBalanceControllerGetBalanceForLocatorAndCurrency0(_ input: Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency0.Input) async throws -> Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletBalanceControllerGetBalanceForLocatorAndCurrency0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/wallets/{}/{}/balance",
                    parameters: [
                        input.path.locator,
                        input.path.currency
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/unstable/wallets`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/wallets/get(GetWalletsController-getWallets-0)`.
    public func getWalletsControllerGetWallets0(_ input: Operations.GetWalletsControllerGetWallets0.Input) async throws -> Operations.GetWalletsControllerGetWallets0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetWalletsControllerGetWallets0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "phoneNumber",
                    value: input.query.phoneNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "address",
                    value: input.query.address
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "handle",
                    value: input.query.handle
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/unstable/setupTokenizeCard/registerToken`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/setupTokenizeCard/registerToken/post(TokenizedCardController-registerToken-0)`.
    public func tokenizedCardControllerRegisterToken0(_ input: Operations.TokenizedCardControllerRegisterToken0.Input) async throws -> Operations.TokenizedCardControllerRegisterToken0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerRegisterToken0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/setupTokenizeCard/registerToken",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/unstable/setupTokenizeCard/createPurchaseIntent`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/setupTokenizeCard/createPurchaseIntent/post(TokenizedCardController-createPurchaseIntent-0)`.
    public func tokenizedCardControllerCreatePurchaseIntent0(_ input: Operations.TokenizedCardControllerCreatePurchaseIntent0.Input) async throws -> Operations.TokenizedCardControllerCreatePurchaseIntent0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerCreatePurchaseIntent0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/setupTokenizeCard/createPurchaseIntent",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/unstable/setupTokenizeCard`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/setupTokenizeCard/get(TokenizedCardController-setupTokenizeCard-0)`.
    public func tokenizedCardControllerSetupTokenizeCard0(_ input: Operations.TokenizedCardControllerSetupTokenizeCard0.Input) async throws -> Operations.TokenizedCardControllerSetupTokenizeCard0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TokenizedCardControllerSetupTokenizeCard0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/setupTokenizeCard",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Order Tracking
    ///
    /// Get delivery tracking information for an order
    ///
    /// - Remark: HTTP `GET /2022-06-09/unstable/orders/{orderId}/tracking`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/orders/{orderId}/tracking/get(HeadlessCheckoutUnstableOrdersController-getTracking-0)`.
    public func headlessCheckoutUnstableOrdersControllerGetTracking0(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking0.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerGetTracking0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/orders/{}/tracking",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get refunds for an order
    ///
    /// Get refunds for an order.
    ///
    /// - Remark: HTTP `GET /2022-06-09/unstable/orders/{orderId}/refunds`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/orders/{orderId}/refunds/get(HeadlessCheckoutUnstableOrdersController-getRefunds-0)`.
    public func headlessCheckoutUnstableOrdersControllerGetRefunds0(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds0.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerGetRefunds0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/orders/{}/refunds",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Refund order
    ///
    /// Refund an order.
    ///
    /// - Remark: HTTP `POST /2022-06-09/unstable/orders/{orderId}/refunds`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/orders/{orderId}/refunds/post(HeadlessCheckoutUnstableOrdersController-refundOrder-0)`.
    public func headlessCheckoutUnstableOrdersControllerRefundOrder0(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder0.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerRefundOrder0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/orders/{}/refunds",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Process payment
    ///
    /// Process payment for an order.
    ///
    /// - Remark: HTTP `POST /2022-06-09/unstable/orders/{orderId}/payment`.
    /// - Remark: Generated from `#/paths//2022-06-09/unstable/orders/{orderId}/payment/post(HeadlessCheckoutUnstableOrdersController-processPayment-0)`.
    public func headlessCheckoutUnstableOrdersControllerProcessPayment0(_ input: Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment0.Input) async throws -> Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutUnstableOrdersControllerProcessPayment0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/unstable/orders/{}/payment",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Subscription
    ///
    /// Retrieve information about an existing subscription, including expiry time, payment information and recurrency status.
    ///
    /// - Remark: HTTP `GET /2022-06-09/subscriptions/{subscriptionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/subscriptions/{subscriptionId}/get(SubscriptionsController-getSubscription-2)`.
    public func subscriptionsControllerGetSubscription2(_ input: Operations.SubscriptionsControllerGetSubscription2.Input) async throws -> Operations.SubscriptionsControllerGetSubscription2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SubscriptionsControllerGetSubscription2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/subscriptions/{}",
                    parameters: [
                        input.path.subscriptionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SubscriptionsControllerGetSubscription2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SubscriptionDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/session/signout`.
    /// - Remark: Generated from `#/paths//2022-06-09/session/signout/post(SessionController-signout-0)`.
    public func sessionControllerSignout0(_ input: Operations.SessionControllerSignout0.Input) async throws -> Operations.SessionControllerSignout0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerSignout0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/session/signout",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/session/exchange-access-token`.
    /// - Remark: Generated from `#/paths//2022-06-09/session/exchange-access-token/post(SessionController-exchangeAccessToken-0)`.
    public func sessionControllerExchangeAccessToken0(_ input: Operations.SessionControllerExchangeAccessToken0.Input) async throws -> Operations.SessionControllerExchangeAccessToken0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerExchangeAccessToken0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/session/exchange-access-token",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/session/authenticate`.
    /// - Remark: Generated from `#/paths//2022-06-09/session/authenticate/get(SessionController-authenticateOAuth-0)`.
    public func sessionControllerAuthenticateOAuth0(_ input: Operations.SessionControllerAuthenticateOAuth0.Input) async throws -> Operations.SessionControllerAuthenticateOAuth0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerAuthenticateOAuth0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/session/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/session/authenticate`.
    /// - Remark: Generated from `#/paths//2022-06-09/session/authenticate/post(SessionController-authenticate-0)`.
    public func sessionControllerAuthenticate0(_ input: Operations.SessionControllerAuthenticate0.Input) async throws -> Operations.SessionControllerAuthenticate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerAuthenticate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/session/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/session`.
    /// - Remark: Generated from `#/paths//2022-06-09/session/get(SessionController-getSession-0)`.
    public func sessionControllerGetSession0(_ input: Operations.SessionControllerGetSession0.Input) async throws -> Operations.SessionControllerGetSession0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SessionControllerGetSession0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/session",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/sdk/auth/user/get-or-create`.
    /// - Remark: Generated from `#/paths//2022-06-09/sdk/auth/user/get-or-create/post(AuthSdkInternalController-getOrCreateUserOnStytch-0)`.
    public func authSdkInternalControllerGetOrCreateUserOnStytch0(_ input: Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch0.Input) async throws -> Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkInternalControllerGetOrCreateUserOnStytch0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/sdk/auth/user/get-or-create",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Refresh Order
    ///
    /// Refreshes the quote and availability for a given order.
    ///
    /// - Remark: HTTP `POST /2022-06-09/orders/{orderId}/refresh`.
    /// - Remark: Generated from `#/paths//2022-06-09/orders/{orderId}/refresh/post(HeadlessCheckoutOrdersController-refreshOrder-2)`.
    public func headlessCheckoutOrdersControllerRefreshOrder2(_ input: Operations.HeadlessCheckoutOrdersControllerRefreshOrder2.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerRefreshOrder2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerRefreshOrder2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/orders/{}/refresh",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerRefreshOrder2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Process payment
    ///
    /// Process payment for an order.
    ///
    /// - Remark: HTTP `POST /2022-06-09/orders/{orderId}/payment`.
    /// - Remark: Generated from `#/paths//2022-06-09/orders/{orderId}/payment/post(HeadlessCheckoutOrdersController-processPayment-2)`.
    public func headlessCheckoutOrdersControllerProcessPayment2(_ input: Operations.HeadlessCheckoutOrdersControllerProcessPayment2.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerProcessPayment2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerProcessPayment2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/orders/{}/payment",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/orders/{orderId}/3ds/sessions/{sessionId}/authenticate`.
    /// - Remark: Generated from `#/paths//2022-06-09/orders/{orderId}/3ds/sessions/{sessionId}/authenticate/post(HeadlessCheckout3DSSController-authenticate-2)`.
    public func headlessCheckout3DSSControllerAuthenticate2(_ input: Operations.HeadlessCheckout3DSSControllerAuthenticate2.Input) async throws -> Operations.HeadlessCheckout3DSSControllerAuthenticate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckout3DSSControllerAuthenticate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/orders/{}/3ds/sessions/{}/authenticate",
                    parameters: [
                        input.path.orderId,
                        input.path.sessionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Order
    ///
    /// Get specific order by ID
    ///
    /// - Remark: HTTP `GET /2022-06-09/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/orders/{orderId}/get(HeadlessCheckoutOrdersController-get-2)`.
    public func headlessCheckoutOrdersControllerGet2(_ input: Operations.HeadlessCheckoutOrdersControllerGet2.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerGet2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerGet2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/orders/{}",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerGet2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Order
    ///
    /// Update an existing order. You can update the recipient, the payment method and the locale.
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/orders/{orderId}/patch(HeadlessCheckoutOrdersController-update-2)`.
    public func headlessCheckoutOrdersControllerUpdate2(_ input: Operations.HeadlessCheckoutOrdersControllerUpdate2.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerUpdate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerUpdate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/orders/{}",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerUpdate2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Order
    ///
    /// Create a new order
    ///
    /// - Remark: HTTP `POST /2022-06-09/orders`.
    /// - Remark: Generated from `#/paths//2022-06-09/orders/post(HeadlessCheckoutOrdersController-create-2)`.
    public func headlessCheckoutOrdersControllerCreate2(_ input: Operations.HeadlessCheckoutOrdersControllerCreate2.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerCreate2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerCreate2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerCreate2.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Start the device onboarding process
    ///
    /// - Remark: HTTP `POST /2022-06-09/ncs/v1/signers/start-onboarding`.
    /// - Remark: Generated from `#/paths//2022-06-09/ncs/v1/signers/start-onboarding/post(NCSController-forwardStartOnboarding-1)`.
    public func ncsControllerForwardStartOnboarding1(_ input: Operations.NCSControllerForwardStartOnboarding1.Input) async throws -> Operations.NCSControllerForwardStartOnboarding1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardStartOnboarding1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/ncs/v1/signers/start-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Deterministically generate a signer's public key for a specified signing curve
    ///
    /// - Remark: HTTP `POST /2022-06-09/ncs/v1/signers/derive-public-key`.
    /// - Remark: Generated from `#/paths//2022-06-09/ncs/v1/signers/derive-public-key/post(NCSController-forwardPreGeneration-1)`.
    public func ncsControllerForwardPreGeneration1(_ input: Operations.NCSControllerForwardPreGeneration1.Input) async throws -> Operations.NCSControllerForwardPreGeneration1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardPreGeneration1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/ncs/v1/signers/derive-public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Complete the device onboarding process, storing an encrypted master secret, and forwarding it to the device
    ///
    /// - Remark: HTTP `POST /2022-06-09/ncs/v1/signers/complete-onboarding`.
    /// - Remark: Generated from `#/paths//2022-06-09/ncs/v1/signers/complete-onboarding/post(NCSController-forwardCompleteOnboarding-1)`.
    public func ncsControllerForwardCompleteOnboarding1(_ input: Operations.NCSControllerForwardCompleteOnboarding1.Input) async throws -> Operations.NCSControllerForwardCompleteOnboarding1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerForwardCompleteOnboarding1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/ncs/v1/signers/complete-onboarding",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get everything an NCS device needs to operate, including the encrypted master secret.
    ///
    /// - Remark: HTTP `GET /2022-06-09/ncs/v1/devices/{deviceId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/ncs/v1/devices/{deviceId}/get(NCSController-getDevice-1)`.
    public func ncsControllerGetDevice1(_ input: Operations.NCSControllerGetDevice1.Input) async throws -> Operations.NCSControllerGetDevice1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetDevice1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/ncs/v1/devices/{}",
                    parameters: [
                        input.path.deviceId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the encryption public key for the TEE - for local developement
    ///
    /// - Remark: HTTP `GET /2022-06-09/ncs/v1/attestation/public-key`.
    /// - Remark: Generated from `#/paths//2022-06-09/ncs/v1/attestation/public-key/get(NCSController-getPublicKey-1)`.
    public func ncsControllerGetPublicKey1(_ input: Operations.NCSControllerGetPublicKey1.Input) async throws -> Operations.NCSControllerGetPublicKey1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetPublicKey1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/ncs/v1/attestation/public-key",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get the attestation for the TEE
    ///
    /// - Remark: HTTP `GET /2022-06-09/ncs/v1/attestation`.
    /// - Remark: Generated from `#/paths//2022-06-09/ncs/v1/attestation/get(NCSController-getAttestation-1)`.
    public func ncsControllerGetAttestation1(_ input: Operations.NCSControllerGetAttestation1.Input) async throws -> Operations.NCSControllerGetAttestation1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NCSControllerGetAttestation1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/ncs/v1/attestation",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/templates/{templateId}/get(TemplatesController-getTemplate-1)`.
    public func templatesControllerGetTemplate1(_ input: Operations.TemplatesControllerGetTemplate1.Input) async throws -> Operations.TemplatesControllerGetTemplate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerGetTemplate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PATCH /2022-06-09/minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/templates/{templateId}/patch(TemplatesController-updateTemplate-1)`.
    public func templatesControllerUpdateTemplate1(_ input: Operations.TemplatesControllerUpdateTemplate1.Input) async throws -> Operations.TemplatesControllerUpdateTemplate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerUpdateTemplate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2022-06-09/minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/templates/{templateId}/put(TemplatesController-createTemplateIdempotent-1)`.
    public func templatesControllerCreateTemplateIdempotent1(_ input: Operations.TemplatesControllerCreateTemplateIdempotent1.Input) async throws -> Operations.TemplatesControllerCreateTemplateIdempotent1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplateIdempotent1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /2022-06-09/minting/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/templates/{templateId}/delete(TemplatesController-deleteTemplate-1)`.
    public func templatesControllerDeleteTemplate1(_ input: Operations.TemplatesControllerDeleteTemplate1.Input) async throws -> Operations.TemplatesControllerDeleteTemplate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerDeleteTemplate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/minting/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/templates/get(TemplatesController-listTemplates-1)`.
    public func templatesControllerListTemplates1(_ input: Operations.TemplatesControllerListTemplates1.Input) async throws -> Operations.TemplatesControllerListTemplates1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerListTemplates1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/minting/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/templates/post(TemplatesController-createTemplate-1)`.
    public func templatesControllerCreateTemplate1(_ input: Operations.TemplatesControllerCreateTemplate1.Input) async throws -> Operations.TemplatesControllerCreateTemplate1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplate1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create SFT
    ///
    /// Create a new SFT
    ///
    /// - Remark: HTTP `POST /2022-06-09/minting/collections/{collectionId}/sfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/sfts/post(SFTsController-createSft-1)`.
    public func sfTsControllerCreateSft1(_ input: Operations.SFTsControllerCreateSft1.Input) async throws -> Operations.SFTsControllerCreateSft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SFTsControllerCreateSft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/sfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "idempotency-key",
                    value: input.headers.idempotencyKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer NFT
    ///
    /// Transfer an existing NFT
    ///
    /// - Remark: HTTP `POST /2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}/send/post(NFTsController-transferNft-1)`.
    public func nfTsControllerTransferNft1(_ input: Operations.NFTsControllerTransferNft1.Input) async throws -> Operations.NFTsControllerTransferNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerTransferNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFT
    ///
    /// Get a single NFT
    ///
    /// - Remark: HTTP `GET /2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}/get(NFTsController-getNft-1)`.
    public func nfTsControllerGetNft1(_ input: Operations.NFTsControllerGetNft1.Input) async throws -> Operations.NFTsControllerGetNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}/patch(NFTsController-updateNft-1)`.
    public func nfTsControllerUpdateNft1(_ input: Operations.NFTsControllerUpdateNft1.Input) async throws -> Operations.NFTsControllerUpdateNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerUpdateNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT (Idempotent)
    ///
    /// Create a new NFT with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}/put(NFTsController-createNftIdempotent-1)`.
    public func nfTsControllerCreateNftIdempotent1(_ input: Operations.NFTsControllerCreateNftIdempotent1.Input) async throws -> Operations.NFTsControllerCreateNftIdempotent1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNftIdempotent1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/nfts/{customerFacingId}/delete(NFTsController-deleteNft-1)`.
    public func nfTsControllerDeleteNft1(_ input: Operations.NFTsControllerDeleteNft1.Input) async throws -> Operations.NFTsControllerDeleteNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerDeleteNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs in a collection
    ///
    /// Get all NFTs in a collection
    ///
    /// - Remark: HTTP `GET /2022-06-09/minting/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/nfts/get(NFTsController-getNfts-1)`.
    public func nfTsControllerGetNfts1(_ input: Operations.NFTsControllerGetNfts1.Input) async throws -> Operations.NFTsControllerGetNfts1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNfts1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT
    ///
    /// Create a new NFT
    ///
    /// - Remark: HTTP `POST /2022-06-09/minting/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/nfts/post(NFTsController-createNft-1)`.
    public func nfTsControllerCreateNft1(_ input: Operations.NFTsControllerCreateNft1.Input) async throws -> Operations.NFTsControllerCreateNft1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNft1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /2022-06-09/minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/get(CollectionsController-getCollection-1)`.
    public func collectionsControllerGetCollection1(_ input: Operations.CollectionsControllerGetCollection1.Input) async throws -> Operations.CollectionsControllerGetCollection1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/patch(CollectionsController-updateCollection-1)`.
    public func collectionsControllerUpdateCollection1(_ input: Operations.CollectionsControllerUpdateCollection1.Input) async throws -> Operations.CollectionsControllerUpdateCollection1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2022-06-09/minting/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-1)`.
    public func collectionsControllerCreateIdempotentOrGetCollection1(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection1.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /2022-06-09/minting/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/get(CollectionsController-getCollections-1)`.
    public func collectionsControllerGetCollections1(_ input: Operations.CollectionsControllerGetCollections1.Input) async throws -> Operations.CollectionsControllerGetCollections1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /2022-06-09/minting/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/minting/collections/post(CollectionsController-createCollection-1)`.
    public func collectionsControllerCreateCollection1(_ input: Operations.CollectionsControllerCreateCollection1.Input) async throws -> Operations.CollectionsControllerCreateCollection1.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection1.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/minting/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Verify the registration response (cred) and return the results to the client
    ///
    /// - Remark: HTTP `POST /2022-06-09/internal/passkeys/register/verify`.
    /// - Remark: Generated from `#/paths//2022-06-09/internal/passkeys/register/verify/post(PasskeysController-verifyRegistration-0)`.
    public func passkeysControllerVerifyRegistration0(_ input: Operations.PasskeysControllerVerifyRegistration0.Input) async throws -> Operations.PasskeysControllerVerifyRegistration0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PasskeysControllerVerifyRegistration0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/internal/passkeys/register/verify",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "origin",
                    value: input.headers.origin
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Generate and return registration options to the client
    ///
    /// The client will use these options to prompt the user to create a passkey
    ///
    /// - Remark: HTTP `POST /2022-06-09/internal/passkeys/register/options`.
    /// - Remark: Generated from `#/paths//2022-06-09/internal/passkeys/register/options/post(PasskeysController-generateRegistrationOptions-0)`.
    public func passkeysControllerGenerateRegistrationOptions0(_ input: Operations.PasskeysControllerGenerateRegistrationOptions0.Input) async throws -> Operations.PasskeysControllerGenerateRegistrationOptions0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PasskeysControllerGenerateRegistrationOptions0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/internal/passkeys/register/options",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "origin",
                    value: input.headers.origin
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/internal/monitoring/outstanding-exports`.
    /// - Remark: Generated from `#/paths//2022-06-09/internal/monitoring/outstanding-exports/get(ExportsController-findOutstandingExports-0)`.
    public func exportsControllerFindOutstandingExports0(_ input: Operations.ExportsControllerFindOutstandingExports0.Input) async throws -> Operations.ExportsControllerFindOutstandingExports0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ExportsControllerFindOutstandingExports0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/internal/monitoring/outstanding-exports",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/export-csv`.
    /// - Remark: Generated from `#/paths//2022-06-09/export-csv/post(ExportCsvController-createExport-0)`.
    public func exportCsvControllerCreateExport0(_ input: Operations.ExportCsvControllerCreateExport0.Input) async throws -> Operations.ExportCsvControllerCreateExport0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ExportCsvControllerCreateExport0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/export-csv",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /2022-06-09/credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/credentials/templates/{collectionId}/get(CollectionsController-getCollection-2)`.
    public func collectionsControllerGetCollection2(_ input: Operations.CollectionsControllerGetCollection2.Input) async throws -> Operations.CollectionsControllerGetCollection2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/credentials/templates/{collectionId}/patch(CollectionsController-updateCollection-2)`.
    public func collectionsControllerUpdateCollection2(_ input: Operations.CollectionsControllerUpdateCollection2.Input) async throws -> Operations.CollectionsControllerUpdateCollection2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2022-06-09/credentials/templates/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/credentials/templates/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-2)`.
    public func collectionsControllerCreateIdempotentOrGetCollection2(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection2.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/credentials/templates/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /2022-06-09/credentials/templates`.
    /// - Remark: Generated from `#/paths//2022-06-09/credentials/templates/get(CollectionsController-getCollections-2)`.
    public func collectionsControllerGetCollections2(_ input: Operations.CollectionsControllerGetCollections2.Input) async throws -> Operations.CollectionsControllerGetCollections2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/credentials/templates",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /2022-06-09/credentials/templates`.
    /// - Remark: Generated from `#/paths//2022-06-09/credentials/templates/post(CollectionsController-createCollection-2)`.
    public func collectionsControllerCreateCollection2(_ input: Operations.CollectionsControllerCreateCollection2.Input) async throws -> Operations.CollectionsControllerCreateCollection2.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection2.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/credentials/templates",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/console/projects/{projectId}/billing/subscriptionCosts`.
    /// - Remark: Generated from `#/paths//2022-06-09/console/projects/{projectId}/billing/subscriptionCosts/get(SubscriptionCostController-getSubscriptionCosts-0)`.
    public func subscriptionCostControllerGetSubscriptionCosts0(_ input: Operations.SubscriptionCostControllerGetSubscriptionCosts0.Input) async throws -> Operations.SubscriptionCostControllerGetSubscriptionCosts0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SubscriptionCostControllerGetSubscriptionCosts0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/console/projects/{}/billing/subscriptionCosts",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/console/project/{projectId}/privacy-policy`.
    /// - Remark: Generated from `#/paths//2022-06-09/console/project/{projectId}/privacy-policy/get(PrivacyPolicyController-getByProjectId-0)`.
    public func privacyPolicyControllerGetByProjectId0(_ input: Operations.PrivacyPolicyControllerGetByProjectId0.Input) async throws -> Operations.PrivacyPolicyControllerGetByProjectId0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PrivacyPolicyControllerGetByProjectId0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/console/project/{}/privacy-policy",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/console/project/{projectId}/privacy-policy`.
    /// - Remark: Generated from `#/paths//2022-06-09/console/project/{projectId}/privacy-policy/post(PrivacyPolicyController-create-0)`.
    public func privacyPolicyControllerCreate0(_ input: Operations.PrivacyPolicyControllerCreate0.Input) async throws -> Operations.PrivacyPolicyControllerCreate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PrivacyPolicyControllerCreate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/console/project/{}/privacy-policy",
                    parameters: [
                        input.path.projectId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/console/contact-sales/upgrade-plan-submission`.
    /// - Remark: Generated from `#/paths//2022-06-09/console/contact-sales/upgrade-plan-submission/post(UpgradePlanSubmissionController-sendEmailToSales-0)`.
    public func upgradePlanSubmissionControllerSendEmailToSales0(_ input: Operations.UpgradePlanSubmissionControllerSendEmailToSales0.Input) async throws -> Operations.UpgradePlanSubmissionControllerSendEmailToSales0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UpgradePlanSubmissionControllerSendEmailToSales0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/console/contact-sales/upgrade-plan-submission",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/console/contact-sales/new-referral`.
    /// - Remark: Generated from `#/paths//2022-06-09/console/contact-sales/new-referral/post(NewReferralRegisteredController-sendEmailToSales-0)`.
    public func newReferralRegisteredControllerSendEmailToSales0(_ input: Operations.NewReferralRegisteredControllerSendEmailToSales0.Input) async throws -> Operations.NewReferralRegisteredControllerSendEmailToSales0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NewReferralRegisteredControllerSendEmailToSales0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/console/contact-sales/new-referral",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update an individual quickstart
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/console/admin/quickstarts/{id}`.
    /// - Remark: Generated from `#/paths//2022-06-09/console/admin/quickstarts/{id}/patch(QuickstartController-updateQuickstart-0)`.
    public func quickstartControllerUpdateQuickstart0(_ input: Operations.QuickstartControllerUpdateQuickstart0.Input) async throws -> Operations.QuickstartControllerUpdateQuickstart0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerUpdateQuickstart0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/console/admin/quickstarts/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 400:
                    return .badRequest(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete a quickstart
    ///
    /// - Remark: HTTP `DELETE /2022-06-09/console/admin/quickstarts/{id}`.
    /// - Remark: Generated from `#/paths//2022-06-09/console/admin/quickstarts/{id}/delete(QuickstartController-deleteQuickstart-0)`.
    public func quickstartControllerDeleteQuickstart0(_ input: Operations.QuickstartControllerDeleteQuickstart0.Input) async throws -> Operations.QuickstartControllerDeleteQuickstart0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerDeleteQuickstart0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/console/admin/quickstarts/{}",
                    parameters: [
                        input.path.id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 404:
                    return .notFound(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create a new quickstart
    ///
    /// - Remark: HTTP `POST /2022-06-09/console/admin/quickstarts`.
    /// - Remark: Generated from `#/paths//2022-06-09/console/admin/quickstarts/post(QuickstartController-createQuickstart-0)`.
    public func quickstartControllerCreateQuickstart0(_ input: Operations.QuickstartControllerCreateQuickstart0.Input) async throws -> Operations.QuickstartControllerCreateQuickstart0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.QuickstartControllerCreateQuickstart0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/console/admin/quickstarts",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                case 400:
                    return .badRequest(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/templates/{templateId}/get(TemplatesController-getTemplate-0)`.
    public func templatesControllerGetTemplate0(_ input: Operations.TemplatesControllerGetTemplate0.Input) async throws -> Operations.TemplatesControllerGetTemplate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerGetTemplate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PATCH /2022-06-09/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/templates/{templateId}/patch(TemplatesController-updateTemplate-0)`.
    public func templatesControllerUpdateTemplate0(_ input: Operations.TemplatesControllerUpdateTemplate0.Input) async throws -> Operations.TemplatesControllerUpdateTemplate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerUpdateTemplate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 204:
                    return .noContent(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2022-06-09/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/templates/{templateId}/put(TemplatesController-createTemplateIdempotent-0)`.
    public func templatesControllerCreateTemplateIdempotent0(_ input: Operations.TemplatesControllerCreateTemplateIdempotent0.Input) async throws -> Operations.TemplatesControllerCreateTemplateIdempotent0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplateIdempotent0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /2022-06-09/collections/{collectionId}/templates/{templateId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/templates/{templateId}/delete(TemplatesController-deleteTemplate-0)`.
    public func templatesControllerDeleteTemplate0(_ input: Operations.TemplatesControllerDeleteTemplate0.Input) async throws -> Operations.TemplatesControllerDeleteTemplate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerDeleteTemplate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/templates/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.templateId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/templates/get(TemplatesController-listTemplates-0)`.
    public func templatesControllerListTemplates0(_ input: Operations.TemplatesControllerListTemplates0.Input) async throws -> Operations.TemplatesControllerListTemplates0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerListTemplates0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/collections/{collectionId}/templates`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/templates/post(TemplatesController-createTemplate-0)`.
    public func templatesControllerCreateTemplate0(_ input: Operations.TemplatesControllerCreateTemplate0.Input) async throws -> Operations.TemplatesControllerCreateTemplate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.TemplatesControllerCreateTemplate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/templates",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create SFT
    ///
    /// Create a new SFT
    ///
    /// - Remark: HTTP `POST /2022-06-09/collections/{collectionId}/sfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/sfts/post(SFTsController-createSft-0)`.
    public func sfTsControllerCreateSft0(_ input: Operations.SFTsControllerCreateSft0.Input) async throws -> Operations.SFTsControllerCreateSft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SFTsControllerCreateSft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/sfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "idempotency-key",
                    value: input.headers.idempotencyKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer NFT
    ///
    /// Transfer an existing NFT
    ///
    /// - Remark: HTTP `POST /2022-06-09/collections/{collectionId}/nfts/{customerFacingId}/send`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/nfts/{customerFacingId}/send/post(NFTsController-transferNft-0)`.
    public func nfTsControllerTransferNft0(_ input: Operations.NFTsControllerTransferNft0.Input) async throws -> Operations.NFTsControllerTransferNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerTransferNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/nfts/{}/send",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFT
    ///
    /// Get a single NFT
    ///
    /// - Remark: HTTP `GET /2022-06-09/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/nfts/{customerFacingId}/get(NFTsController-getNft-0)`.
    public func nfTsControllerGetNft0(_ input: Operations.NFTsControllerGetNft0.Input) async throws -> Operations.NFTsControllerGetNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update NFT
    ///
    /// Update an existing NFT
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/nfts/{customerFacingId}/patch(NFTsController-updateNft-0)`.
    public func nfTsControllerUpdateNft0(_ input: Operations.NFTsControllerUpdateNft0.Input) async throws -> Operations.NFTsControllerUpdateNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerUpdateNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT (Idempotent)
    ///
    /// Create a new NFT with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2022-06-09/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/nfts/{customerFacingId}/put(NFTsController-createNftIdempotent-0)`.
    public func nfTsControllerCreateNftIdempotent0(_ input: Operations.NFTsControllerCreateNftIdempotent0.Input) async throws -> Operations.NFTsControllerCreateNftIdempotent0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNftIdempotent0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Burn NFT
    ///
    /// Burn an existing NFT
    ///
    /// - Remark: HTTP `DELETE /2022-06-09/collections/{collectionId}/nfts/{customerFacingId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/nfts/{customerFacingId}/delete(NFTsController-deleteNft-0)`.
    public func nfTsControllerDeleteNft0(_ input: Operations.NFTsControllerDeleteNft0.Input) async throws -> Operations.NFTsControllerDeleteNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerDeleteNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/nfts/{}",
                    parameters: [
                        input.path.collectionId,
                        input.path.customerFacingId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs in a collection
    ///
    /// Get all NFTs in a collection
    ///
    /// - Remark: HTTP `GET /2022-06-09/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/nfts/get(NFTsController-getNfts-0)`.
    public func nfTsControllerGetNfts0(_ input: Operations.NFTsControllerGetNfts0.Input) async throws -> Operations.NFTsControllerGetNfts0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerGetNfts0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create NFT
    ///
    /// Create a new NFT
    ///
    /// - Remark: HTTP `POST /2022-06-09/collections/{collectionId}/nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/nfts/post(NFTsController-createNft-0)`.
    public func nfTsControllerCreateNft0(_ input: Operations.NFTsControllerCreateNft0.Input) async throws -> Operations.NFTsControllerCreateNft0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.NFTsControllerCreateNft0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/nfts",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collection
    ///
    /// Get a single collection
    ///
    /// - Remark: HTTP `GET /2022-06-09/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/get(CollectionsController-getCollection-0)`.
    public func collectionsControllerGetCollection0(_ input: Operations.CollectionsControllerGetCollection0.Input) async throws -> Operations.CollectionsControllerGetCollection0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollection0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Collection
    ///
    /// Update an existing collection
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/patch(CollectionsController-updateCollection-0)`.
    public func collectionsControllerUpdateCollection0(_ input: Operations.CollectionsControllerUpdateCollection0.Input) async throws -> Operations.CollectionsControllerUpdateCollection0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerUpdateCollection0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection (Idempotent)
    ///
    /// Create a new collection with a pre-computed id, or get an existing one if the id already exists
    ///
    /// - Remark: HTTP `PUT /2022-06-09/collections/{collectionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{collectionId}/put(CollectionsController-createIdempotentOrGetCollection-0)`.
    public func collectionsControllerCreateIdempotentOrGetCollection0(_ input: Operations.CollectionsControllerCreateIdempotentOrGetCollection0.Input) async throws -> Operations.CollectionsControllerCreateIdempotentOrGetCollection0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateIdempotentOrGetCollection0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}",
                    parameters: [
                        input.path.collectionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/collections/{clientId}/orders/stats`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{clientId}/orders/stats/get(CollectionOrdersController-getStatus-0)`.
    public func collectionOrdersControllerGetStatus0(_ input: Operations.CollectionOrdersControllerGetStatus0.Input) async throws -> Operations.CollectionOrdersControllerGetStatus0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetStatus0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/orders/stats",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/collections/{clientId}/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{clientId}/orders/{orderId}/get(CollectionOrdersController-getOrder-0)`.
    public func collectionOrdersControllerGetOrder0(_ input: Operations.CollectionOrdersControllerGetOrder0.Input) async throws -> Operations.CollectionOrdersControllerGetOrder0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetOrder0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/orders/{}",
                    parameters: [
                        input.path.clientId,
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/collections/{clientId}/orders`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/{clientId}/orders/get(CollectionOrdersController-getOrders-0)`.
    public func collectionOrdersControllerGetOrders0(_ input: Operations.CollectionOrdersControllerGetOrders0.Input) async throws -> Operations.CollectionOrdersControllerGetOrders0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionOrdersControllerGetOrders0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections/{}/orders",
                    parameters: [
                        input.path.clientId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recipient",
                    value: input.query.recipient
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderId",
                    value: input.query.orderId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentMethod",
                    value: input.query.paymentMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentStatus",
                    value: input.query.paymentStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "deliveryStatus",
                    value: input.query.deliveryStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeSummary",
                    value: input.query.includeSummary
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "search",
                    value: input.query.search
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "identifier",
                    value: input.query.identifier
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Collections
    ///
    /// Get all collections in a project
    ///
    /// - Remark: HTTP `GET /2022-06-09/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/get(CollectionsController-getCollections-0)`.
    public func collectionsControllerGetCollections0(_ input: Operations.CollectionsControllerGetCollections0.Input) async throws -> Operations.CollectionsControllerGetCollections0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerGetCollections0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Collection
    ///
    /// Create a new collection
    ///
    /// - Remark: HTTP `POST /2022-06-09/collections`.
    /// - Remark: Generated from `#/paths//2022-06-09/collections/post(CollectionsController-createCollection-0)`.
    public func collectionsControllerCreateCollection0(_ input: Operations.CollectionsControllerCreateCollection0.Input) async throws -> Operations.CollectionsControllerCreateCollection0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.CollectionsControllerCreateCollection0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/collections",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/address-autocomplete/suggestions`.
    /// - Remark: Generated from `#/paths//2022-06-09/address-autocomplete/suggestions/get(AddressAutocompleteController-getSuggestions-0)`.
    public func addressAutocompleteControllerGetSuggestions0(_ input: Operations.AddressAutocompleteControllerGetSuggestions0.Input) async throws -> Operations.AddressAutocompleteControllerGetSuggestions0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AddressAutocompleteControllerGetSuggestions0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/address-autocomplete/suggestions",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "query",
                    value: input.query.query
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/address-autocomplete/details`.
    /// - Remark: Generated from `#/paths//2022-06-09/address-autocomplete/details/get(AddressAutocompleteController-getAddressDetails-0)`.
    public func addressAutocompleteControllerGetAddressDetails0(_ input: Operations.AddressAutocompleteControllerGetAddressDetails0.Input) async throws -> Operations.AddressAutocompleteControllerGetAddressDetails0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AddressAutocompleteControllerGetAddressDetails0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/address-autocomplete/details",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "placeId",
                    value: input.query.placeId
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/actions/sendEmail/order-confirmation-email/send`.
    /// - Remark: Generated from `#/paths//2022-06-09/actions/sendEmail/order-confirmation-email/send/get(EmailContentVerificationController-verify-0)`.
    public func emailContentVerificationControllerVerify0(_ input: Operations.EmailContentVerificationControllerVerify0.Input) async throws -> Operations.EmailContentVerificationControllerVerify0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.EmailContentVerificationControllerVerify0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/actions/sendEmail/order-confirmation-email/send",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "orderIdentifier",
                    value: input.query.orderIdentifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "templateIdentifier",
                    value: input.query.templateIdentifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "email",
                    value: input.query.email
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/actions/mintAPI/dequeue`.
    /// - Remark: Generated from `#/paths//2022-06-09/actions/mintAPI/dequeue/get(DequeueController-dequeueGet-0)`.
    public func dequeueControllerDequeueGet0(_ input: Operations.DequeueControllerDequeueGet0.Input) async throws -> Operations.DequeueControllerDequeueGet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DequeueControllerDequeueGet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/actions/mintAPI/dequeue",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/actions/mintAPI/dequeue`.
    /// - Remark: Generated from `#/paths//2022-06-09/actions/mintAPI/dequeue/post(DequeueController-dequeuePost-0)`.
    public func dequeueControllerDequeuePost0(_ input: Operations.DequeueControllerDequeuePost0.Input) async throws -> Operations.DequeueControllerDequeuePost0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.DequeueControllerDequeuePost0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/actions/mintAPI/dequeue",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/actions/{actionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/actions/{actionId}/get(ActionsController-getAction-0)`.
    public func actionsControllerGetAction0(_ input: Operations.ActionsControllerGetAction0.Input) async throws -> Operations.ActionsControllerGetAction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ActionsControllerGetAction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/actions/{}",
                    parameters: [
                        input.path.actionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Orders by Project
    ///
    /// Get all orders for a specific project with filtering and pagination support
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-15/orders`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-15/orders/get(ProjectOrdersController-getProjectOrders-0)`.
    public func projectOrdersControllerGetProjectOrders0(_ input: Operations.ProjectOrdersControllerGetProjectOrders0.Input) async throws -> Operations.ProjectOrdersControllerGetProjectOrders0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.ProjectOrdersControllerGetProjectOrders0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-15/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortBy",
                    value: input.query.sortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortOrder",
                    value: input.query.sortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "projectId",
                    value: input.query.projectId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentMethod",
                    value: input.query.paymentMethod
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "paymentStatus",
                    value: input.query.paymentStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "deliveryStatus",
                    value: input.query.deliveryStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "collectionId",
                    value: input.query.collectionId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "createdAfter",
                    value: input.query.createdAfter
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "createdBefore",
                    value: input.query.createdBefore
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeSummary",
                    value: input.query.includeSummary
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "identifier",
                    value: input.query.identifier
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recipient",
                    value: input.query.recipient
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV2025Controller-submitMeApprovals-0)`.
    public func walletsV2025ControllerSubmitMeApprovals0(_ input: Operations.WalletsV2025ControllerSubmitMeApprovals0.Input) async throws -> Operations.WalletsV2025ControllerSubmitMeApprovals0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitMeApprovals0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals0.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeApprovals0.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/transactions/{transactionId}/get(WalletsV2025Controller-getMeTransaction-0)`.
    public func walletsV2025ControllerGetMeTransaction0(_ input: Operations.WalletsV2025ControllerGetMeTransaction0.Input) async throws -> Operations.WalletsV2025ControllerGetMeTransaction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeTransaction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransaction0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransaction0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/me{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/transactions/get(WalletsV2025Controller-getMeTransactionsWithoutChain-0)`.
    public func walletsV2025ControllerGetMeTransactionsWithoutChain0(_ input: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain0.Input) async throws -> Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeTransactionsWithoutChain0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/me{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/transactions/post(WalletsV2025Controller-createMeTransaction-0)`.
    public func walletsV2025ControllerCreateMeTransaction0(_ input: Operations.WalletsV2025ControllerCreateMeTransaction0.Input) async throws -> Operations.WalletsV2025ControllerCreateMeTransaction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeTransaction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeTransaction0.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token For Authenticated User
    ///
    /// Sends a token of any type from the authenticated user's wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenV2025Controller-sendMeToken-0)`.
    public func walletsSendTokenV2025ControllerSendMeToken0(_ input: Operations.WalletsSendTokenV2025ControllerSendMeToken0.Input) async throws -> Operations.WalletsSendTokenV2025ControllerSendMeToken0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenV2025ControllerSendMeToken0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenV2025ControllerSendMeToken0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/me{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/signers/{signer}/get(WalletsV2025Controller-getMeDelegatedSigner-0)`.
    public func walletsV2025ControllerGetMeDelegatedSigner0(_ input: Operations.WalletsV2025ControllerGetMeDelegatedSigner0.Input) async throws -> Operations.WalletsV2025ControllerGetMeDelegatedSigner0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeDelegatedSigner0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeDelegatedSigner0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeDelegatedSigner0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/me{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/signers/post(WalletsV2025Controller-createMeDelegatedSigner-0)`.
    public func walletsV2025ControllerCreateMeDelegatedSigner0(_ input: Operations.WalletsV2025ControllerCreateMeDelegatedSigner0.Input) async throws -> Operations.WalletsV2025ControllerCreateMeDelegatedSigner0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeDelegatedSigner0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeDelegatedSigner0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV2025Controller-submitMeSignatureApprovals-0)`.
    public func walletsV2025ControllerSubmitMeSignatureApprovals0(_ input: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals0.Input) async throws -> Operations.WalletsV2025ControllerSubmitMeSignatureApprovals0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitMeSignatureApprovals0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/signatures/{signatureId}/get(WalletsV2025Controller-getMeSignature-0)`.
    public func walletsV2025ControllerGetMeSignature0(_ input: Operations.WalletsV2025ControllerGetMeSignature0.Input) async throws -> Operations.WalletsV2025ControllerGetMeSignature0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeSignature0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignature0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignature0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Signatures For Authenticated User
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/me{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/signatures/get(WalletsV2025Controller-getMeSignatures-0)`.
    public func walletsV2025ControllerGetMeSignatures0(_ input: Operations.WalletsV2025ControllerGetMeSignatures0.Input) async throws -> Operations.WalletsV2025ControllerGetMeSignatures0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeSignatures0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignatures0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeSignatures0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/me{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/signatures/post(WalletsV2025Controller-createMeSignatureRequest-0)`.
    public func walletsV2025ControllerCreateMeSignatureRequest0(_ input: Operations.WalletsV2025ControllerCreateMeSignatureRequest0.Input) async throws -> Operations.WalletsV2025ControllerCreateMeSignatureRequest0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeSignatureRequest0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeSignatureRequest0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/me{walletLocator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me{walletLocator}/get(WalletsV2025Controller-getMeWallet-0)`.
    public func walletsV2025ControllerGetMeWallet0(_ input: Operations.WalletsV2025ControllerGetMeWallet0.Input) async throws -> Operations.WalletsV2025ControllerGetMeWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetMeWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetMeWallet0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/me`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/me/post(WalletsV2025Controller-createMeWallet-0)`.
    public func walletsV2025ControllerCreateMeWallet0(_ input: Operations.WalletsV2025ControllerCreateMeWallet0.Input) async throws -> Operations.WalletsV2025ControllerCreateMeWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateMeWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateMeWallet0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV2025Controller-submitApprovals-0)`.
    public func walletsV2025ControllerSubmitApprovals0(_ input: Operations.WalletsV2025ControllerSubmitApprovals0.Input) async throws -> Operations.WalletsV2025ControllerSubmitApprovals0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitApprovals0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals0.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitApprovals0.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV2025Controller-getTransaction-0)`.
    public func walletsV2025ControllerGetTransaction0(_ input: Operations.WalletsV2025ControllerGetTransaction0.Input) async throws -> Operations.WalletsV2025ControllerGetTransaction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetTransaction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransaction0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransaction0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/transactions/get(WalletsV2025Controller-getTransactionsWithoutChain-0)`.
    public func walletsV2025ControllerGetTransactionsWithoutChain0(_ input: Operations.WalletsV2025ControllerGetTransactionsWithoutChain0.Input) async throws -> Operations.WalletsV2025ControllerGetTransactionsWithoutChain0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetTransactionsWithoutChain0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransactionsWithoutChain0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetTransactionsWithoutChain0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/transactions/post(WalletsV2025Controller-createTransaction-0)`.
    public func walletsV2025ControllerCreateTransaction0(_ input: Operations.WalletsV2025ControllerCreateTransaction0.Input) async throws -> Operations.WalletsV2025ControllerCreateTransaction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateTransaction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateTransaction0.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Transfer Token
    ///
    /// Sends a token of any type from this wallet to a recipient
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/tokens/{tokenLocator}/transfers/post(WalletsSendTokenV2025Controller-sendToken-0)`.
    public func walletsSendTokenV2025ControllerSendToken0(_ input: Operations.WalletsSendTokenV2025ControllerSendToken0.Input) async throws -> Operations.WalletsSendTokenV2025ControllerSendToken0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsSendTokenV2025ControllerSendToken0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/tokens/{}/transfers",
                    parameters: [
                        input.path.walletLocator,
                        input.path.tokenLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsSendTokenV2025ControllerSendToken0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsTransactionV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/signers/{signer}/get(WalletsV2025Controller-getDelegatedSigner-0)`.
    public func walletsV2025ControllerGetDelegatedSigner0(_ input: Operations.WalletsV2025ControllerGetDelegatedSigner0.Input) async throws -> Operations.WalletsV2025ControllerGetDelegatedSigner0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetDelegatedSigner0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetDelegatedSigner0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetDelegatedSigner0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Delegated Signer
    ///
    /// Create a delegated signer for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/signers/post(WalletsV2025Controller-createDelegatedSigner-0)`.
    public func walletsV2025ControllerCreateDelegatedSigner0(_ input: Operations.WalletsV2025ControllerCreateDelegatedSigner0.Input) async throws -> Operations.WalletsV2025ControllerCreateDelegatedSigner0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateDelegatedSigner0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerV2025Dto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateDelegatedSigner0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV2025Controller-submitSignatureApprovals-0)`.
    public func walletsV2025ControllerSubmitSignatureApprovals0(_ input: Operations.WalletsV2025ControllerSubmitSignatureApprovals0.Input) async throws -> Operations.WalletsV2025ControllerSubmitSignatureApprovals0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerSubmitSignatureApprovals0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerSubmitSignatureApprovals0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV2025Controller-getSignature-0)`.
    public func walletsV2025ControllerGetSignature0(_ input: Operations.WalletsV2025ControllerGetSignature0.Input) async throws -> Operations.WalletsV2025ControllerGetSignature0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetSignature0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetSignature0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetSignature0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/signatures/get(WalletsV2025Controller-getAllSignatures-0)`.
    public func walletsV2025ControllerGetAllSignatures0(_ input: Operations.WalletsV2025ControllerGetAllSignatures0.Input) async throws -> Operations.WalletsV2025ControllerGetAllSignatures0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetAllSignatures0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetAllSignatures0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsMultipleSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetAllSignatures0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/signatures/post(WalletsV2025Controller-createSignatureRequest-0)`.
    public func walletsV2025ControllerCreateSignatureRequest0(_ input: Operations.WalletsV2025ControllerCreateSignatureRequest0.Input) async throws -> Operations.WalletsV2025ControllerCreateSignatureRequest0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateSignatureRequest0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsSignatureV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateSignatureRequest0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Balance
    ///
    /// Get the balance of a wallet for a given chain and currency
    ///
    /// **API scope required**: `wallets:balance.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/{walletLocator}/balances`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/balances/get(BalanceV20250609Controller-getBalanceForLocator-0)`.
    public func balanceV20250609ControllerGetBalanceForLocator0(_ input: Operations.BalanceV20250609ControllerGetBalanceForLocator0.Input) async throws -> Operations.BalanceV20250609ControllerGetBalanceForLocator0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.BalanceV20250609ControllerGetBalanceForLocator0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}/balances",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chains",
                    value: input.query.chains
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceV20250609ControllerGetBalanceForLocator0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletBalanceV20250609ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.BalanceV20250609ControllerGetBalanceForLocator0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2025-06-09/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/{walletLocator}/get(WalletsV2025Controller-getWalletByLocator-0)`.
    public func walletsV2025ControllerGetWalletByLocator0(_ input: Operations.WalletsV2025ControllerGetWalletByLocator0.Input) async throws -> Operations.WalletsV2025ControllerGetWalletByLocator0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerGetWalletByLocator0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetWalletByLocator0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerGetWalletByLocator0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When owner is provided, subsequent calls with the same owner will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2025-06-09/wallets`.
    /// - Remark: Generated from `#/paths//2022-06-09/2025-06-09/wallets/post(WalletsV2025Controller-createWallet-0)`.
    public func walletsV2025ControllerCreateWallet0(_ input: Operations.WalletsV2025ControllerCreateWallet0.Input) async throws -> Operations.WalletsV2025ControllerCreateWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV2025ControllerCreateWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2025-06-09/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateWallet0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV2025ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV2025ControllerCreateWallet0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/2024-09-26/session/sdk/auth/social/{provider}/start`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/session/sdk/auth/social/{provider}/start/get(AuthSdkSessionController-getOauthUrl-0)`.
    public func authSdkSessionControllerGetOauthUrl0(_ input: Operations.AuthSdkSessionControllerGetOauthUrl0.Input) async throws -> Operations.AuthSdkSessionControllerGetOauthUrl0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerGetOauthUrl0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/session/sdk/auth/social/{}/start",
                    parameters: [
                        input.path.provider
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "appSchema",
                    value: input.query.appSchema
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-api-key",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-app-identifier",
                    value: input.headers.xAppIdentifier
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/2024-09-26/session/sdk/auth/refresh`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/session/sdk/auth/refresh/post(AuthSdkSessionController-refresh-0)`.
    public func authSdkSessionControllerRefresh0(_ input: Operations.AuthSdkSessionControllerRefresh0.Input) async throws -> Operations.AuthSdkSessionControllerRefresh0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerRefresh0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/session/sdk/auth/refresh",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/2024-09-26/session/sdk/auth/otps/send`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/session/sdk/auth/otps/send/post(AuthSdkSessionController-initiateEmailAuthentication-0)`.
    public func authSdkSessionControllerInitiateEmailAuthentication0(_ input: Operations.AuthSdkSessionControllerInitiateEmailAuthentication0.Input) async throws -> Operations.AuthSdkSessionControllerInitiateEmailAuthentication0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerInitiateEmailAuthentication0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/session/sdk/auth/otps/send",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/2024-09-26/session/sdk/auth/logout`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/session/sdk/auth/logout/post(AuthSdkSessionController-logout-0)`.
    public func authSdkSessionControllerLogout0(_ input: Operations.AuthSdkSessionControllerLogout0.Input) async throws -> Operations.AuthSdkSessionControllerLogout0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerLogout0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/session/sdk/auth/logout",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start/post(AuthSdkSessionController-startCryptoWalletAuthentication-0)`.
    public func authSdkSessionControllerStartCryptoWalletAuthentication0(_ input: Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication0.Input) async throws -> Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerStartCryptoWalletAuthentication0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/start",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/2024-09-26/session/sdk/auth/crypto_wallets/authenticate`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/session/sdk/auth/crypto_wallets/authenticate/post(AuthSdkSessionController-authenticateCryptoWallet-0)`.
    public func authSdkSessionControllerAuthenticateCryptoWallet0(_ input: Operations.AuthSdkSessionControllerAuthenticateCryptoWallet0.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateCryptoWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateCryptoWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/session/sdk/auth/crypto_wallets/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/2024-09-26/session/sdk/auth/authenticate`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/session/sdk/auth/authenticate/get(AuthSdkSessionController-authenticateOAuthAuthSDK-0)`.
    public func authSdkSessionControllerAuthenticateOAuthAuthSDK0(_ input: Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK0.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateOAuthAuthSDK0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/session/sdk/auth/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/2024-09-26/session/sdk/auth/authenticate`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/session/sdk/auth/authenticate/post(AuthSdkSessionController-authenticateAuthSDK-0)`.
    public func authSdkSessionControllerAuthenticateAuthSDK0(_ input: Operations.AuthSdkSessionControllerAuthenticateAuthSDK0.Input) async throws -> Operations.AuthSdkSessionControllerAuthenticateAuthSDK0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkSessionControllerAuthenticateAuthSDK0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/session/sdk/auth/authenticate",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "callbackUrl",
                    value: input.query.callbackUrl
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "signinAuthenticationMethod",
                    value: input.query.signinAuthenticationMethod
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/2024-09-26/sdk/auth/user/{externalUserId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/sdk/auth/user/{externalUserId}/get(AuthSdkController-getUserServerSide-0)`.
    public func authSdkControllerGetUserServerSide0(_ input: Operations.AuthSdkControllerGetUserServerSide0.Input) async throws -> Operations.AuthSdkControllerGetUserServerSide0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkControllerGetUserServerSide0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/sdk/auth/user/{}",
                    parameters: [
                        input.path.externalUserId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/2024-09-26/sdk/auth/user`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-09-26/sdk/auth/user/get(AuthSdkController-getUserClientSide-0)`.
    public func authSdkControllerGetUserClientSide0(_ input: Operations.AuthSdkControllerGetUserClientSide0.Input) async throws -> Operations.AuthSdkControllerGetUserClientSide0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthSdkControllerGetUserClientSide0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-09-26/sdk/auth/user",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `GET /2022-06-09/2024-06-09/sdk/smart-wallet/config`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-06-09/sdk/smart-wallet/config/get(SmartWalletSDKController-getConfig-0)`.
    public func smartWalletSDKControllerGetConfig0(_ input: Operations.SmartWalletSDKControllerGetConfig0.Input) async throws -> Operations.SmartWalletSDKControllerGetConfig0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SmartWalletSDKControllerGetConfig0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-06-09/sdk/smart-wallet/config",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /2022-06-09/2024-06-09/sdk/smart-wallet`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-06-09/sdk/smart-wallet/put(SmartWalletSDKController-save-0)`.
    public func smartWalletSDKControllerSave0(_ input: Operations.SmartWalletSDKControllerSave0.Input) async throws -> Operations.SmartWalletSDKControllerSave0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SmartWalletSDKControllerSave0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-06-09/sdk/smart-wallet",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .put
                )
                suppressMutabilityWarning(&request)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/2024-06-09/sdk/paymaster`.
    /// - Remark: Generated from `#/paths//2022-06-09/2024-06-09/sdk/paymaster/post(PaymasterProxyController-sponsorUserOp-0)`.
    public func paymasterProxyControllerSponsorUserOp0(_ input: Operations.PaymasterProxyControllerSponsorUserOp0.Input) async throws -> Operations.PaymasterProxyControllerSponsorUserOp0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.PaymasterProxyControllerSponsorUserOp0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2024-06-09/sdk/paymaster",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction For Authenticated User
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitMeApprovals-0)`.
    public func walletsV1ControllerSubmitMeApprovals0(_ input: Operations.WalletsV1ControllerSubmitMeApprovals0.Input) async throws -> Operations.WalletsV1ControllerSubmitMeApprovals0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeApprovals0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals0.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeApprovals0.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction For Authenticated User
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/me{walletType}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/transactions/{transactionId}/get(WalletsV1Controller-getMeTransaction-0)`.
    public func walletsV1ControllerGetMeTransaction0(_ input: Operations.WalletsV1ControllerGetMeTransaction0.Input) async throws -> Operations.WalletsV1ControllerGetMeTransaction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransaction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/transactions/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransaction0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions For Authenticated User
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/transactions/get(WalletsV1Controller-getMeTransactionsWithoutChain-0)`.
    public func walletsV1ControllerGetMeTransactionsWithoutChain0(_ input: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain0.Input) async throws -> Operations.WalletsV1ControllerGetMeTransactionsWithoutChain0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeTransactionsWithoutChain0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction For Authenticated User
    ///
    /// Creates a new transaction for the authenticated user. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/me{walletType}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/transactions/post(WalletsV1Controller-createMeTransaction-0)`.
    public func walletsV1ControllerCreateMeTransaction0(_ input: Operations.WalletsV1ControllerCreateMeTransaction0.Input) async throws -> Operations.WalletsV1ControllerCreateMeTransaction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeTransaction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/transactions",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeTransaction0.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer For Authenticated User
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/me{walletType}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/signers/{signer}/get(WalletsV1Controller-getMeDelegatedSigner-0)`.
    public func walletsV1ControllerGetMeDelegatedSigner0(_ input: Operations.WalletsV1ControllerGetMeDelegatedSigner0.Input) async throws -> Operations.WalletsV1ControllerGetMeDelegatedSigner0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeDelegatedSigner0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/signers/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeDelegatedSigner0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer For Authenticated User
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/me{walletType}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/signers/post(WalletsV1Controller-createMeDelegatedSigner-0)`.
    public func walletsV1ControllerCreateMeDelegatedSigner0(_ input: Operations.WalletsV1ControllerCreateMeDelegatedSigner0.Input) async throws -> Operations.WalletsV1ControllerCreateMeDelegatedSigner0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeDelegatedSigner0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/signers",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeDelegatedSigner0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature For Authenticated User
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitMeSignatureApprovals-0)`.
    public func walletsV1ControllerSubmitMeSignatureApprovals0(_ input: Operations.WalletsV1ControllerSubmitMeSignatureApprovals0.Input) async throws -> Operations.WalletsV1ControllerSubmitMeSignatureApprovals0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitMeSignatureApprovals0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitMeSignatureApprovals0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature For Authenticated User
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/me{walletType}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/signatures/{signatureId}/get(WalletsV1Controller-getMeSignature-0)`.
    public func walletsV1ControllerGetMeSignature0(_ input: Operations.WalletsV1ControllerGetMeSignature0.Input) async throws -> Operations.WalletsV1ControllerGetMeSignature0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeSignature0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/signatures/{}",
                    parameters: [
                        input.path.walletType,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeSignature0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature For Authenticated User
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/me{walletType}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/signatures/post(WalletsV1Controller-createMeSignatureRequest-0)`.
    public func walletsV1ControllerCreateMeSignatureRequest0(_ input: Operations.WalletsV1ControllerCreateMeSignatureRequest0.Input) async throws -> Operations.WalletsV1ControllerCreateMeSignatureRequest0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeSignatureRequest0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/signatures",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeSignatureRequest0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity For Authenticated User
    ///
    /// Retrieves activity history for the authenticated user's wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/me{walletType}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/activity/get(WalletsV1Controller-getMeWalletActivity-0)`.
    public func walletsV1ControllerGetMeWalletActivity0(_ input: Operations.WalletsV1ControllerGetMeWalletActivity0.Input) async throws -> Operations.WalletsV1ControllerGetMeWalletActivity0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWalletActivity0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}/activity",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWalletActivity0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet For Authenticated User
    ///
    /// Retrieves a wallet for the authenticated user.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/me{walletType}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me{walletType}/get(WalletsV1Controller-getMeWallet-0)`.
    public func walletsV1ControllerGetMeWallet0(_ input: Operations.WalletsV1ControllerGetMeWallet0.Input) async throws -> Operations.WalletsV1ControllerGetMeWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetMeWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me{}",
                    parameters: [
                        input.path.walletType
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetMeWallet0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet For Authenticated User
    ///
    /// Creates a new wallet of specified type for the authenticated user. If called for a user who already has a wallet, returns the existing wallet. Supports both custodial and non-custodial wallet types. Uses client-side API key authentication.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/me`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/me/post(WalletsV1Controller-createMeWallet-0)`.
    public func walletsV1ControllerCreateMeWallet0(_ input: Operations.WalletsV1ControllerCreateMeWallet0.Input) async throws -> Operations.WalletsV1ControllerCreateMeWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateMeWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/me",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateMeWallet0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Transaction
    ///
    /// Submit approval signature for a pending transaction. Required for transactions using external signers.
    ///
    /// **API scope required**: `wallets:transactions.sign`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/approvals/post(WalletsV1Controller-submitApprovals-0)`.
    public func walletsV1ControllerSubmitApprovals0(_ input: Operations.WalletsV1ControllerSubmitApprovals0.Input) async throws -> Operations.WalletsV1ControllerSubmitApprovals0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitApprovals0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/transactions/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 409:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals0.Output.Conflict.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .conflict(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitApprovals0.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transaction
    ///
    /// Retrieves the current status and details of a specific transaction.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/transactions/{transactionId}/get(WalletsV1Controller-getTransaction-0)`.
    public func walletsV1ControllerGetTransaction0(_ input: Operations.WalletsV1ControllerGetTransaction0.Input) async throws -> Operations.WalletsV1ControllerGetTransaction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransaction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/transactions/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.transactionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransaction0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Transactions
    ///
    /// Retrieves all transactions associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:transactions.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/transactions/get(WalletsV1Controller-getTransactionsWithoutChain-0)`.
    public func walletsV1ControllerGetTransactionsWithoutChain0(_ input: Operations.WalletsV1ControllerGetTransactionsWithoutChain0.Input) async throws -> Operations.WalletsV1ControllerGetTransactionsWithoutChain0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetTransactionsWithoutChain0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionsResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetTransactionsWithoutChain0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Transaction
    ///
    /// Creates a new transaction for the specified wallet. Transaction will be automatically broadcast once it has all necessary approvals.
    ///
    /// **API scope required**: `wallets:transactions.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/{walletLocator}/transactions`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/transactions/post(WalletsV1Controller-createTransaction-0)`.
    public func walletsV1ControllerCreateTransaction0(_ input: Operations.WalletsV1ControllerCreateTransaction0.Input) async throws -> Operations.WalletsV1ControllerCreateTransaction0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateTransaction0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/transactions",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2TransactionResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateTransaction0.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2TransactionErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Delegated Signer
    ///
    /// Retrieve details about a specific delegated signer by its locator.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/{walletLocator}/signers/{signer}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/signers/{signer}/get(WalletsV1Controller-getDelegatedSigner-0)`.
    public func walletsV1ControllerGetDelegatedSigner0(_ input: Operations.WalletsV1ControllerGetDelegatedSigner0.Input) async throws -> Operations.WalletsV1ControllerGetDelegatedSigner0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetDelegatedSigner0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/signers/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signer
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetDelegatedSigner0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Register Delegated Signer
    ///
    /// Register a delegated key for a smart wallet with optional restrictions around permissions and expiry date.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/{walletLocator}/signers`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/signers/post(WalletsV1Controller-createDelegatedSigner-0)`.
    public func walletsV1ControllerCreateDelegatedSigner0(_ input: Operations.WalletsV1ControllerCreateDelegatedSigner0.Input) async throws -> Operations.WalletsV1ControllerCreateDelegatedSigner0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateDelegatedSigner0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/signers",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DelegatedSignerDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateDelegatedSigner0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Approve Signature
    ///
    /// Submit approval for a signature to sign a message or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/approvals/post(WalletsV1Controller-submitSignatureApprovals-0)`.
    public func walletsV1ControllerSubmitSignatureApprovals0(_ input: Operations.WalletsV1ControllerSubmitSignatureApprovals0.Input) async throws -> Operations.WalletsV1ControllerSubmitSignatureApprovals0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerSubmitSignatureApprovals0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/signatures/{}/approvals",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerSubmitSignatureApprovals0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signature
    ///
    /// Retrieves details about a specific signature by its ID.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/signatures/{signatureId}/get(WalletsV1Controller-getSignature-0)`.
    public func walletsV1ControllerGetSignature0(_ input: Operations.WalletsV1ControllerGetSignature0.Input) async throws -> Operations.WalletsV1ControllerGetSignature0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetSignature0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/signatures/{}",
                    parameters: [
                        input.path.walletLocator,
                        input.path.signatureId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetSignature0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get All Signatures
    ///
    /// Retrieves all signatures associated with the specified wallet.
    ///
    /// **API scope required**: `wallets:signatures.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/signatures/get(WalletsV1Controller-getAllSignatures-0)`.
    public func walletsV1ControllerGetAllSignatures0(_ input: Operations.WalletsV1ControllerGetAllSignatures0.Input) async throws -> Operations.WalletsV1ControllerGetAllSignatures0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetAllSignatures0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2MultipleSignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetAllSignatures0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Signature
    ///
    /// Creates a new signature for signing messages or typed data.
    ///
    /// **API scope required**: `wallets:signatures.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets/{walletLocator}/signatures`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/signatures/post(WalletsV1Controller-createSignatureRequest-0)`.
    public func walletsV1ControllerCreateSignatureRequest0(_ input: Operations.WalletsV1ControllerCreateSignatureRequest0.Input) async throws -> Operations.WalletsV1ControllerCreateSignatureRequest0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateSignatureRequest0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/signatures",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2SignatureResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateSignatureRequest0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet Activity
    ///
    /// Retrieves activity history for the specified wallet including transactions and other relevant events.
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/{walletLocator}/activity`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/activity/get(WalletsV1Controller-getWalletActivity-0)`.
    public func walletsV1ControllerGetWalletActivity0(_ input: Operations.WalletsV1ControllerGetWalletActivity0.Input) async throws -> Operations.WalletsV1ControllerGetWalletActivity0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletActivity0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/activity",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "chain",
                    value: input.query.chain
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletsV1Alpha2ActivityResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletActivity0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Wallet By Locator
    ///
    /// Retrieves a wallet by its locator (address or user identifier and wallet type)
    ///
    /// **API scope required**: `wallets.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/{walletLocator}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{walletLocator}/get(WalletsV1Controller-getWalletByLocator-0)`.
    public func walletsV1ControllerGetWalletByLocator0(_ input: Operations.WalletsV1ControllerGetWalletByLocator0.Input) async throws -> Operations.WalletsV1ControllerGetWalletByLocator0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerGetWalletByLocator0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}",
                    parameters: [
                        input.path.walletLocator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerGetWalletByLocator0.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get NFTs from Wallet
    ///
    /// Retrieves NFTs from a wallet.
    ///
    /// **API scope required**: `wallets:nfts.read`
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/wallets/{locator}/nfts`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/{locator}/nfts/get(WalletNFTController-getNFTsFromWallet-0)`.
    public func walletNFTControllerGetNFTsFromWallet0(_ input: Operations.WalletNFTControllerGetNFTsFromWallet0.Input) async throws -> Operations.WalletNFTControllerGetNFTsFromWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletNFTControllerGetNFTsFromWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets/{}/nfts",
                    parameters: [
                        input.path.locator
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "perPage",
                    value: input.query.perPage
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "contractAddress",
                    value: input.query.contractAddress
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokenId",
                    value: input.query.tokenId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletNFTControllerGetNFTsFromWallet0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletNFTsResponseDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Wallet
    ///
    /// Creates a new wallet of specified type. If called with an idempotency key or for a user who already has a wallet, returns existing wallet. When linkedUser is provided, subsequent calls with the same linkedUser will return the existing wallet. Supports both custodial and non-custodial wallet types.
    ///
    /// **API scope required**: `wallets.create`
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/wallets`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/wallets/post(WalletsV1Controller-createWallet-0)`.
    public func walletsV1ControllerCreateWallet0(_ input: Operations.WalletsV1ControllerCreateWallet0.Input) async throws -> Operations.WalletsV1ControllerCreateWallet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.WalletsV1ControllerCreateWallet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/wallets",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-API-KEY",
                    value: input.headers.xApiKey
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "x-idempotency-key",
                    value: input.headers.xIdempotencyKey
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet0.Output.Created.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ResponseDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .created(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.WalletsV1ControllerCreateWallet0.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.WalletV1Alpha2ErrorDTO.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Subscription
    ///
    /// Retrieve information about an existing subscription, including expiry time, payment information and recurrency status.
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/subscriptions/{subscriptionId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/subscriptions/{subscriptionId}/get(SubscriptionsController-getSubscription-0)`.
    public func subscriptionsControllerGetSubscription0(_ input: Operations.SubscriptionsControllerGetSubscription0.Input) async throws -> Operations.SubscriptionsControllerGetSubscription0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.SubscriptionsControllerGetSubscription0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/subscriptions/{}",
                    parameters: [
                        input.path.subscriptionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.SubscriptionsControllerGetSubscription0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SubscriptionDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Refresh Order
    ///
    /// Refreshes the quote and availability for a given order.
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/orders/{orderId}/refresh`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/orders/{orderId}/refresh/post(HeadlessCheckoutOrdersController-refreshOrder-0)`.
    public func headlessCheckoutOrdersControllerRefreshOrder0(_ input: Operations.HeadlessCheckoutOrdersControllerRefreshOrder0.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerRefreshOrder0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerRefreshOrder0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/orders/{}/refresh",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerRefreshOrder0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Process payment
    ///
    /// Process payment for an order.
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/orders/{orderId}/payment`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/orders/{orderId}/payment/post(HeadlessCheckoutOrdersController-processPayment-0)`.
    public func headlessCheckoutOrdersControllerProcessPayment0(_ input: Operations.HeadlessCheckoutOrdersControllerProcessPayment0.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerProcessPayment0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerProcessPayment0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/orders/{}/payment",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/orders/{orderId}/3ds/sessions/{sessionId}/authenticate`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/orders/{orderId}/3ds/sessions/{sessionId}/authenticate/post(HeadlessCheckout3DSSController-authenticate-0)`.
    public func headlessCheckout3DSSControllerAuthenticate0(_ input: Operations.HeadlessCheckout3DSSControllerAuthenticate0.Input) async throws -> Operations.HeadlessCheckout3DSSControllerAuthenticate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckout3DSSControllerAuthenticate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/orders/{}/3ds/sessions/{}/authenticate",
                    parameters: [
                        input.path.orderId,
                        input.path.sessionId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 201:
                    return .created(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Order
    ///
    /// Get specific order by ID
    ///
    /// - Remark: HTTP `GET /2022-06-09/2022-06-09/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/orders/{orderId}/get(HeadlessCheckoutOrdersController-get-0)`.
    public func headlessCheckoutOrdersControllerGet0(_ input: Operations.HeadlessCheckoutOrdersControllerGet0.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerGet0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerGet0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/orders/{}",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerGet0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Order
    ///
    /// Update an existing order. You can update the recipient, the payment method and the locale.
    ///
    /// - Remark: HTTP `PATCH /2022-06-09/2022-06-09/orders/{orderId}`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/orders/{orderId}/patch(HeadlessCheckoutOrdersController-update-0)`.
    public func headlessCheckoutOrdersControllerUpdate0(_ input: Operations.HeadlessCheckoutOrdersControllerUpdate0.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerUpdate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerUpdate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/orders/{}",
                    parameters: [
                        input.path.orderId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerUpdate0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Order
    ///
    /// Create a new order
    ///
    /// - Remark: HTTP `POST /2022-06-09/2022-06-09/orders`.
    /// - Remark: Generated from `#/paths//2022-06-09/2022-06-09/orders/post(HeadlessCheckoutOrdersController-create-0)`.
    public func headlessCheckoutOrdersControllerCreate0(_ input: Operations.HeadlessCheckoutOrdersControllerCreate0.Input) async throws -> Operations.HeadlessCheckoutOrdersControllerCreate0.Output {
        try await client.send(
            input: input,
            forOperation: Operations.HeadlessCheckoutOrdersControllerCreate0.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/2022-06-09/2022-06-09/orders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.HeadlessCheckoutOrdersControllerCreate0.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SchemaHolderClass.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
